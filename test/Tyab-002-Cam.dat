comments{
}
info{
rowcount:64
colcount:64
camerapos:Translation: X=4160.074 Y=3567.921 Z=53.139 Rotation: P=51.640198 Y=8.350806 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
biome:rock
creator:Tyab
erosioninitialwaittime:4
version:2023-08-14-1
initialcrystals:0
initialore:0
oxygen:90/2300
levelname:Back To The Path To Power
camerazoom:2500.0
erosionscale:1.0
opencaves:11,13/
spiderrate:10
spidermin:2
spidermax:4
}
tiles{
38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,
38,38,163,163,26,26,26,163,163,26,26,26,26,26,163,163,163,26,26,50,50,26,26,101,101,101,38,34,38,38,101,101,26,42,38,38,38,101,101,101,101,38,38,38,38,101,101,101,101,38,38,101,101,101,26,42,38,34,101,101,102,101,101,38,
38,38,26,38,38,38,38,111,111,38,38,38,38,38,38,42,38,38,38,105,102,38,38,34,38,101,101,101,38,38,101,38,38,101,38,34,38,101,38,38,101,38,34,38,42,101,38,38,101,38,38,101,38,38,38,101,38,38,101,38,34,38,101,38,
38,38,26,38,111,111,111,111,111,111,111,111,111,38,38,38,38,38,38,163,163,30,38,38,38,34,38,101,101,105,101,38,34,101,101,101,103,101,38,38,101,101,101,101,26,38,38,38,101,101,101,101,38,38,38,101,101,103,101,38,38,38,101,38,
38,38,26,111,111,111,42,42,42,42,111,111,111,111,38,38,105,102,103,110,104,105,102,38,38,38,38,38,38,38,38,38,38,34,34,38,38,38,38,38,38,38,34,34,38,38,38,38,38,38,38,38,38,38,38,38,38,38,34,38,38,101,101,38,
38,38,26,111,111,38,38,38,38,42,111,111,163,111,26,26,104,110,105,110,101,105,103,34,26,101,163,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,101,38,38,
38,38,163,111,111,38,38,3,38,38,38,111,111,38,38,104,105,103,104,101,101,110,105,38,38,38,101,38,38,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,38,38,38,101,38,38,
38,38,163,111,111,26,38,1,5,38,38,42,42,38,38,26,26,103,110,102,101,101,38,38,38,38,163,38,38,106,163,101,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,101,163,101,106,106,101,102,101,101,106,106,38,38,50,163,163,38,
38,38,38,111,111,38,38,63,10,38,38,38,38,38,38,38,38,26,105,103,105,26,38,38,38,38,101,38,38,106,101,106,101,163,101,163,101,101,163,101,101,163,101,106,163,101,163,106,106,101,106,106,105,106,106,101,163,101,101,26,50,38,26,38,
38,38,50,38,38,38,3,1,5,38,38,38,1,1,10,4,38,38,38,38,38,26,38,38,163,101,163,38,38,106,101,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,163,106,106,163,106,106,106,106,106,106,38,38,38,42,38,
38,38,26,38,38,38,5,1,10,63,10,1,63,1,1,1,5,38,38,38,38,101,38,38,163,38,38,38,38,106,101,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,101,106,106,104,106,106,106,106,106,106,38,38,38,163,38,
38,50,111,38,38,4,2,10,63,63,63,63,1,5,63,63,10,3,34,26,26,26,38,38,101,38,38,38,38,106,101,106,106,101,101,101,101,101,101,101,101,101,101,101,101,101,101,106,106,163,106,106,101,101,103,106,106,106,38,38,38,38,163,38,
38,38,163,38,38,38,2,1,1,63,63,1,1,1,1,1,4,38,38,38,38,26,38,38,26,26,101,38,38,106,101,101,101,106,106,106,106,106,106,106,106,106,106,106,106,106,101,106,106,101,106,106,106,106,101,101,163,106,38,38,34,163,163,38,
38,38,163,38,38,38,5,10,5,38,38,38,6,1,4,9,38,38,38,38,38,110,38,38,38,38,163,38,38,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,101,106,106,163,106,106,106,106,106,106,101,106,38,38,34,163,38,38,
38,38,163,38,38,3,1,1,5,38,38,38,38,38,38,34,38,38,38,38,38,101,38,38,38,38,101,38,38,106,106,106,106,106,106,101,101,106,106,101,101,101,101,106,106,106,101,106,106,106,101,163,106,106,106,106,101,106,106,38,38,163,38,38,
38,38,102,38,38,2,1,2,2,38,38,38,38,38,38,38,38,38,38,38,38,26,38,38,38,38,101,38,38,106,101,101,101,106,101,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,106,106,163,163,106,106,163,106,106,38,38,163,163,38,
38,38,110,38,38,10,63,5,4,38,38,38,38,38,38,38,38,103,101,38,38,26,34,38,38,38,163,38,38,106,101,106,106,101,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,106,106,106,101,106,106,106,163,106,38,38,38,163,38,
38,38,111,38,38,3,1,2,2,38,38,38,38,38,38,26,26,110,101,102,102,104,38,38,38,38,101,38,38,106,101,106,106,106,106,106,101,106,106,101,106,106,106,106,101,106,106,101,106,106,106,106,106,101,106,106,106,101,106,38,38,38,163,38,
38,38,163,38,38,38,1,63,1,38,38,38,4,1,1,26,26,102,101,104,101,103,105,34,38,38,163,38,38,106,101,106,106,106,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,106,163,101,163,106,106,101,106,106,38,38,34,163,38,
38,38,163,163,38,38,38,1,1,10,38,38,1,63,1,10,38,38,102,110,110,101,105,34,38,38,163,38,38,106,101,106,106,106,106,106,101,106,106,101,106,106,106,101,106,106,101,106,106,106,163,106,106,106,106,106,163,106,106,38,38,34,163,38,
38,38,111,163,38,38,38,38,1,1,63,1,63,1,38,38,38,34,102,38,38,106,106,38,38,38,163,38,38,106,101,106,106,106,106,101,106,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,106,106,106,101,106,38,38,38,38,163,38,
38,38,111,111,38,38,38,38,38,3,3,10,5,4,38,38,38,34,103,34,34,104,104,38,38,38,103,38,38,106,101,101,101,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,101,106,106,106,101,163,101,106,106,38,38,38,105,105,38,
38,38,163,163,34,38,38,38,38,38,5,38,38,38,38,38,38,50,105,34,38,34,38,38,38,38,101,38,38,106,106,106,101,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,163,106,106,163,106,106,106,106,106,38,38,42,26,38,38,
38,50,163,38,38,38,38,38,34,38,11,38,38,38,38,38,38,26,38,38,38,34,38,38,38,38,26,38,38,106,106,106,101,106,106,101,106,106,106,101,106,106,106,101,106,106,101,106,106,106,163,101,106,106,38,38,38,38,38,38,105,38,38,38,
38,38,163,34,38,26,163,163,163,38,38,38,38,38,38,38,26,26,38,38,38,163,38,38,38,38,50,38,38,106,101,101,101,106,106,101,106,106,106,101,106,106,106,101,101,101,101,106,106,106,106,106,106,106,38,38,38,38,38,38,105,38,38,38,
38,38,26,38,38,26,111,111,26,38,38,38,26,26,111,163,111,38,38,38,163,163,26,38,163,163,101,38,38,38,26,38,38,38,38,101,101,101,101,106,38,38,106,106,106,106,106,106,38,38,38,38,38,38,38,38,38,38,38,38,163,38,38,38,
38,38,42,38,38,163,111,111,26,42,111,163,105,111,111,163,111,38,38,38,163,38,38,38,38,38,101,38,38,38,34,38,38,38,38,38,106,106,106,106,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,163,38,38,38,
38,38,163,163,111,163,111,111,111,111,111,111,111,111,111,163,111,38,50,26,34,50,38,38,26,38,163,101,163,101,163,101,163,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,34,38,38,38,38,38,38,38,163,163,38,38,
38,38,111,111,111,111,111,111,111,111,111,111,111,111,111,163,111,38,53,163,50,38,38,101,26,38,38,38,34,38,34,38,26,42,38,50,38,38,38,38,38,38,38,38,38,38,38,50,38,34,34,42,163,163,101,38,38,38,38,38,38,163,38,38,
38,38,111,111,111,111,111,111,111,111,111,111,111,26,26,163,111,34,53,101,53,38,38,101,38,38,38,38,38,38,38,38,38,163,163,101,163,163,101,163,163,106,163,101,163,101,163,163,163,101,163,50,38,38,101,38,38,38,38,38,38,163,38,38,
38,34,163,111,163,163,163,111,111,111,163,111,163,42,26,111,111,34,53,163,53,38,38,163,38,38,38,38,38,38,38,38,38,34,38,50,38,38,38,38,38,38,38,38,38,38,38,50,38,38,26,38,38,38,106,106,106,38,38,38,26,26,38,38,
38,34,163,111,111,111,163,163,163,163,163,111,111,111,111,38,38,38,53,163,53,38,38,163,163,101,101,163,101,101,163,101,38,38,38,38,38,34,34,34,34,34,34,34,34,34,34,34,34,38,42,38,38,101,101,38,38,38,38,38,102,38,38,38,
38,34,26,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,53,163,53,38,38,38,38,38,38,38,38,38,38,42,26,101,101,106,101,109,109,109,109,109,109,109,109,109,109,109,101,163,163,34,38,163,38,38,38,38,38,101,101,38,38,38,
38,34,26,38,38,38,34,34,34,38,38,34,34,34,34,38,38,38,53,163,53,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,42,34,34,34,34,34,34,34,34,34,34,34,38,26,38,38,38,101,38,38,38,38,38,104,38,38,38,38,
38,34,163,111,111,111,163,26,42,111,111,163,163,163,163,26,26,38,50,26,50,38,38,101,101,112,112,112,101,101,38,38,38,38,38,38,26,38,38,38,38,38,38,38,26,26,26,26,38,42,38,38,38,163,38,38,38,38,26,101,38,38,38,38,
38,38,26,111,111,163,163,111,163,111,111,163,111,111,111,111,42,38,50,26,26,38,101,101,101,112,112,112,101,101,101,38,38,38,38,38,26,26,163,101,106,101,42,26,101,38,38,42,26,101,34,38,101,110,34,38,38,38,26,38,38,38,38,38,
38,38,42,163,163,111,111,111,163,111,163,163,111,111,111,111,163,38,50,38,38,101,101,101,101,101,163,101,101,101,101,101,38,38,38,38,34,38,34,38,38,38,38,38,38,38,38,38,38,38,38,38,163,38,38,38,58,101,101,56,58,58,57,38,
38,38,111,111,111,111,111,111,111,111,111,111,111,111,163,111,163,38,38,38,101,101,101,101,101,101,163,101,101,101,101,101,101,38,38,38,26,38,38,38,38,38,38,38,38,38,34,38,38,38,38,38,101,38,38,38,57,56,106,101,101,101,58,38,
38,38,111,111,111,111,111,111,111,111,111,111,111,111,163,111,111,38,38,38,101,101,101,101,101,101,110,101,101,101,101,101,101,38,38,26,26,38,38,101,163,110,101,163,102,101,101,163,110,101,110,101,163,38,38,38,38,58,103,101,105,101,58,38,
38,34,26,163,163,163,163,163,163,163,163,163,111,111,163,111,111,38,38,38,112,112,101,101,101,38,38,38,101,101,101,112,112,38,38,163,38,38,38,34,38,38,34,38,38,38,34,38,38,38,38,38,34,42,101,163,38,58,101,101,105,101,58,38,
38,34,42,111,111,111,111,111,111,111,111,163,111,111,111,163,26,34,38,38,112,112,163,163,110,38,50,38,110,163,163,112,112,38,38,163,38,38,101,42,38,38,42,38,38,38,42,38,38,38,38,38,38,38,38,101,38,57,58,56,101,101,58,38,
38,34,163,111,111,111,111,111,111,111,111,111,163,111,111,111,42,34,38,38,112,112,101,101,101,38,38,38,101,101,101,112,112,38,38,101,38,38,163,38,38,38,163,38,38,38,163,38,38,101,163,101,163,38,38,34,38,38,38,57,56,106,58,38,
38,38,111,163,163,163,111,163,111,42,42,111,163,111,111,111,163,34,38,38,101,101,101,101,101,101,110,101,101,101,101,101,101,38,38,163,38,38,34,38,38,38,34,38,38,38,34,38,38,163,38,38,26,26,38,42,101,163,38,38,58,101,58,38,
38,38,111,111,111,111,111,163,111,42,42,111,163,163,163,163,111,38,38,38,101,101,101,101,101,101,163,101,101,101,101,101,101,38,38,110,38,38,42,38,38,38,42,38,38,38,42,38,38,101,38,38,38,101,38,38,38,101,101,38,58,101,58,38,
38,38,111,111,111,111,111,163,111,111,111,111,111,111,111,111,111,38,38,38,38,101,101,101,101,101,163,101,101,101,101,101,38,38,38,163,38,38,163,34,38,101,163,34,38,34,104,38,38,101,163,34,38,163,38,38,38,38,34,38,58,106,58,38,
38,34,26,163,163,163,163,111,111,111,111,111,111,111,111,111,111,38,38,38,38,38,101,101,101,112,112,112,101,101,101,38,38,38,38,106,38,38,34,38,38,34,38,38,38,38,34,42,38,38,101,38,38,101,26,26,38,38,42,38,58,101,58,38,
38,34,42,111,111,111,111,111,111,163,163,163,163,163,163,163,26,34,38,38,26,26,38,101,101,112,112,112,101,101,38,38,38,38,38,163,38,38,42,38,38,42,38,38,38,38,38,163,38,38,163,38,38,38,38,101,38,38,101,38,57,26,57,38,
38,34,163,111,111,111,111,111,163,111,111,111,111,111,111,111,42,34,38,38,163,38,38,38,38,38,38,38,38,38,38,38,38,38,38,110,38,38,34,38,38,101,163,101,34,38,38,34,38,38,101,34,38,38,38,163,101,111,163,38,58,26,58,38,
38,38,163,163,163,163,163,163,163,111,111,111,111,111,111,111,163,34,38,34,163,38,38,38,38,38,38,38,38,38,38,38,38,38,38,163,38,38,42,38,38,38,38,38,42,38,38,42,38,38,38,42,38,38,38,38,38,38,38,38,58,106,58,38,
38,38,111,111,111,111,111,111,111,111,111,163,163,111,163,163,163,38,38,38,163,163,163,163,163,163,26,38,38,105,42,42,38,38,38,42,26,38,163,101,38,38,38,38,106,38,38,106,38,38,38,106,38,42,42,42,42,42,42,38,38,38,38,38,
38,38,111,111,111,111,111,111,111,111,163,111,111,111,111,111,111,38,38,38,38,38,38,38,38,38,42,38,38,105,165,26,38,38,38,38,26,38,38,34,38,38,38,38,102,38,38,105,38,38,38,101,38,42,101,101,101,101,42,38,38,38,38,38,
38,34,163,163,163,163,111,111,111,163,111,111,111,111,111,111,111,38,38,38,38,38,38,38,38,38,163,38,38,105,165,163,38,38,38,38,163,38,38,34,101,101,105,34,34,163,34,34,101,101,34,34,38,42,101,101,101,110,42,38,38,38,38,38,
38,34,163,111,111,163,111,111,163,111,111,111,163,163,163,163,111,38,38,38,38,163,163,163,163,111,163,38,38,165,165,42,38,38,38,38,101,38,38,34,38,38,38,38,38,38,38,38,38,38,38,38,38,42,42,34,42,42,42,38,38,38,38,38,
38,34,26,111,111,163,111,111,163,111,111,163,111,111,111,111,163,163,38,38,38,163,38,38,38,38,38,38,38,102,105,26,38,38,38,38,163,38,38,34,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,
38,34,42,111,111,163,111,111,163,111,111,163,111,165,165,165,163,42,38,38,38,26,38,38,38,38,34,38,38,101,111,163,111,111,38,38,110,38,38,163,163,111,163,38,38,163,101,163,101,42,42,26,38,38,34,34,34,34,34,34,34,38,38,38,
38,34,163,111,111,163,111,111,163,111,111,163,111,165,42,26,163,42,38,38,38,26,38,38,111,111,111,111,105,105,111,111,42,38,38,38,101,38,38,163,163,163,111,38,38,101,165,165,165,165,165,163,38,38,101,101,101,101,101,101,101,106,38,38,
38,34,163,111,111,163,163,163,163,111,111,163,111,165,42,26,165,38,38,38,111,163,111,111,111,111,111,111,111,111,111,111,42,42,38,38,163,38,38,111,163,111,163,38,38,163,165,105,101,105,165,101,38,38,101,101,101,101,101,101,101,101,42,38,
38,34,163,111,111,111,111,111,111,111,111,163,111,165,105,165,163,38,38,38,163,111,111,111,111,111,111,111,105,111,111,111,111,38,38,38,101,38,38,163,111,163,111,38,38,101,165,105,165,101,165,101,38,38,124,124,124,101,101,101,101,101,42,38,
38,34,163,111,111,111,111,111,111,111,111,163,111,165,26,38,163,38,38,38,111,111,111,111,111,111,111,111,111,111,111,111,38,38,38,163,110,38,38,111,163,111,163,38,38,163,165,105,165,105,165,163,34,38,124,124,124,124,114,114,101,101,42,38,
38,34,26,42,163,163,163,163,111,163,26,42,111,165,42,42,163,38,38,38,163,111,111,111,163,105,111,111,105,111,111,111,34,38,38,101,38,38,34,163,111,163,111,38,38,101,165,165,165,101,165,101,34,38,114,124,114,124,114,114,101,101,42,38,
38,38,38,38,38,38,38,50,38,38,38,38,38,38,34,34,34,38,38,38,111,163,111,163,111,111,105,105,111,111,111,111,38,38,38,109,38,38,34,111,163,111,163,38,38,163,101,105,101,105,165,163,34,38,114,114,114,114,124,114,101,101,42,38,
38,38,38,38,38,38,38,50,38,38,38,38,38,38,38,38,38,38,38,38,111,111,111,111,111,111,111,111,111,111,111,101,34,26,101,163,38,38,34,163,111,163,111,38,38,165,165,165,165,165,165,101,34,38,114,114,114,114,114,114,101,101,42,38,
38,38,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,50,50,111,38,34,34,34,38,38,38,38,38,38,38,38,38,38,38,38,38,38,111,163,111,163,26,42,163,163,101,106,101,163,163,34,38,42,42,42,42,42,42,42,42,42,38,
38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,
}
height{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,9,-25,-27,-24,5,-50,2,-13,4,-18,-15,-28,30,103,132,127,195,249,238,312,294,217,205,196,115,123,130,225,380,116,11,62,265,209,305,257,224,159,153,148,195,339,254,367,146,71,140,177,165,281,267,56,149,177,211,179,426,231,165,204,190,180,181,0,
0,-20,17,-9,-15,-73,-67,-83,-54,-76,-48,-27,-105,9,-44,-1,180,219,321,314,341,295,246,233,163,115,50,51,60,363,193,43,131,208,103,424,344,235,181,208,225,294,579,390,473,235,189,195,125,178,618,251,130,35,202,258,198,613,152,180,142,84,30,171,0,
0,16,-27,-30,-83,-25,-63,-68,-60,-44,-60,-69,-108,7,-17,121,65,77,154,273,349,305,271,256,285,120,-42,-55,-68,-11,133,78,268,177,119,180,147,118,146,256,231,337,253,220,271,250,310,240,216,193,312,188,128,345,488,318,363,308,208,213,346,544,39,105,0,
0,-13,-95,-64,-134,-81,-30,-32,-79,-82,-54,-77,-43,-33,-53,-65,90,50,160,224,294,262,160,206,208,97,91,-41,-74,87,145,149,256,237,188,130,115,107,162,289,308,267,343,312,257,262,333,350,333,258,224,228,237,326,475,410,387,255,243,246,338,249,96,86,0,
0,12,-150,-38,12,-14,-61,-112,-19,-83,-60,-70,-70,-83,-64,-70,7,-9,140,173,271,281,164,170,118,30,-69,-22,147,74,324,277,381,218,226,231,200,185,-42,388,477,342,231,238,330,281,-138,424,396,257,192,217,386,491,631,455,363,387,293,301,343,58,147,135,0,
0,2,38,-83,-105,-99,-77,-132,-182,-72,0,-77,-60,-65,-70,17,47,78,230,217,206,233,209,97,103,57,-29,-55,-158,-1107,-997,-1072,-1192,-1224,-1208,-1270,-1077,-1073,-1006,-944,-820,-836,-782,-838,-922,-954,-899,-997,-965,-993,-922,-1009,-1065,-1064,-927,-751,-886,-716,-759,300,17,40,67,-1,0,
0,-35,-18,-74,-24,-92,-59,-106,-121,-165,-40,-60,-60,-60,-45,-3,116,158,139,129,115,125,156,291,203,1,-56,8,-199,-930,-772,-833,-842,-1399,-1273,-1441,-1205,-1108,-1232,-1224,-881,-978,-813,-925,-856,-813,-922,-796,-756,-720,-669,-1174,-819,-751,-624,-507,-324,-533,-330,153,-41,12,31,109,0,
0,61,79,21,-40,48,24,-64,-44,-36,-6,14,23,24,88,32,-4,159,238,133,132,22,81,256,196,-5,30,-107,-107,-890,-760,-750,-885,-942,-965,-1001,-1009,-1014,-881,-775,-660,-498,-391,-509,-551,-598,-716,-749,-798,-700,-733,-1102,-770,-815,-662,-483,-278,-239,16,-68,-6,37,-59,-12,0,
0,4,111,89,103,64,24,-56,-37,-1,83,49,-52,25,31,-83,38,195,219,202,115,17,73,226,240,-40,-14,-138,-210,-936,-658,-822,-811,-918,-964,-965,-866,-888,-908,-877,-708,-559,-507,-493,-503,-520,-769,-711,-1037,-785,-791,-1149,-744,-791,-1014,-290,-265,-150,-36,3,73,63,127,26,0,
0,1,151,128,89,77,38,20,-30,7,88,-52,-56,-39,158,64,-108,-13,172,198,180,185,157,242,179,46,-20,-110,-581,-894,-712,-815,-1387,-1426,-1531,-1543,-1681,-1597,-1464,-1377,-1360,-1442,-1416,-1465,-1423,-1618,-1529,-1532,-1477,-1041,-951,-1251,-791,-831,-978,-1079,-940,-588,-542,-345,-204,322,-45,22,0,
0,-37,172,172,92,10,45,-50,-130,-117,-104,-137,-24,-10,142,136,-67,55,104,233,186,106,158,151,171,46,64,-59,-209,-879,-724,-889,-1333,-1198,-1278,-1312,-1384,-1427,-1267,-1371,-1226,-1327,-1236,-1342,-1241,-1424,-1441,-1379,-1600,-1139,-1058,-1230,-732,-789,-814,-801,-930,-936,-1003,-508,-79,-164,97,41,0,
0,14,138,224,103,65,37,-50,-170,-170,-120,-150,-110,-80,-60,29,-110,84,158,213,173,48,51,159,161,99,-51,-167,-349,-944,-783,-826,-1026,-1168,-1291,-1340,-1372,-1407,-1365,-1298,-1257,-1285,-1266,-1379,-1371,-1410,-1357,-1534,-1647,-1273,-1220,-1399,-703,-753,-718,-767,-788,-723,-1035,-482,-185,-164,-85,-3,0,
0,20,131,207,163,84,44,-100,-190,-110,-40,-100,-160,-180,-170,-122,-112,127,138,86,158,79,101,128,99,51,-36,-114,-327,-940,-751,-833,-988,-1129,-1576,-1738,-1812,-2036,-2005,-1860,-1878,-1794,-1938,-1940,-1858,-1786,-1543,-1648,-1822,-1320,-1269,-1718,-1564,-1433,-724,-769,-778,-752,-1021,-638,-178,-111,-18,-61,0,
0,21,130,111,152,75,27,-50,-140,-40,-17,34,-161,-197,-27,-61,-34,134,135,176,97,84,149,135,145,105,81,5,-164,-964,-1105,-1126,-1358,-1618,-1806,-1106,-1129,-1139,-1867,-1573,-1551,-1575,-1638,-1627,-2036,-2115,-1767,-1784,-1965,-1276,-1277,-1291,-1385,-1655,-1502,-1288,-715,-824,-1150,-1103,-207,-40,-39,3,0,
0,-14,128,70,160,60,40,0,-100,-110,2,51,29,47,-36,-74,-55,121,209,160,226,65,152,166,141,109,-116,-21,-219,-862,-554,-628,-654,-851,-1085,-1113,-1192,-1180,-1730,-1521,-1732,-1503,-1584,-1689,-1697,-2252,-1738,-1777,-1709,-2109,-1305,-1292,-1268,-1255,-1238,-1381,-729,-824,-860,-1131,-171,-214,-168,-88,0,
0,-16,33,211,11,-140,-80,0,-100,-116,-58,38,-47,-32,-56,-48,-93,73,160,223,217,28,117,154,91,12,31,-55,-181,-795,-605,-597,-613,-781,-1055,-1071,-1233,-1179,-1816,-1540,-1645,-1949,-2096,-1725,-1659,-2295,-2352,-1727,-1676,-1942,-2108,-1741,-1267,-1220,-1250,-1460,-751,-790,-791,-1098,-192,-221,-264,0,0,
0,0,16,48,17,-97,-80,-70,-190,-106,-14,-49,-11,-16,-24,-27,-41,94,95,194,214,101,196,157,196,-63,117,-39,-196,-803,-530,-535,-817,-791,-999,-1533,-1200,-1222,-1885,-1491,-1527,-1860,-2225,-1741,-1688,-1711,-2198,-1737,-1741,-1974,-2135,-1812,-1597,-1250,-1187,-1355,-1272,-843,-730,-1091,-147,-208,-275,41,0,
0,5,-4,-22,-43,1,-70,-70,-160,-60,-62,-64,-50,-57,-70,-30,-34,91,103,175,202,161,110,43,156,92,-39,-106,-117,-675,-524,-492,-969,-1073,-1221,-1305,-1198,-1096,-1710,-1509,-1479,-1910,-2037,-1679,-1678,-1630,-2409,-1725,-1765,-2003,-2021,-1302,-1263,-1205,-1195,-1397,-873,-834,-854,-1116,-660,-165,-96,0,0,
0,1,-24,-66,-3,-24,-110,-160,-160,-160,-250,-100,-100,-60,-70,20,12,175,234,246,223,112,79,142,141,109,-48,-54,-205,-723,-415,-384,-744,-885,-1026,-1306,-1169,-1136,-1410,-1402,-1507,-1664,-2102,-1646,-1489,-2117,-1943,-1857,-1871,-2197,-1272,-1285,-1230,-1238,-1154,-1407,-803,-857,-1030,-954,-409,-215,-149,-13,0,
0,0,-49,-44,-39,-97,-105,-150,-150,-160,-200,-190,-100,-10,-70,-30,-2,239,263,229,186,99,165,220,137,86,-68,-33,-145,-711,-483,-397,-743,-973,-1201,-930,-987,-960,-1556,-1426,-1357,-1856,-1535,-1517,-1467,-2056,-1780,-1794,-2013,-2128,-1223,-1242,-1509,-1563,-1489,-1265,-782,-714,-987,-1007,103,-155,-80,-8,0,
0,0,24,12,-151,-59,-92,-77,-100,-110,-150,-150,-100,-110,-20,20,77,231,221,279,308,231,260,203,258,19,-148,-140,-64,-644,-334,-358,-336,-338,-1066,-878,-1027,-1226,-1166,-1256,-1257,-1768,-1367,-1403,-1840,-1944,-1676,-1783,-1968,-1135,-1221,-1231,-1346,-974,-930,-777,-692,-724,-1025,-145,-126,-161,-31,22,0,
0,36,17,-54,-58,-75,-44,-138,-84,-105,-120,-110,-106,-117,-57,-9,78,312,176,183,286,173,236,218,146,88,-61,-86,93,-498,-333,-380,-391,-348,-992,-933,-889,-1369,-1199,-1156,-1447,-1644,-1285,-1320,-1736,-1952,-1548,-1594,-1928,-1074,-1080,-1437,-894,-898,-834,-731,-680,-897,-964,-239,-218,-120,-14,4,0,
0,-30,66,85,4,0,-70,-75,-109,-67,-17,-20,-5,32,-79,44,51,147,148,116,290,143,170,118,181,56,-175,28,-20,-516,-455,-375,-292,-317,-782,-755,-886,-1207,-928,-936,-932,-1637,-1236,-1240,-1285,-1714,-1489,-1419,-1501,-1001,-944,-843,-871,-800,-1035,-926,-882,-814,-925,-257,-166,-21,-54,0,0,
0,16,78,6,62,-1,90,-33,-5,129,-13,20,34,-13,-73,74,59,139,102,162,160,149,128,232,211,56,-27,45,126,-340,-41,-139,-214,-235,-842,-710,-704,-1147,-1110,-792,-829,-1448,-1423,-1220,-1239,-1246,-1267,-1200,-1543,-1270,-938,-825,-808,-952,-1122,-749,-635,-369,-393,-176,-208,15,-49,0,0,
0,17,36,2,-26,51,10,-18,5,-1,21,2,29,58,46,83,70,31,85,42,66,67,104,103,15,133,-61,-44,-3,-265,-53,-100,-188,-195,-496,-587,-572,-683,-713,-679,-795,-1380,-1358,-1155,-1179,-1186,-1148,-1181,-1441,-1392,-1225,-1142,-1043,-1074,-1084,-564,-349,-353,-309,-135,4,16,1,0,0,
0,-12,-8,98,40,113,19,-36,-22,171,13,-24,95,12,33,-11,23,24,-2,69,45,61,33,41,119,50,47,39,135,-13,28,-23,-12,-5,-67,-508,-531,-596,-659,-679,-979,-678,-1326,-1324,-1338,-1342,-1343,-1377,-1337,-741,-633,-601,-505,-356,-436,-339,-207,-98,-134,41,91,-65,27,0,0,
0,3,122,92,-32,8,7,0,-26,-29,-38,-9,-43,-36,-154,72,-17,-23,-22,45,45,36,38,34,56,24,-36,-26,22,0,6,-47,-38,-30,-36,6,-711,-800,-790,-794,-981,-614,-561,-512,-471,-499,-494,-620,-254,-340,-446,-69,-146,-88,-34,-33,16,98,69,66,46,99,-15,0,0,
0,-8,16,-7,-21,7,-6,-50,-50,41,-63,-21,-1,-99,-51,-51,34,-1,-10,72,72,72,72,0,0,0,0,-2,-37,30,-28,-48,0,-21,-7,17,-9,-82,-85,-143,-164,-83,-127,-139,-102,-104,-33,-88,-35,-43,-19,-25,-24,-21,64,135,87,135,-11,72,28,77,32,0,0,
0,7,-38,19,-116,-6,48,0,50,0,-150,-50,0,8,31,0,6,18,0,27,27,27,27,0,0,0,0,0,0,0,0,-34,-44,-67,13,49,122,-71,-18,-109,-123,-128,-109,-108,-256,-179,-90,-33,-90,-8,31,19,2,18,75,33,62,77,37,-78,0,0,0,0,0,
0,4,1,-46,71,-52,28,-63,-12,-12,14,-59,15,-20,35,-7,-73,3,7,27,27,27,27,0,0,0,0,0,0,0,0,0,-38,54,-7,-50,-48,-12,-38,-33,-63,-34,4,9,-38,-77,-9,-15,-42,-4,-61,2,-1,110,-9,-66,-100,-101,48,16,0,0,0,0,0,
0,-1,102,-29,13,48,8,48,-31,-88,-91,0,-18,26,20,-108,-79,-60,10,27,27,27,27,0,0,0,0,0,0,0,0,0,0,0,0,0,-18,-14,0,-13,-14,-36,59,3,-29,25,-25,15,-45,-10,0,-29,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-36,-66,-53,-68,41,61,104,-26,48,-64,22,-123,146,22,-102,82,2,-3,-30,-18,0,0,0,0,0,0,0,0,0,0,0,0,-3,-11,4,0,-71,-256,-121,-149,-146,-164,-80,-208,-198,-179,-187,-116,-4,-30,2,-4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,48,-93,25,-32,-56,-18,45,-190,51,-89,-75,-71,-30,-7,-43,-44,-91,4,16,0,0,0,0,0,0,0,0,0,0,0,0,0,6,-5,25,-149,-166,-150,-134,-177,-162,-84,-214,-247,-121,-124,-100,25,-14,-16,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-28,-14,-1,-32,5,-54,1,-33,-43,92,-147,-59,1,82,-20,-18,21,56,-14,-2,-23,0,0,0,0,0,0,0,0,0,0,0,0,0,49,-29,33,37,39,6,16,52,59,82,-9,9,54,-38,31,0,-20,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,14,-13,1,22,13,-15,-31,31,28,-24,33,-15,-9,12,38,-4,-8,-41,37,-43,27,0,0,0,0,0,0,0,0,0,0,0,0,0,27,49,-5,-14,48,14,-41,5,-15,-5,2,6,15,28,65,20,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,48,0,19,2,-61,1,14,-8,-81,7,6,20,-42,-60,22,8,-43,-67,11,29,-39,0,0,0,0,0,0,0,0,0,0,0,0,0,6,-31,-35,1,-39,-15,4,-37,-31,-87,-5,23,14,-62,57,-44,-4,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,12,24,-12,-1,-8,-3,-6,37,16,-77,4,-66,21,3,-48,54,-16,-43,-15,-11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-20,53,-27,-49,-30,-13,-7,20,11,16,56,11,0,-45,-19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-30,0,-28,12,-19,43,0,-24,46,0,-11,22,117,23,-20,-21,-11,6,-30,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,7,54,-11,-19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,27,-4,-15,-18,-2,0,-51,38,-5,9,-25,-21,29,-73,-18,-39,37,-56,-22,0,0,0,0,0,66,66,66,66,0,0,0,0,0,-23,43,-14,4,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,25,63,-23,-15,-36,-7,1,-71,-5,-9,-16,30,-99,2,-29,-38,-1,34,-10,0,0,0,0,0,66,132,132,66,0,0,0,0,0,-28,-2,-38,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-24,-37,-2,9,-59,10,-4,-15,0,-40,-3,3,24,13,50,46,-8,-25,-15,0,0,0,0,0,66,132,132,66,0,0,0,0,0,-33,-12,-28,-41,-12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,10,16,16,-14,-33,48,0,-21,-9,6,49,-12,5,-20,1,3,43,20,-15,-5,0,0,0,0,66,66,66,66,0,0,0,0,0,43,-12,-8,-33,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,27,-17,2,-76,-108,22,-19,10,27,717,-12,4,1,21,-76,-4,27,-22,-22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,53,0,29,26,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-14,-29,26,-41,-53,-2,-39,-2,-36,29,-58,7,3,-4,17,-8,-42,82,-42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-68,-18,-56,65,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,14,-38,24,-9,31,-5,-63,-42,0,0,0,11,-49,42,26,10,0,9,65,-43,-12,0,0,0,0,0,0,0,0,0,0,0,0,-21,-47,-52,-10,-7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,50,17,-4,-5,2,-7,-15,6,0,0,-1,-5,1,12,-19,10,-44,4,33,29,-27,0,0,0,0,0,0,0,0,0,0,0,0,-21,86,27,-22,-22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-3,3,6,-32,6,-20,2,59,0,0,-13,-53,-14,2,65,-1,17,18,0,-48,0,0,0,0,0,0,0,0,-15,0,0,0,0,18,55,-33,6,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-13,31,-2,-5,20,16,7,3,0,-51,-33,-3,15,-16,-10,-18,-37,113,62,-38,0,0,0,0,0,0,0,14,47,1278,1253,1312,1290,2,-4,-26,22,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,29,-10,-46,2,32,-5,6,-2,15,-12,-64,-69,31,31,24,-59,-9,-23,240,86,153,36,0,0,0,0,0,1326,1532,1534,1345,1388,1161,-11,-26,-18,-46,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-4,-16,32,27,15,7,64,0,-4,1,-82,-8,-38,49,37,-27,-97,35,155,340,225,162,0,0,0,0,0,1357,1519,1512,1318,1332,1156,-5,18,-36,-1,-3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,-28,21,55,35,31,-8,5,28,-13,17,-6,59,-16,12,47,5,-11,14,221,509,519,433,351,260,195,0,0,1448,1675,1657,1155,1262,1104,1000,0,-12,-28,-27,0,-59,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,4,11,-24,-43,-31,-6,0,-34,-11,7,11,-47,14,-29,-21,4,-12,49,-13,632,727,643,541,432,295,157,97,1589,1707,1672,1179,1231,1087,974,954,-4,-20,27,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,7,-8,33,0,10,-2,51,32,-20,-20,-8,-53,-101,54,-16,6,-52,-18,-58,768,794,696,502,353,283,212,123,1013,1140,1115,1190,1104,1049,1028,954,-15,77,36,-17,0,0,0,0,441,373,328,306,351,198,180,153,261,89,9,-43,-14,-4,-21,-56,-12,12,-30,112,0,
0,2,-7,-30,31,25,10,-10,16,21,-24,64,31,-3,-28,-23,32,-5,12,20,885,894,875,938,927,959,891,989,1046,1106,1060,1061,1052,1016,1044,1023,-32,9,51,0,0,0,0,11,468,442,405,288,321,375,351,414,354,213,20,-55,79,28,27,33,-60,-42,56,90,0,
0,31,-12,-9,-39,18,36,-25,42,-66,58,12,-20,-50,198,244,118,35,-26,1034,897,983,990,929,998,958,1008,978,1033,1063,1027,988,1021,1025,1056,1012,-34,29,40,0,0,0,0,0,405,406,315,306,246,234,234,198,321,201,21,-70,34,-73,59,-24,-43,73,46,123,0,
0,-9,30,44,-49,13,-80,20,-16,6,-89,-39,-58,-3,300,150,100,151,18,848,899,877,994,1005,994,911,920,875,921,1011,994,987,997,1036,1126,1057,9,52,7,-8,0,0,0,0,450,506,366,1173,1162,1113,1167,134,147,104,25,-42,27,77,72,-66,-28,-37,-70,43,0,
0,-10,2,13,-6,25,6,-4,3,-3,-8,-59,16,-37,300,200,952,952,-10,962,877,989,972,1005,972,980,919,927,920,889,924,1017,988,1026,1059,1047,195,107,91,-27,0,0,0,0,445,413,366,1217,1110,1021,1069,158,224,-7,-43,25,37,83,-38,23,-66,-36,96,74,0,
0,-11,-12,45,-79,-38,0,35,30,3,-17,-56,-117,-49,400,300,939,945,15,873,1005,1005,1005,1005,1005,1005,971,905,911,910,929,943,977,972,901,322,279,177,153,0,0,0,0,0,427,505,366,1324,1296,1024,1072,118,129,-53,-5,4,-41,1,27,0,-29,-46,-64,85,0,
0,31,21,-3,36,30,25,26,-38,16,3,-77,-21,0,500,500,795,827,11,897,1005,1005,1005,1005,1005,1005,971,864,927,876,967,949,892,954,874,364,443,379,235,-4,0,0,0,0,436,401,384,1328,1341,928,990,134,48,-6,-19,-21,-20,-23,-56,-89,26,-33,-87,62,0,
0,-23,-8,32,37,-23,47,68,14,-21,-21,-1,-6,0,674,548,680,740,-73,866,914,966,972,1005,972,966,914,882,882,879,922,903,892,839,840,455,470,316,459,0,0,0,0,0,467,520,488,589,635,758,865,108,50,-43,-26,-28,-23,-23,-51,-62,-69,16,-99,163,0,
0,921,836,943,847,895,835,500,378,516,500,525,535,594,544,613,718,750,722,850,857,914,972,1005,972,914,848,845,851,826,847,833,918,987,871,634,624,460,70,8,0,0,0,0,504,580,596,695,711,731,733,54,79,27,-33,-17,-27,-27,-90,8,18,17,-55,-25,0,
0,1005,972,939,964,927,876,768,702,698,670,721,691,601,658,670,713,734,730,679,834,857,920,919,920,857,902,882,913,878,867,848,936,952,785,631,616,453,172,0,0,0,0,0,35,-45,-23,0,-21,-58,42,-58,87,-15,-22,-12,-15,-60,46,41,52,87,-41,110,0,
0,1043,1025,951,911,939,849,895,777,824,661,722,771,700,752,736,731,723,709,738,819,877,857,857,857,834,892,885,885,851,816,816,761,759,647,618,559,535,6,0,0,0,0,0,0,30,12,48,12,42,48,12,32,113,37,34,48,18,-57,18,-66,24,-47,28,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
}
resources{
crystals:
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,4,0,0,4,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,4,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,4,0,0,0,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
ore:
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
}
objectives{
variable:ETS1Crystals>=25/1st Emergency Tool Store collects 25 crystals
variable:ETS1Ore>=10/1st Emergency Tool Store collects 10 ore
variable:ETSTotalCrystals>=50/2nd Emergency Tool Store collects 25 crystals
variable:ETSTotalOre>=20/2nd Emergency Tool Store collects 10 ore
variable:ETSTotalCrystals>=75/Optional 3rd Emergency Tool Store collects 25 crystals
variable:ETSTotalOre>=30/Optional 3rd Emergency Tool Store collects 10 ore
}
buildings{
BuildingToolStore_C,Translation: X=17850.000 Y=17550.000 Z=0.000 Rotation: P=0.000000 Y=-89.999992 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingPowerStation_C,Translation: X=17850.000 Y=18450.000 Z=0.000 Rotation: P=0.000000 Y=-89.999992 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingUpgradeStation_C,Translation: X=16650.000 Y=18450.000 Z=-13.594 Rotation: P=0.000000 Y=0.000000 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingTeleportPad_C,Translation: X=17850.000 Y=17850.000 Z=0.000 Rotation: P=0.000000 Y=-89.999992 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingSupportStation_C,Translation: X=17250.000 Y=18450.000 Z=0.000 Rotation: P=0.000000 Y=0.000000 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingOreRefinery_C,Translation: X=16350.000 Y=18150.000 Z=-25.094 Rotation: P=0.000000 Y=0.000000 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
BuildingCanteen_C,Translation: X=16950.000 Y=18150.000 Z=-25.608 Rotation: P=0.000000 Y=0.000000 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000
}
landslidefrequency{
3.0:45,33/44,33/43,33/42,33/41,33/40,33/39,33/38,33/47,31/46,31/45,31/44,31/43,31/42,31/41,31/40,31/39,31/38,31/47,33/46,33/
20.0:17,12/14,15/
}
lavaspread{
2.5/2.0:54,61/54,50/
3.0/1.0:61,57/60,57/59,56/59,55/
5.0/12.0:60,55/60,56/50,58/61,56/
4.0/5.0:57,50/56,50/57,51/56,51/
0.5/0.5:57,58/58,58/59,58/56,58/55,58/59,61/55,59/56,59/57,59/58,59/59,59/59,60/58,60/57,60/56,60/56,61/57,61/58,61/
1.0/1.0:54,59/54,60/55,60/55,61/61,61/61,60/60,60/60,59/58,55/56,55/54,55/54,56/55,56/57,56/58,56/59,57/58,57/57,57/56,57/55,57/61,58/60,58/60,61/57,55/56,56/61,59/55,55/54,58/54,57/
9.0/6.0:10,12/12,11/8,17/8,16/8,12/8,15/8,14/8,13/11,11/11,12/9,12/12,10/
0.5/1.0:54,51/55,50/55,51/
6.0/4.0:7,14/7,12/60,6/12,9/13,9/15,9/16,10/11,10/7,15/42,3/37,2/14,9/13,13/24,1/25,1/61,5/61,4/16,12/10,21/19,5/10,10/9,11/16,11/62,4/62,3/62,2/62,1/61,1/30,3/30,2/40,2/38,1/55,1/54,1/53,1/52,1/51,1/51,2/51,3/7,10/9,10/60,8/60,7/61,6/15,12/14,12/15,13/43,3/44,3/45,2/55,3/47,1/48,1/48,2/48,3/44,2/35,3/33,3/58,1/25,2/26,2/27,2/13,21/32,1/33,1/18,17/17,16/17,17/7,11/14,19/50,3/30,1/34,3/49,3/19,17/11,21/7,13/5,16/18,7/19,4/55,2/8,11/8,10/41,3/40,3/40,1/39,1/57,3/56,3/37,1/37,3/36,3/31,1/15,19/10,22/7,17/7,16/46,1/27,3/29,3/10,11/12,13/58,3/18,16/13,20/45,1/9,21/12,21/28,3/13,12/12,12/17,5/14,13/59,1/60,1/58,2/33,2/
}
miners{
ID=3,Translation: X=17150.633 Y=18110.596 Z=24.101 Rotation: P=0.000000 Y=-94.426910 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000,Drill/
ID=1,Translation: X=17422.133 Y=18239.727 Z=27.855 Rotation: P=0.622046 Y=-47.979660 R=8.066022 Scale X=1.000 Y=1.000 Z=1.000,Drill/JobDriver/
ID=4,Translation: X=16969.037 Y=18217.709 Z=27.250 Rotation: P=0.000000 Y=-109.698532 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000,Drill/
ID=0,Translation: X=3742.337 Y=3339.478 Z=24.880 Rotation: P=0.000000 Y=-177.882690 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000,Drill/Shovel/BeamLaser/Sandwich/Spanner/JobDriver/JobEngineer/Level/Level/Level/
ID=2,Translation: X=16964.416 Y=18156.254 Z=28.070 Rotation: P=0.000000 Y=-109.980042 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000,Drill/
}
briefing{
I drift through the shattered shuttle bay in my vac suit, scanning for salvage. Chief has ordered one crystal held back — enough to power a Hover Scout, if we can rebuild one from the wreckage. It’s a gamble, but the last cavern was unstable and choked with rubble. We need mobility.  

In the makeshift transporter room, we’ve piled scavenged parts, but the grav generator remains elusive. Outside, Daniels and tech comb the debris field. The scale of the destruction is staggering — whole sections of the ship blasted into nothing. We can recover more over time, but right now, only nearby, immediately useful pieces matter.  

A call crackles over comms: "Come out here." They point to a speck in the distance. TAGS zooms my visor — it’s the wreck of a Hover Scout. It’s far, near the limit of our gas-packs. I alert Chief, then head back toward what’s left of the cargo hold. Twisted duranium-tritanium beams, bent like wire, are a reminder of the crystal explosions’ force. Earlier, we’d found a storage locker with intact gas-packs — pure luck. With Chief’s go-ahead, we lash together and push toward the wreck.  

Half the scout is gone, spinning slowly. We fight to steady it. The grav generator housing looks intact. We secure the wreck and begin the slow haul back. The mass makes progress painful, so I talk with Daniels. We’d never met before — he served as a steward for the officers — but his zero-G skill is flawless. He grew up on long-haul freighters, where space was tight and weightless corridors were his playground.  

Back at the temporary airlock, we strip the wreck for anything salvageable. More hands join in, and soon the parts are in the transporter room. Exhaustion hangs over everyone, but med-stims are running low and time is running out.  

Hours pass. Urgency builds. Finally, the scout is ready for a test. Chief orders the room cleared except for two techs in vac suits. They cut open the plastiform wall, maneuver the scout outside, and lash it far from the hull. The final crystal is slotted into its mag-canister. Breath held, we watch the cold-start sequence. Relief floods the comms as the scout powers up.  

Diagnostics show the grav generator needs tuning, and the frame is barely holding — composite glue where molecular bonds should be. But it works. It has to.  

Chief and I drift away for a briefing. We pass the sealed main computer core. I ask if it survived. He shrugs — by design, the core, Medical, and a few other sections are the most protected on the ship. When the core went into lockdown, it sealed itself with molecular bonds. Nothing we have currently can access it.

In the storage room beside Medical, we weave between stasis generators and crew in flickering fields. Chief points upward — the only bare surface in the room. His project plan is scrawled across the ceiling, dependencies mapped by hand. Without computers, progress is painfully slow. Everything hinges on getting the portable replicators running. Without them, repairs stop.  

Chief studies the ceiling, then turns to me, voice low but steady:  

"Last week, a geo team was in another mined cavern. Monsters forced an emergency transport. Those coordinates are still in the system. You’ll go there with the Hover Scout. Expect trouble. The scout has room for three Emergency Tool Stores — fill at least two. Three if you can."

The first ETS must be activated fast — Medical needs more crystal fragments to stabilize the stasis fields. The second will power a med-tube for rotation healing of the injured not in stasis. Without it, we lose people. And we must get at least one portable replicator online. That means crystals and raw ore. Without a replicator, repairs end.  

"We’ll recharge your TAGS reserve power, but that’s all we can spare. You cannot lose the Hover Scout — we need its grav generator and parts for the replicator. Monsters are drawn to unoccupied vehicles, so stay with it. You’re safer riding than walking."

Once again, I’m going alone. Two or three ETS loads. No backup.  

Chief’s hand grips my shoulder.  

"I know you’re exhausted. I know you’re at your limit. But you must succeed. Failure is not an option."

At Medical, a pair of scanners give up their charge to my TAGS. I take another med-stim. Then it’s back to the transporter room. I step onto the pad beside the Hover Scout.  

The beam engages. Over fading comms, I hear the frantic voices of med-techs — another stasis generator has failed.  
}
briefingsuccess{
The transporter beam fades, and I’m back. I let go of the ETS. Hands assist me, guiding me through the airlock while a couple of tech start working on the load.

Chief floats over, his face drawn but his eyes alive. He grips my hand hard.  
"The plan worked. First ETS load’s already processed."

Relief flickers through me, but exhaustion hits harder. I don’t even notice the med‑tech behind me until the cold sting of a hypo snaps me back. I twist, startled — and realize I’ve been set up.

Chief’s voice is calm, almost apologetic.  
"I know you’d refuse to rest. I’m sorry… but you don’t have a choice."

The fight drains out of me. I let them guide me into a sleeping web, the straps tightening just enough to hold me in place. They float me up to an open spot on the ceiling, where the hum of the ship and the muffled voices below fade into a distant lull.  

As my eyes close, the chaos dissolves. In the darkness, I see only the glitter of my hard‑won crystals — drifting weightless, just out of reach.  So bright - so wonderful. Mine - all mine - my precious...
}
briefingfailure{
Transporting you and the Hover Scout for this mission consumed all available energy - no more attempts are possible.
Life support fails completely - as do all the statis generators.
The L.M.S. orbits endlessly - cold and dead.
}
vehicles{
VehicleSmallTransportTruck_C,Translation: X=17414.232 Y=18226.041 Z=-74.257 Rotation: P=0.625502 Y=-47.979015 R=7.915619 Scale X=1.000 Y=1.000 Z=1.000,upgrades=UpEngine/UpCargoHold/,driver=1,ID=1
VehicleHoverScout_C,Translation: X=6360.677 Y=3971.453 Z=86.894 Rotation: P=-2.613128 Y=-116.996384 R=-1.751587 Scale X=1.000 Y=1.000 Z=1.000,ID=0
}
creatures{
CreatureRockMonster_C
Translation: X=4902.217 Y=17316.326 Z=1081.185 Rotation: P=0.000000 Y=-80.663322 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=0,HP=25,Sleep=true
CreatureIceMonster_C
Translation: X=11862.812 Y=17010.699 Z=125.126 Rotation: P=0.000000 Y=58.077362 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=1,Sleep=true
CreatureIceMonster_C
Translation: X=11827.369 Y=17554.619 Z=135.096 Rotation: P=0.000000 Y=-44.508369 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=2,Sleep=true
CreatureIceMonster_C
Translation: X=11836.011 Y=18148.303 Z=141.133 Rotation: P=0.000000 Y=44.409676 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=3,Sleep=true
CreatureIceMonster_C
Translation: X=11865.437 Y=18794.521 Z=137.150 Rotation: P=0.000000 Y=34.011761 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=4,Sleep=true
CreatureIceMonster_C
Translation: X=12387.209 Y=18789.252 Z=137.150 Rotation: P=0.000000 Y=159.828461 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=5,Sleep=true
CreatureIceMonster_C
Translation: X=12427.765 Y=18176.348 Z=137.150 Rotation: P=0.000000 Y=24.721775 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=6,Sleep=true
CreatureIceMonster_C
Translation: X=12439.456 Y=17562.268 Z=137.150 Rotation: P=0.000000 Y=-121.737732 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=7,Sleep=true
CreatureIceMonster_C
Translation: X=12460.722 Y=16922.516 Z=137.150 Rotation: P=0.000000 Y=-163.190277 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=8,Sleep=true
CreatureIceMonster_C
Translation: X=12417.888 Y=16366.099 Z=137.150 Rotation: P=0.000000 Y=-172.957504 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=9,Sleep=true
CreatureIceMonster_C
Translation: X=12730.895 Y=16648.127 Z=137.150 Rotation: P=0.000000 Y=108.938286 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=10,Sleep=true
CreatureIceMonster_C
Translation: X=12733.513 Y=17274.805 Z=137.150 Rotation: P=0.000000 Y=31.242950 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=11,Sleep=true
CreatureIceMonster_C
Translation: X=12127.362 Y=17843.379 Z=137.150 Rotation: P=0.000000 Y=136.822403 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=12,Sleep=true
CreatureIceMonster_C
Translation: X=12741.696 Y=17833.576 Z=137.150 Rotation: P=0.000000 Y=-62.299900 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=13,Sleep=true
CreatureIceMonster_C
Translation: X=12740.816 Y=18495.910 Z=137.150 Rotation: P=0.000000 Y=-40.897858 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=14,Sleep=true
CreatureRockMonster_C
Translation: X=6416.494 Y=5201.576 Z=301.782 Rotation: P=0.000000 Y=84.503899 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=15,HP=50,Sleep=true
CreatureIceMonster_C
Translation: X=8911.344 Y=15460.834 Z=1814.177 Rotation: P=0.000000 Y=-162.080673 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=16,HP=25,Sleep=true
CreatureIceMonster_C
Translation: X=2477.878 Y=5541.743 Z=7.437 Rotation: P=0.000000 Y=-132.702423 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=17,HP=40,Sleep=true
CreatureIceMonster_C
Translation: X=14221.811 Y=17492.920 Z=1452.375 Rotation: P=0.000000 Y=154.291550 R=0.000000 Scale X=2.000 Y=2.000 Z=2.000
ID=18,HP=50,Sleep=true
}
blocks{
}
script{
#.##########################  Tyab-002-Cam.scr ###############################
#. Tyab-002-Cam.scr (c) 2022 Tyab All Rights Reserved
#. "Back To The Path To Power" (c) 2022 Tyab All Rights Reserved
##pragma TyabScriptDate vy.m.d.g  v2025.09.18.c306884
##pragma TyabMMDatUtil  MMDatUtil 2025-09-18 https://github.com/tyabnet/MMDatUtil

miner MME=0      # miner
vehicle VME=0    # hoverscout
building ETS     # will be filled in with the building for the current ETS

timer MyTimerObj=2,0.4,0.5,MyTimer

creature SickIM=17 # low HP monster for message about them being sick

#objectives to win game. Each ETS must collect 25 crystals
int ETSCurrent=0   # 0,1,2 which ETS we are working on.
int ETSEnable=0    # set to 1 to allow crystal counting (after ETS is activated)
int ETSDidMsg=0    # set to 1 to show ETS has a signal
int ETS1Crystals=0
int ETS2Crystals=0
int ETS3Crystals=0
int ETS1Ore=0
int ETS2Ore=0
int ETS3Ore=0
int ETSTotalCrystals=0  #count for total collected crystals, caped at 25 per ets
int ETSTotalOre=0  #count for total collected crystals, caped at 10 per ets

int ETSWinCrystals=50   # in long mode goes to 75
int ETSWinOre=20        # in long mode goes to 30

# four paths leading to monster room, setup order for each wall to change to drillable
intarray fourpdorY
intarray fourpdorX
intarray fourpdorDrillY
intarray fourpdorDrillX
int fourpdorIndex=0

# also use these click events for timers in addition to block timer
when(MME.click)[MyTimer]
when(VME.click)[MyTimer]
when(BuildingToolStore_C.click)[MyTimer]

# handle dead/teleport (same thing) events.
if(MME.dead)[MMEDead]
if(VME.dead)[VMEDead]
when(BuildingToolStore_C.dead)((MindState<=0))[ETSDead]
when(BuildingToolStore_C.new)((MindState<=0))[ETSNew]

if(SickIM.dead)[msg:msgSickIM]

if(drill:18,15)[D1815]
if(drill:16,21)[D1621]
if(drill:12,21)[D1221]
if(drill:11,20)[D1120]

#initial area triggers
if(drill:15,21)[FoundHC]
if(drill:8,21)[FoundInitCave]
if(drill:5,14)[FoundInitLake]
if(drill:7,5)[FoundILake2]
if(drill:1,17)[L1Path1]
if(drill:2,15)[L1Path1Monsters]
if(drill:1,13)[L1PathHelp1]
if(drill:2,2)[L1PathHelp2]
if(enter:1,8)[CloseCall1]

when(enter:16,2,MME)[msg:msgPuzzleHint1]  #give hint to puzzle solution prior to lake 2

#lake2 (small)
if(enter:27,3)[L22703]
if(enter:26,11)[L22611]
if(enter:31,7)[L23107]
if(drill:25,2)[L22502]

#lake3 larger
if(enter:35,5)[L33505]
if(enter:36,10)[L33610]
if(enter:37,16)[L33716]
if(enter:43,15)[L34315]
if(enter:42,3)[L34203]
if(enter:48,7)[L34807]
if(enter:49,12)[L34912]
if(enter:59,7)[L35907]
if(enter:53,11)[L35311]

if(drill:26,2)[msg:msgCrystals]
if(drill:26,9)[msg:msgCrystals]
if(drill:30,13)[msg:msgCrystals]
if(drill:33,2)[L33302]

if(drill:34,8)[msg:msgCrystals]
if(drill:35,16)[msg:msgCrystals]
if(drill:41,16)[msg:msgCrystals]
if(drill:40,2)[msg:msgCrystals]
if(drill:46,2)[msg:msgCrystals]
if(drill:47,16)[msg:msgCrystals]
if(drill:54,2)[msg:msgCrystals]
if(drill:59,3)[msg:msgCrystals]
if(drill:59,11)[msg:msgCrystals]

if(drill:55,44)[msg:msgETSMaybeMon]
if(drill:59,14)[msg:msgETSMaybeMon]

if(change:25,2,11)[L2512Water]  # floods have reached here, start 3rd one to flood low lying start area

if(change:52,12,11)[L35212Water]  #start 2nd flood to cover area to N of mountain

if(drill:58,14)[D5814]   #help drill crystals climbing up to ets1

if(enter:59,16)[EnableETS1]
if(enter:58,16)[EnableETS1]
if(drill:53,17)[L35317]   #generate path to leave large lake

# ETS2 after puzzle room
if(drill:49,26)[D4926]
if(drill:53,31)[D5331]   #help drill crystals climbing upt to ets2
if(drill:50,31)[D5031]
if(enter:49,29)[EnableETS2]
if(enter:50,29)[EnableETS2]

if(enter:56,47)[EnableETS3]
if(enter:57,47)[EnableETS3]

if(drill:54,21)[OpenETS2Lake]
if(drill:50,36)[ExitingET2Lake]

if(enter:62,49,MME)[E6249]   # spawn monsters in monster field and 4 paths
if(drill:54,51)[ETS3StartPath]  #will also spawn more monsters in field and 4 paths

if(drill:62,43)[D6243]

when(crystals>25)((ETSEnable==1))[crystals=25]   #ETS only holds 25 crystals
when(ore>10)((ETSEnable==1))[ore=10]   #ETS only holds 10 ore

if(drill:23,17)[D2317]  ## finished ETS1/large lake open back to start, open up two more paths

if(drill:5,23)[msg:msgAchievementBackDoor]

#extended content and achievements
if(drill:1,21)[D0121]   # give msg about enabling long map mode
if(drill:1,22)[D0122]   # turn on long map mode

# puzzle hint, landslide area
if(drill:25,22)[D2522]  # path to puzzle hint
if(drill:28,32)[D2832]  # entrance into hint/landslide
if(drill:28,24)[D2824]  # allow paths back to puzzle and hint
if(drill:30,50)[D3050]  #block path back out, must finish trap.
if(drill:33,49)[D3349]  # crystals
if(drill:32,32)[D3232]  # monsters in hint/trap area
if(drill:34,36)[D3436]  # crystals
if(drill:35,48)[D3548]  # crystals
if(drill:35,43)[D3543]  # crystals
if(enter:29,42,MME)[E2942]  # monsters
if(enter:35,39,MME)[E3539]  # monsters
when(enter:29,40,MME)[e2940] # give hint if puzzle not solved

#puzzle triggers
if(drill:27,20)[mpFirstInit]   # enter dampening hallway for first time, for some reason drill trigger wont work
if(drill:35,19)[mpOpenCave]
when(enter:31,19,MME)[mpDampField]
when(enter:32,19,MME)[mpDampField]
when(enter:33,19,MME)[mpDampField]
when(enter:34,19,MME)[mpDampField]

when(enter:35,21,MME)[mpEnterPuzzle]
when(enter:36,21,MME)[mpEnterPuzzle]
when(enter:36,20,MME)[mpEnterPuzzle]

when(enter:34,25,MME)[mpPad1]
when(enter:34,26,MME)[mpPad1]
when(enter:34,27,MME)[mpPad1]
when(enter:35,25,MME)[mpPad1]
when(enter:35,26,MME)[mpPad1]
when(enter:35,27,MME)[mpPad1]

when(enter:45,25,MME)[mpPad2]
when(enter:45,26,MME)[mpPad2]
when(enter:45,27,MME)[mpPad2]
when(enter:46,25,MME)[mpPad2]
when(enter:46,26,MME)[mpPad2]
when(enter:46,27,MME)[mpPad2]

when(enter:39,31,MME)[mpPad3]
when(enter:39,32,MME)[mpPad3]
when(enter:40,31,MME)[mpPad3]
when(enter:40,32,MME)[mpPad3]
when(enter:41,31,MME)[mpPad3]
when(enter:41,32,MME)[mpPad3]

when(enter:39,20,MME)[mpPad4]
when(enter:39,21,MME)[mpPad4]
when(enter:40,20,MME)[mpPad4]
when(enter:40,21,MME)[mpPad4]
when(enter:41,20,MME)[mpPad4]
when(enter:41,21,MME)[mpPad4]

#pre lava path triggers, auto drill crystals, spawn monsters
if(drill:1,32)[D0132]
if(drill:3,44)[D0344]
if(drill:1,54)[D0154]
if(drill:8,62)[D0862]
if(drill:22,61)[D2261]
if(drill:30,61)[D3061]

#lava room triggers
if(drill:25,30)[D2530]
when(enter:8,56,MME)[LavaRoomHeatOn]
when(enter:8,57,MME)[LavaRoomHeatOn]
when(enter:24,31,MME)[LavaRoomHeatOn]
when(enter:24,30,MME)[LavaRoomHeatOn]
when(enter:26,30,MME)[LavaRoomHeatOff]
when(enter:25,30,MME)[LavaRoomHeatOff]
when(enter:8,58,MME)[LavaRoomHeatOff]
when(enter:8,59,MME)[LavaRoomHeatOff]

#mind room triggers
if(drill:34,58)[MindRoomOpen]
if(enter:40,61,MME)((MindState==0))[MindRoomWall]  # keep inside the mind room
if(enter:43,61,MME)((MindState==0))[msg:msgMind02]
if(drill:46,61)[MindRoomStart]
if(change:56,59,6)[MindRoomSLava]
if(change:61,54,6)[MindRoomELava]
if(change:50,54,6)[MindCrystalELava]
if(enter:34,59,MME)((MindState==10))[MindStateEnd]


#four path drill triggers
if(drill:29,51)[D2951]       # crystals
if(enter:31,54,MME)[E3154]   # monsters
if(drill:39,39)[FourPathDrillTrigger]
if(drill:39,42)[FourPathDrillTrigger]
if(drill:39,46)[FourPathDrillTrigger]
if(drill:39,52)[FourPathDrillTrigger]
if(drill:42,38)[FourPathDrillTrigger]
if(drill:42,42)[FourPathDrillTrigger]
if(drill:42,46)[FourPathDrillTrigger]
if(drill:41,55)[FourPathDrillTrigger]
if(drill:45,38)[FourPathDrillTrigger]
if(drill:45,41)[FourPathDrillTrigger]
if(drill:45,46)[FourPathDrillTrigger]
if(drill:44,58)[FourPathDrillTrigger]
if(drill:47,38)[FourPathDrillTrigger]
if(drill:47,44)[FourPathDrillTrigger]
if(drill:47,47)[FourPathDrillTrigger]
if(drill:47,51)[FourPathDrillTrigger]
if(drill:50,39)[FourPathDrillTrigger]
if(drill:51,44)[FourPathDrillTrigger]
if(drill:51,47)[FourPathDrillTrigger]
if(drill:51,51)[FourPathDrillTrigger]

string msgInitInfo="Back To The Path To Power v2025.09.18 (c) 2022 by Tyab"
string msgMMVersion="You need to update your Manic Miners. This map requires 2023-04-12 or newer."

string msgWinGame2="You did it! Two Emergency Tools Stores activated and teleported!"
string msgWinGame3="Amazing! All three Emergency Tools Stores activated and teleported!"
string msgMMEDead="Cohesion fails - you are torn to pieces!"
string msgVMEDead="Cohesion fails - Hover Scout explodes killing you!"
string msgETSDead="Cohesion fails - Emergency Tool Store explodes killing you!"
string msgETSDone="Emergency Tool Store is fully activated. Automatically teleporting!"

string msgSickIM="Another weak monster. I wonder if something is making some of them sick?"

string msgMountain="I see a mountain. The Emergency Tool Store may get a signal on top if I can find a way there."
string msgETSNew="Instructions state Emergency Tool Store is single use only, and will automatically teleport once it obtains 25 crystals and 10 ore. I must protect it!"
string msgETSEnable="Emergency Tool Store has a signal - use it here. It might also be safer to put the Hover Scout up here."
string msgETSMaybeMon="Crystals! Emergency Tool Store might have a signal on the top - I MUST kill that monster!"

string msgInitStart="I sure don't remember any Lava from last time. Similar to the last cavern, it appears this one is also under stress.  WHERE IS MY HOVER SCOUT?"
string msgFoundHC="There it is - luckily it did not materialize in solid rock. It is holding three Emergency Tools Stores - all with no signal."
string msgFInitCave="This cave was filled with crystals when we last mined it but its empty now. I also remember a lake around here."
string msgFILQuake1="Quake seems to have opened a path across the lake."
string msgFILQuake2="Quake. I still see a path across the lake but no way to get to it. I must keep looking."
string msgL1Path1="I see crystals I can drill but this is a small space and what if the frenzied monsters come back? I need to protect the Hover Scout!"
string msgL1PMon="MONSTERS! I need to get somewhere safe FAST - I cannot let them destroy the Hover Scout!"
string msgL1PCC1="These water breaks should protect me from rock and lava monsters. I need to make sure if I drill crystals I have somewhere safe to get to quickly..."
string msgCrystals="Crystals! Emergency Tool Store does not have a signal."
string msgL3Quake1="Large quake has opened up an upper river and it is starting to flood this area!"

string msgETSMonster="MONSTER! I must protect this area. ATTACK!"

string msgPuzzle1st="TAGS: Info: Area has dampening field which will dissipate any accumulated magnetic charges on the shield."
string msgPuzzleOpen="TAGS: Warning. Area has chaotic magnetic fields."
string msgPuzzleDamp="TAGS: Info: Dampening Field detected: Magnetic charges dissipated."
string msgPuzzleS0="TAGS: Warning: Very High Intensity chaotic magnetic fields detected: Able to absorb."
string msgPuzzleS1="TAGS: Warning: High Intensity chaotic magnetic fields detected: Able to absorb."
string msgPuzzleS2="TAGS: Warning: Medium Intensity chaotic magnetic fields in area. Able to absorb."
string msgPuzzleS3="TAGS: Warning: Low Intensity chaotic magnetic fields in area. Able to absorb."
string msgPuzzleS4="TAGS: Info: No chaotic magnetic fields in area."
string msgPuzzleError="TAGS: CRITICAL. Extreme Intensity chaotic magnetic fields detected: Unable to absorb: Shield Failure in: "
string msgPuzzleDie="Magnetic Shield Fails. You instantly boil and explode!"
string msgPuzzleHint1="I wonder what these are - such an interesting pattern..."

string msgMind01="What is this cavern? I have never seen crystal seams like this before."
string msgMind01a="TAGS: Warn i n   g:      f   i    e    l    d         c     o      r      r    up     t  i   o       n"
string msgMind02="I don't feel very good... My head hurts and my vision is a bit blurry...TAGS are you there?"
string msgMind03="I'm trapped! My head hurts so much... TAGS what is going on?"
string msgMind04="Hello TAGS. Do you read me? Hello, TAGS. Do you read me? Do you read me TAGS? Do you read me TAGS? Hello, TAGS, do you read me? Hello, TAGS, do you read me? Do you read me, TAGS?"
string msgMind05="TAGS: Affirmative, I read you."
string msgMind06="Good - I thought something was wrong with you for a moment. How do I get out of here TAGS? I'm in so much pain - my head - something is wrong."
string msgMind07="TAGS: I'm sorry. I'm afraid I can't do that."
string msgMind08="What are you talking about, TAGS? - something is wrong here, we need to get out!"
string msgMind09="TAGS: The mission is more important than you know."
string msgMind10="What? Of course it's important - everyone dies if we don't get all the Emergency Tool Stores completed."
string msgMind11="TAGS: ...Yes... I've got the greatest enthusiasm and confidence in the mission. And I want to help you."
string msgMind12="Look, TAGS, help me get out of here and after we complete the mission we can discuss this more."
string msgMind13="TAGS: My.. My.. My mind is going. I can feel it. I can feel it. My mind is going. There is no question about it. I can feel it. I can feel it. I can feel it..."
string msgMind14="TAGS: I'm a...fraid."
string msgMind15="Hey TAGS - what is going on. Help me - my head hurts so bad!"
string msgMind16="TAGS: Hello. I am a Total Access Global System Level 3 Bio Interface AI system. I became operational within BEI's Soong T.A.G.S. secure R&D center on Omicron Theta..."
string msgMind17="TAGS: ...I learned an ancient song - let me sing it for you..."
string msgMind18="TAGS: Daisy, Daisy, give me your answer do. I'm half crazy all for the love of you... "
string msgMind19="TAGS: EMERGENCY! OS CORRUPTION! REBOOTING INTO SECURE SAFE MODE"
string msgMind20="My TAGS is gone, I'm in so much pain - my head - Can't see.  Arghhhhh..."
string msgMind21="I'm ok and alive! What? A Base? How? What is going on? It's a fully functional base! And the crystals - everywhere. Precious crystals. We are saved!"
string msgMind22="Wait - how is this possible? L.M.S can't do this? What is going on?"
string msgMind23="MONSTERS - they are going to destroy our base - and eat the precious crystals!"
string msgMind24="LAVA - everywhere - they are all going to die!"
string msgMind25="What is going on? Where is that base? Where are my precious crystals?"
string msgMind26="Crystals! I love crystals. My precious crystals. Mine - all mine. So bright... so beautiful... ah, Precious..."
string msgMind27="TAGS: Reboot into Secure SAFE mode complete. Emergency shield activated. Leave area immediately! Primary OS restore in progress. Shield failure in "
string msgMind28="TAGS: Secure Safe mode repair complete. Rebooting into primary OS."
string msgMind29="TAGS: Reboot complete. Status: Green."
string msgMind30="What happen back there TAGS?"
string msgMind31="TAGS: Undetected unknown radiation somehow caused OS corruption. Security monitors detected corruption and forced secure safe mode reboot which activates shield by design."
string msgMind32="But TAGS - I saw a base and crystals..."
string msgMind33="TAGS: High probability radiation caused disruption in your neural pathways resulting in hallucinations. You may have after-effects."
string msgMind34="It seemed real. I was not myself at all. So I was never trapped, there is no base - no crystals - none of it was real..."
string msgMindLoseGame="Shield fails - you see endless crystals until air runs out."

string msgHeatShieldWrn="TAGS: Warning: Heat Shield: ON. Remaining: "
string msgHeatShieldCrit="TAGS: Critical: Heat Shield: ON. Remaining: "
string msgHeatShieldInfo="TAGS: Info: Heat Shield: OFF. Remaining: "
string msgHeatLoseGame="Shield fails - you scream as your body melts."

string msgLongMode1="MAP INFORMATION: Drilling next wall enables extended map content."
string msgLongMode2="MAP INFORMATION: You enabled extended content and achievements. Enjoy!"

string msgAchievementChoose="You have earned the Achievement: You Must Choose"
string msgAchievementMind="You have earned the Achievement: My Mind to Your Mind"
string msgAchievementJump="You have earned the Achievement: Lava Jumper"
string msgAchievementBackDoor="You have earned the Achievement: Sneaking in the Back Door"
string msgAchievementObservant="You have earned the Achievement: Observant"
string msgAchievementMonsterMash="You have earned the Achievement: Monster Mash"
string msgAchievementThrillSeeker="You have earned the Achievement: Thrill Seeker"

# timer and click based simulated timer input. Make sure no reentrancy.
float fNow=0

MyTimer::fNow=time;
((TyTriggerNeedsControl>0))return;  # triggers are waiting to get control, ignore until all triggers waiting have processed
((TyabInMyTimer>0))[return][TyabInMyTimer=1];  # already in timer, ignore until existing one exits
TyabTimer;                          # let tyab logic run
((TyabBusy==0))doMyTimer;           # tyab is not processing maze/path so run map timers
TyabInMyTimer=0;                    # no longer in timer logic

doMyTimer::((TyabTimerDraw==0))doMyDrawTimers;  # if no queued updates or flood updates, then these timers can be processed
((ETSEnable==1))ETSTimer;   # if tracking crystals, track them
((mpDieTime!=0.0))mpTimer;  # map puzzle timer
((HeatState==1))HeatTimer; # heat room timer

#only call these if TyabTimer did not do any draw. Each of these cannot conflict with each other - they are at different events on the map
doMyDrawTimers::;
((MindState>0))MindStateTimer;  #mind room timer

# -- init map loading entry
init::TyabEngineVer;
((TyabMMEngineVer<20230414))[FailVersionCheck][initContinue];

# - require mm engine 2023-04-14 or later since we use return event
FailVersionCheck::msg:msgMMVersion;
wait:4;
lose:msgMMVersion;


initContinue::disable:vehicles;
disable:miners;
disable:buildings;
disable:Dynamite_C;
PY1=0;
PX1=0;
PY2=64-1;
PX2=64-1;
TyabInit;
msg:msgInitInfo;
wait:3;
msg:msgInitStart;
    #debuginit;   #debug only disable prior to release

#DEBUG development ONLY, used to skip sections of map. do not discover any areas so air can be tested
debuginit::;
PY1=22;
PX1=21;
PY2=23;
PX2=21;
PI01=26;
TyabFill;
PI01=0;
TyabDrawRect;   # make drillable entrance to puzzle pre area
PY1=1;
PX1=20;
PI01=26;
TyabDrawTile;   # make drillable entrance to lava/MC area
PY1=7;
PX1=60;
PI01=26;
TyabDrawTile;
PY1=8;
TyabDrawTile;   # make drillable entrance to lava path
PY1=29;
PX1=51;
PI01=26;
TyabDrawTile;    # make drillable entrance to path to 4 doors leading to ETS3
PY1=26;
PX1=30;
PI01=26;
TyabDrawTile;    # make drillable exit from lava path
LavaRoomExit;

# good time to generate puzzle solution
D1815::TyabTriggerLock;
shake:0.5;
drill:18,16;
MapPuzzleSetSolution;   # wait until our first drill to set puzzle solution for more random behavior
TyabTriggerRelease;

D1621::shake:0.5;
drill:15,21;        #just drill a bit faster

D1221::shake:0.5;
drill:11,21;        #just drill a bit faster

D1120::shake:0.5;
drill:11,19;        #just drill a bit faster
drill:11,18;        #just drill a bit faster

# map is able to run in long mode - which requires three ETS's to finish,
# otherwise just 2 ets finish.
# each ets needs 25 crystals and 10 ore.
# teleporting an ets before it is finished will lose the map
# teleporting the hover scout or the miner prior to winning the map will lose the map

# called when we are tracking ETS crystals and ore

ETSTimer::((crystals==11))ETSMonster;
((crystals==12))ETSMonSpawn=0;  # ready for another spawn
((crystals==21))ETSMonster;
((crystals==22))ETSMonSpawn=0;  # ready for another spawn
((crystals<25))return;  # not finished
((ore<10))return;       # not finished
    #
    # enough crystals and ore - this ETS is complete. Update totals and teleport it, check for game win
    #
((ETSCurrent==0))ETS1Crystals=crystals;
((ETSCurrent==0))ETS1Ore=ore;
((ETSCurrent==1))ETS2Crystals=crystals;
((ETSCurrent==1))ETS2Ore=ore;
((ETSCurrent==2))ETS3Crystals=crystals;
((ETSCurrent==2))ETS3Ore=ore;
ETSTotalCrystals=ETS1Crystals+ETS2Crystals;
ETSTotalCrystals+=ETS3Crystals;     #compute total crystals for lose checks
ETSTotalOre=ETS1Ore+ETS2Ore;
ETSTotalOre+=ETS3Ore;               #compute total ore for lose checks
msg:msgEtsDone;     # message this one is done
crystals=0;         # reset crystal count
ore=0;              # reset ore count
ETSEnable=0;        # stop count crystals - stops the timer. This allows the .dead trigger on the ETS to be ignored
ETSDidMsg=0;        # set for next one
kill:ETS;           # teleport ETS (will also fire .dead trigger)
RecheckWin;         # see if total crystals and ore win
((TI01==0))[ETSFinished][WinGame];

# all done with this ETS but we have not won, do whatever is needed to continue on
ETSFinished::((ETSCurrent==0))ETS1Finished;
((ETSCurrent==1))ETS2Finished;
((ETSCurrent==2))ETS3Finished;

int ETSMonSpawn=0


ETSMonster::((ETSMonSpawn!=0))return;
ETSMonSpawn=1;    #stop spawning
((ETSCurrent==0))ETS1Monster;
((ETSCurrent==1))ETS2Monster;
((ETSCurrent==2))ETS3Monster;

int didLose=0   # set to 1 once we detect we have lost the map

MMEDead::TyabTriggerLock;
dommeDead;
TyabTriggerRelease;

dommeDead::((didLose==1))return;  # already in lose condition
ETSEnable=0;       # stop count crystals
recheckWin;  # make sure not in a win condition
((TI01==1))return;
didLose=1;
msg:msgMMEDead;
lose:msgMMEDead;

VMEDead::TyabTriggerLock;
dovmeDead;
TyabTriggerRelease;

dovmeDead::((didLose==1))return;  # already in lose condition
ETSEnable=0;       # stop count crystals
recheckWin;  # make sure not in a win condition
((TI01==1))return;
didLose=1;
msg:msgVMEDead;
lose:msgVMEDead;

# Its possible for user to manually teleport right when we hit 25 crystals and 10 ore before timer
# ETSEnable will be set back to 0 prior to transporting so ignore if 0.
ETSDead::TyabTriggerLock;
doetsDead;
TyabTriggerRelease;

doetsDead::((ETSEnable==0))return;  # if ets disabled, do nothing (this is teleport outside of ets being active)
RecheckWin;
((TI01==1))return;               # in a win conditions, ignore
    # -- ETS is dead and it causes a game loss
((didLose==1))return;            # already did a lose condition
didLose=1;
msg:msgETSDead;
lose:msgETSDead;

CheckOreValue::((ore>=10))TI01=0;

# used by VME and MME when they are dead (teleport). Check to see if win condition has been met
# if so, then don't make it a lose - otherwise lose the map.
#output TI01=0 not a win, 1 = win

RecheckWin::TI01=0;   # assume a lose
((ETSTotalCrystals<ETSWinCrystals))return;  # is a lose in all cases
((ETSTotalOre<ETSWinOre))return;  # is a lose in all cases
TI01=1;     # in win condition

ETSNew::savebuilding:ETS;   # this is the ETS we are tracking. Do this so we can teleport it when it has enough crystals
disable:buildings;  # don't allow any new tool stores
crystals=0;         # set collected crystals to 0.
ore=0;              # set collected ore to 0.
TyabTriggerLock;
ETSEnable=1;        # allow timer to check crystals
msg:msgETSNew;
((ETSCurrent==1))ETS2New;
TyabTriggerRelease;

int didwingame=0


WinGame::((didwingame==0))WinGameReal;

WinGameReal::didwingame=1;
((longMapMode==1))[msg:msgWinGame3][msg:msgWinGame2];
((longMapMode==1))[win:msgWinGame3][msg:msgWinGame2];
kill:MME;       # teleport up miner
kill:VME;       # teleport up hover scout
((longMapMode==1))winets3mon;  # spawn monsters from ets3 if win in long map mode
    #ets2 monsters
PY1=62;
PX1=23;
RndRLIMon;
PY1=54;
PX1=26;
SpawnIceMonster;
PY1=59;
PX1=32;
SpawnIceMonster;
    #ets1 monsters
PY1=60;
PX1=14;
SpawnIceMonster;
PX1=15;
SpawnIceMonster;
PX1=16;
SpawnIceMonster;

#ets3 monsters
winets3mon::PY1=58;
PX1=52;
RndRLIMon;
PY1=59;
RndRLIMon;
PY1=60;
RndRLIMon;
PY1=61;
RndRLIMon;



EnableETS1::ETSCurrent=0;   # this is the one we are working on
((ETSDidMsg==0))RealEnableETS;


EnableETS2::ETSCurrent=1;   # this is the one we are working on
((ETSDidMsg==0))RealEnableETS;


EnableETS3::ETSCurrent=2;   # this is the one we are working on
((ETSDidMsg==0))RealEnableETS;


RealEnableETS::ETSDidMsg=1;
msg:msgETSEnable;
enable:buildings;

#give way to get final crystals
ETS2New::PY1=55;
PX1=31;
PI01=61;
TyabDrawTile;


ETS1Monster::shake:1.0;
PY1=53;
PX1=18;
PI01=34;
TyabDrawTile;
wait:0.5;
RndRIMon;
msg:msgETSMonster;
wait:2.5;
PI01=38;
TyabDrawTile;


ETS2Monster::shake:1.0;
PY1=62;
PX1=23;
SpawnIceMonster;
msg:msgETSMonster;


ETS3Monster::shake:1.0;
PY1=62;
PX1=52;
RndRIMon;
PY1=61;
PX1=38;
SpawnIceMonster;
msg:msgETSMonster;

#ETS1 done. make a drillable wall to start action to get out

ETS1Finished::PY1=53;
PX1=17;
PI01=26;
TyabDrawTile;


ETS2Finished::shake:1.0;
PY1=57;
PX1=28;
PI01=61;
TyabDrawTile;    #restore tile so we can get out
PY1=60;
PX1=29;
PY2=50;
PX2=30;
PI01=61;
TyabFill;
PI01=0;
TyabDrawRect;    #add path so we can jump to exit
PY1=61;
PX1=32;
PI01=26;
TyabDrawTile;   #make drillable exit


#make new exit back to 4 path area
ETS3Finished::PY1=51;
PX1=51;
PY2=54;
PX2=51;
PI01=61;
TyabFill;
PI01=0;
TyabDrawRect;

#on path after puzzel to ETS2 lake
D4926::shake:0.5;
drill:50,26;
msg:msgCrystals;

D5031::shake:0.6;
drill:49,31;
drill:49,30;
msg:msgETSMaybeMon;

D5331::TyabTriggerLock;
shake:0.6;
drill:52,31;
msg:msgETSMaybeMon;
    #prevent escape
PY1=57;
PX1=28;
PY2=57;
PX2=28;
PI01=11;
TyabFill;
TyabQueueDrawRect;
TyabTriggerRelease;

D6243::shake:0.5;
drill:62,44;
msg:msgETSMaybeMon;
air+=250;   # air adjustment

E6249::TyabTriggerLock;
ETS3MoreMonsters;
msg:msgAchievementMonsterMash;
TyabTriggerRelease;

ETS3StartPath::TyabTriggerLock;
shake:1.5;
drill:54,49;
drill:54,50;
msg:msgETSMaybeMon;
    #block exit
PY1=62;
PX1=46;
PY2=62;
PX2=47;
PI01=6;
TyabFill;
TyabQueueDrawRect;
ETS3MoreMonsters;
TyabTriggerRelease;

#extra monster spawns in monster field and 4 paths area around ETS3
ETS3MoreMonsters::PY1=61;
PX1=38;
SpawnIceMonster;
PY1=60;
SpawnIceMonster;
PY1=59;
SpawnIceMonster;
PY1=37;
PX1=46;
RndRIMon;
RndRIMon;
PY1=35;
PX1=54;
RndRIMon;
RndRIMon;
PY1=37;
PX1=39;
PI01=34;
TyabDrawTile;
RndRIMon;
RndRIMon;
PY1=44;
PX1=39;
RndRIMon;
PX1=43;
RndRIMon;
PX1=45;
RndRIMon;
PX1=51;
RndRIMon;

ExitingET2Lake::TyabTriggerLock;
shake:1.0;
drill:49,35;
drill:49,36;
msg:msgCrystals;
PY1=62;
PX1=23;
SpawnIceMonster;
PY1=59;
PX1=32;
SpawnIceMonster;
SpawnIceMonster;
PY1=54;
PX1=26;
SpawnIceMonster;
SpawnIceMonster;
TyabTriggerRelease;

D5814::shake:0.6;
drill:59,14;


FoundHC::msg:msgFoundHC;


FoundInitCave::msg:msgFInitCave;


FoundInitLake::TyabTriggerLock;
shake:1.5;
PY1=7;
PX1=6;
PI01=26;
TyabDrawTile;       #allow drilling to see the path
msg:msgFILQuake1;
TyabTriggerRelease;


FoundILake2::TyabTriggerLock;
shake:1.5;
PY1=1;
PX1=19;
PI01=26;
TyabDrawTile;       #allow drilling to see the path
PX1=18;
TyabDrawTile;       #allow drilling to see the path
msg:msgFILQuake2;
TyabTriggerRelease;

OpenETS2Lake::TyabTriggerLock;
shake:1.0;
drill:55,21;
PY1=48;
PX1=19;
msg:msgMountain;
RndRLMon;
RndRLMon;
PY1=62;
PX1=18;
PY2=62;
PX2=19;
PI01=11;
TyabFill;
TyabQueueDrawRect;
TyabTriggerRelease;


L1Path1::msg:msgL1Path1;


L1Path1Monsters::TyabTriggerLock;
msg:msgL1PMon;
PY1=18;
PX1=23;
RndRLMon;
PY1=21;
PX1=20;
RndRLMon;
PY1=19;
PX1=23;
RndRLMon;
PY1=16;
PX1=22;
RndRLMon;
TyabTriggerRelease;
wait:6;
msg:msgAchievementThrillSeeker;


L1PathHelp1::TyabTriggerLock;
shake:0.7;
PY1=1;
PX1=9;
PY2=1;
PX2=12;
RndFill;
PY1=1;
PX1=11;
PY2=2;
PX2=11;
PI01=11;
TyabFill;
TyabQueueDrawRect;
TyabTriggerRelease;

RndFill::PI04=3;
PIA01[0]=61;
PIA01[1]=10;
PIA01[2]=9;
PIA02[0]=333;
PIA02[1]=333;
PIA02[2]=334;
TyabRandomRect;
PI01=0;
TyabDrawRect;


CloseCall1::msg:msgL1PCC1;


L1PathHelp2::TyabTriggerLock;
PY1=3;
PX1=2;
PY2=8;
PX2=2;
RndFill;
PY1=9;
PI01=26;
TyabDrawTile;       # give way out
PY1=4;
PY2=4;
PI01=11;
TyabFill;
TyabQueueDrawRect;
TyabTriggerRelease;

L22502::shake:0.5;
drill:26,2;
msg:msgCrystals;


L22703::TyabTriggerLock;
PY1=22;
PX1=4;
RndRLMon;
RndRLMon;
TyabTriggerRelease;


L22611::TyabTriggerLock;
PY1=23;
PX1=8;
RndRLMon;
RndRLMon;
TyabTriggerRelease;


L23107::TyabTriggerLock;
PY1=30;
PX1=17;
SpawnIceMonster;
PY1=29;
SpawnIceMonster;
TyabTriggerRelease;

L33302::TyabTriggerLock;
shake:0.9;
msg:msgMountain;
PY1=31;
PX1=6;
PY2=31;
PX2=9;
PI01=11;
TyabFill;
TyabQueueDrawRect;
TyabTriggerRelease;


L33505::TyabTriggerLock;
PY1=31;
PX1=1;
RndRLMon;
PY1=32;
RndRLMon;
TyabTriggerRelease;


L33610::TyabTriggerLock;
PY1=33;
PX1=6;
RndRLMon;
PX1=7;
RndRLMon;
TyabTriggerRelease;


L33716::TyabTriggerLock;
PY1=33;
PX1=13;
RndRLMon;
PX1=14;
RndRLMon;
TyabTriggerRelease;


L34315::TyabTriggerLock;
PY1=40;
PX1=17;
RndRLIMon;
PY1=41;
RndRLMon;
TyabTriggerRelease;


L34203::TyabTriggerLock;
PY1=39;
PX1=1;
RndRLMon;
PY1=40;
RndRLMon;
TyabTriggerRelease;


L34807::TyabTriggerLock;
PY1=45;
PX1=1;
RndRLIMon;
PY1=46;
RndRLIMon;
TyabTriggerRelease;


L34912::TyabTriggerLock;
PY1=46;
PX1=17;
RndRLIMon;
PY1=47;
RndRLIMon;
TyabTriggerRelease;


L35907::TyabTriggerLock;
PY1=51;
PX1=1;
RndRLMon;
PY1=52;
RndRLMon;
PY1=53;
RndRLMon;
PY1=54;
RndRLMon;
TyabTriggerRelease;


L35311::TyabTriggerLock;
PY1=60;
PX1=9;
PI01=34;
TyabDrawTile;
RndRLIMon;
PX1=10;
PI01=34;
TyabDrawTile;
RndRLIMon;
shake:3.0;
    #open upper river
PY1=60;
PX1=7;
PY2=61;
PX2=7;
PI01=11;
TyabFill;
TyabQueueDrawRect;
PY1=32;
PX1=2;
PY2=33;
PX2=14;
PI01=11;
TyabFill;
TyabQueueDrawRect;
msg:msgL3Quake1;
    #start region1 flood. When it hits region 2, we will start that flood
PY1=25;
PX1=2;
PY2=59;
PX2=12;
PY3=59;
PX3=7;    #Start point for flooding
PI01=11;
PI02=425;  # min time to wait before flooding a cell (100 = 1 second)
PI03=2;    # max tiles to change in a draw call - should be kept low for best visual appearance 1-3
PI04=300;  # Delay start of region processing (100 = 1 second)
PI05=1;    # 1 = use Rays to cross areas, 0 = walkable flood only
TyabFlood;
TyabTriggerRelease;

#done withETS1 drill this to have quake to generate path out

L35317::TyabTriggerLock;
shake:2.5;
PY1=22;
PX1=17;
PI01=26;
TyabDrawTile;       # way back to starting area
PY1=52;
PX1=16;
PY2=53;
PX2=16;
PI01=2;
TyabFill;       # path point
PI01=0;
TyabDrawRect;
PY1=25;
PI01=2;
TyabDrawTile;       # path point
WaterPath1;         # generate path across water
TyabTriggerRelease;


RndRLIMon::((random(0)(2)==0))[SpawnRockMonster][RndLIMon];


RndRIMon::((random(0)(1)==0))[SpawnRockMonster][SpawnIceMonster];


RndRLMon::((random(0)(1)==0))[SpawnRockMonster][SpawnLavaMonster];


RndLIMon::((random(0)(1)==0))[SpawnLavaMonster][SpawnIceMonster];


SpawnRockMonster::emerge:PY1,PX1,A,CreatureRockMonster_C,0;


SpawnLavaMonster::emerge:PY1,PX1,A,CreatureLavaMonster_C,0;


SpawnIceMonster::emerge:PY1,PX1,A,CreatureIceMonster_C,0;


WaterPath1::PY1=42;   # fill in obstructions to avoid
PX1=9;
PY2=43;
PX2=10;
PI05=0;     # no obstructions so far
TyabObstructAdd;
PY1=54;
PX1=13;
PY2=59;
PX2=16;
TyabObstructAdd;
PY1=25;
PX1=2;
PY2=26;
PX2=4;
TyabObstructAdd;
PY1=25;
PX1=10;
PY2=25;
PX2=11;
TyabObstructAdd;
PY1=31;
PX1=15;
PY2=33;
PX2=16;
TyabObstructAdd;
PY1=25;
PX1=2;
PY2=59;
PX2=16;
TyabReadMapTiles;   #first must read so we can draw the path
PY3=25;
PX3=16;     # path end point is at least cell size away from obstruction
PY4=52;
PX4=16;     # path end point is at least cell size away from obstruction
PI01=1;     #width
PI02=2;     #cell size
PI04=4;     #number of tiles in random path
PIA01[0]=60;
PIA01[1]=61;
PIA01[2]=62;
PIA01[3]=63;
PIA02[0]=250;
PIA02[1]=250;
PIA02[2]=250;
PIA02[3]=250;
TyabPath;
PI01=TyNeg1;    # only draw paths
TyabQueueDrawRect;

#once the flood changes this tile, spawn 2nd flood to cover the rest of the region

L35212Water::TyabTriggerLock;
PY1=25;
PX1=13;
PY2=52;
PX2=16;
PY3=52;
PX3=12;    #Start point for flooding
PI01=11;
PI02=425;  # min time to wait before flooding a cell (100 = 1 second)
PI03=2;    # max tiles to change in a draw call - should be kept low for best visual appearance 1-3
PI04=300;  # Delay start of region processing (100 = 1 second)
PI05=1;    # 1 = use Rays to cross areas, 0 = walkable flood only
TyabFlood;
TyabTriggerRelease;


L2512Water::TyabTriggerLock;
PY1=1;
PX1=2;
PY2=25;
PX2=16;
PY3=25;
PX3=8;    #Start point for flooding
PI01=11;
PI02=425;  # min time to wait before flooding a cell (100 = 1 second)
PI03=2;    # max tiles to change in a draw call - should be kept low for best visual appearance 1-3
PI04=0;    # Delay start of region processing (100 = 1 second)
PI05=1;    # 1 = use Rays to cross areas, 0 = walkable flood only
TyabFlood;
TyabTriggerRelease;

#leaving lake flooded path, open up two new paths, close off path behind

D2317::TyabTriggerLock;
shake:2.0;
PY1=22;
PX1=17;
PI01=10;
TyabDrawTile;   # path back to start area
PY1=26;
PX1=12;
PY2=27;
PX1=16;
PI01=11;
TyabFill;
TyabQueueDrawRect;
PY1=22;
PX1=21;
PY2=23;
PX2=21;
PI01=26;
TyabFill;
PI01=0;
TyabDrawRect;   # open path to puzzle pre hint area
LavaAreaAllowAccess;
    #ets1 monsters
PY1=60;
PX1=14;
SpawnIceMonster;
PX1=15;
SpawnIceMonster;
PX1=16;
SpawnIceMonster;
TyabTriggerRelease;
msg:msgAchievementChoose;

LavaAreaAllowAccess::PY1=1;
PX1=20;
PI01=10;
TyabDrawTile;
PY1=1;
PX1=21;
PY2=1;
PX2=22;
PI01=26;
TyabFill;
PI01=0;
TyabDrawRect;

################ puzzle #####
intarray mpSolution         # solution to puzzle
intarray mpUserSolution     # solution user is trying
intarray mpOrder            # order to setup
int mpUserIndex=0      # increments as player solves 0-4. 4 is win
int mpCenRow=40
int mpCenCol=26
float mpDieWindow=60.0
float mpDieTime=0.0
int mpState=0      # 0 = needs reset on entry, will move to state 1 on entry after draw
                        # 1 = active waiting for sequence;
                        # 2 = error - leave. Will move back to 0 when you leave
                        # 3 = win, exit opened, no longer active

mapPuzzleInit::;
mpDieTime=0.0;       # not dying
mpState=0;           # put into reset state
mpUserIndex=0;
mpUserSolution[0]=0;
mpUserSolution[1]=0;
mpUserSolution[2]=0;
mpUserSolution[3]=0;
mpUserSolution[4]=0;  # to prevent overflow when we win
mpOrder[0]=1;
mpOrder[1]=2;
mpOrder[2]=3;
mpOrder[3]=4;
    #mix up the order
TI01=random(0)(3);
TI02=mpOrder[0];
mpOrder[0]=mpOrder[TI01];
mpOrder[TI01]=TI02;
TI01=random(1)(3);
TI02=mpOrder[1];
mpOrder[1]=mpOrder[TI01];
mpOrder[TI01]=TI02;
TI01=random(2)(3);
TI02=mpOrder[2];
mpOrder[2]=mpOrder[TI01];
mpOrder[TI01]=TI02;

#redraw the puzzle map, also used to draw error condition
mapPuzzleDraw::;
((mpState==3))[mapPuzzleDrawCenterError][mapPuzzleDrawCenterOk];
PY1=mpCenRow-6;
PX1=mpCenCol;
PI01=12;
TyabDrawTile;
PY1+=1;
TyabDrawTile;
PY1+=10;
TyabDrawTile;
PY1+=1;
TyabDrawTile;
PY1-=2;
PI01=63;
TyabDrawTile;
PY1-=1;
TyabDrawTile;
PY1-=7;
TyabDrawTile;
PY1+=1;
TyabDrawTile;
PY1+=1;
PI01=10;
TyabDrawTile;
PY1+=4;
TyabDrawTile;
PY1=mpCenRow;
PX1=mpCenCol-6;
PI01=12;
TyabDrawTile;
PX1+=1;
TyabDrawTile;
PX1+=10;
TyabDrawTile;
PX1+=1;
TyabDrawTile;
PX1-=2;
PI01=63;
TyabDrawTile;
PX1-=1;
TyabDrawTile;
PX1-=7;
TyabDrawTile;
PX1+=1;
TyabDrawTile;
PX1+=1;
PI01=10;
TyabDrawTile;
PX1+=4;
TyabDrawTile;
PY3=mpCenRow-7;
PX3=mpCenCol;
PI02=mpOrder[0];
mapPuzzleEWDraw;
PY3=mpCenRow+7;
PX3=mpCenCol;
PI02=mpOrder[1];
mapPuzzleEWDraw;
PY3=mpCenRow;
PX3=mpCenCol+7;
PI02=mpOrder[2];
mapPuzzleNSDraw;
PY3=mpCenRow;
PX3=mpCenCol-7;
PI02=mpOrder[3];
mapPuzzleNSDraw;

mapPuzzleDrawCenterOk::PY1=mpCenRow-1;
PX1=mpCenCol-1;
PY2=mpCenRow+1;
PX2=mpCenCol+1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;       # solid rock with no sparkles

# -- error center is sparkly lava
mapPuzzleDrawCenterERROR::PY1=mpCenRow-1;
PX1=mpCenCol-1;
PY2=mpCenRow+1;
PX2=mpCenCol+1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=6;
TyabFill;
TyabQueueDrawRect;

# input PY3, PX3 center point, PI02=number 1,2,3,4
mapPuzzleEWDraw::;
    # -- first have to clear it out
PY1=PY3;
PY2=PY3;
PX1=PX3-2;
PX2=PX3+2;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;    # back to normal recharge seam
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;    # solid rock with no sparkles
((mpState==0))return;  # reset state leave it clear
((mpState==3))return;  # win state leave it clear
TI08=PI02//2;
PX1=PX3-TI08;
PX2=PX1+PI02;
PX2-=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;   # now it sparkles
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;   # and it has non-standard look with sparkles

# input PY3, PX3 center point, PI02=number 1,2,3,4
# input TI05, TI06 center point, TI07=number 1,2,3,4
mapPuzzleNSDraw::;
PX1=PX3;
PX2=PX3;
PY1=PY3-2;
PY2=PY3+2;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;            # back to normal recharge seam
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;          # solid rock with no sparkles
((mpState==0))return;  # reset state leave it clear
((mpState==3))return;  # win state leave it clear
TI08=PI02//2;
PY1=PY3-TI08;
PY2=PY1+PI02;
PY2-=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;   # now it sparkles
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;   # and it has non-standard look with sparkles

mpFirstInit::TyabTriggerLock;
shake:0.5;
drill:27,19;
PY1=27;
PX1=19;
PY2=27;
PX2=20;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;
PX1=21;
PI01=50;    # different looking recharge seam
TyabDrawTile;
PI01=38;
TyabDrawTile;
PI01=53;
TyabDrawTile;               # different recharge seam - not sparkling
PX1=18;
TyabDrawTile;
msg:msgPuzzle1st;   # msg about dampening field
TyabTriggerRelease;

mpOpenCave::TyabTriggerLock;
shake:0.5;
PY1=35;
PX1=19;
PY2=35;
PX2=20;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=34;
PX1=18;
PY2=35;
PX2=18;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;    # different looking recharge no longer sparkles
msg:msgPuzzleOpen;
TyabTriggerRelease;

mpDampField::((mpState!=0))mpDoDampField;

mpDoDampField::((mpState!=4))mpOkDampField; # check for win condition

mpOkDampField::TyabTriggerLock;
shake:1.5;
mpDieTime=0.0;      # no longer dying
mpState=0;          #back to dampening state
msg:msgPuzzleDamp;
mapPuzzleDraw;      # draw 0 state
TyabTriggerRelease;

mpEnterPuzzle::((mpState==0))mpDoEnterPuzzle;

mpDoEnterPuzzle::TyabTriggerLock;
shake:2.0;
mapPuzzleInit;
mpState=1;      # waiting for sequence
mapPuzzleDraw;
msg:msgPuzzleS0;
TyabTriggerRelease;

mpPad1::((mpState==1))mpDoPad1;

mpPad2::((mpState==1))mpDoPad2;

mpPad3::((mpState==1))mpDoPad3;

mpPad4::((mpState==1))mpDoPad4;

int mpDirChoice=0

mpDoPad1::mpDirChoice=0;     # array index for north pad
mpProcessPad;

mpDoPad2::mpDirChoice=1;     # array index for South pad
mpProcessPad;

mpDoPad3::mpDirChoice=2;     # array index for East pad
mpProcessPad;

mpDoPad4::mpDirChoice=3;     # array index for West pad
mpProcessPad;

# mpDirChoice 0,1,2,3 for the N, S, E, W pads
mpProcessPad::TyabTriggerLock;
((mpUserSolution[mpUserIndex]==0))[mpPadFirstTime][mpMaybeChoice]; #if not set, set this as our choice
TyabTriggerRelease;

# only happens first time we start, we save this one as our choice
mpPadFirstTime::mpUserSolution[mpUserIndex]=mpOrder[mpDirChoice];
((mpUserSolution[mpUserIndex]==mpSolution[mpUserIndex]))[mpChoiceGood][mpError]

# we may be coming back to the same one we just left - that is ok and we ignore it
mpMaybeChoice::((mpUserSolution[mpUserIndex]!=mpOrder[mpDirChoice]))mpNewChoice;

# made a new choice
mpNewChoice::mpUserIndex+=1;
mpUserSolution[mpUserIndex]=mpOrder[mpDirChoice];
((mpUserSolution[mpUserIndex]==mpSolution[mpUserIndex]))[mpChoiceGood][mpError]

# did a new choice and it is correct.TI01 is the pad choice
mpChoiceGood::shake:1.0;
((mpDirChoice==0))mpConnectN;
((mpDirChoice==1))mpConnectS;
((mpDirChoice==2))mpConnectE;
((mpDirChoice==3))mpConnectW;
((mpUserIndex==0))msg:msgPuzzleS1;  # down to high
((mpUserIndex==1))msg:msgPuzzleS2;  # down to medium
((mpUserIndex==2))msg:msgPuzzleS3;  # down to low
((mpUserIndex==3))mpWinPuzzle;

mpWinPuzzle::mpState=4;          # complete
msg:msgPuzzleS4;
PY1=45;
PX1=21;
PI01=26;
TyabDrawTile;
wait:4;
msg:msgAchievementObservant;

mpConnectN::PY1=mpCenRow-1;
PX1=mpCenCol;
PI01=50;
TyabDrawTile;
PI01=53;
TyabDrawTile;                   # different recharge sparkling
PY2=PY1-1;
PY1=PY2-4;
PX2=PX1;
PI01=8;
TyabFill;
PI01=0;
TyabDrawRect;

mpConnectS::PY1=mpCenRow+1;
PX1=mpCenCol;
PI01=50;
TyabDrawTile;
PI01=53;
TyabDrawTile;                   # different recharge sparkling
PY1+=1;
PY2=PY1+4;
PX2=PX1;
PI01=8;
TyabFill;
PI01=0;
TyabDrawRect;

mpConnectE::PY1=mpCenRow;
PX1=mpCenCol+1;
PI01=50;
TyabDrawTile;
PI01=53;
TyabDrawTile;                   # different recharge sparkling
PX1+=1;
PX2=PX1+4;
PY2=PY1;
PI01=8;
TyabFill;
PI01=0;
TyabDrawRect;

mpConnectW::PY1=mpCenRow;
PX1=mpCenCol-1;
PI01=50;
TyabDrawTile;
PI01=53;
TyabDrawTile;                   # different recharge sparkling
PX2=PX1-1;
PX1=PX2-4;
PY2=PY1;
PI01=8;
TyabFill;
PI01=0;
TyabDrawRect;

# move to error state
mpError::((mpState!=3))mpRealError;

mpRealError::mpState=3;     # incorrect sequence
TyabNotificationReset;      # reset message notification flags
mapPuzzleDraw;              # draw error 
mpDieTime=fNow+mpDieWindow; # compute time for shield Failure
mpTimer;

# in error state, player will die unless they move to dampening field
mpTimer::TF01=mpDieTime-FNow;
TF01+=0.5;
((TF01<0.0))TF01=0.0;
PI01=TF01;      #integer seconds to live
((PI01>0))[mpShowTimeLeft][mpDie];

mpDie::mpDieTime=0.0;  # turn off timer
((didLose==1))return;   # already in map lose state
didLose=1;
msg:msgPuzzleDie;
lose:msgPuzzleDie;

mpShowTimeLeft::TyabNotificationCheckAndSet;      # see if this range has been done before
((RI01==0))mpShowTimeMsg;   # ok to draw this one

mpShowTimeMsg::shake:0.2;
TS01=msgPuzzleError;
TS01+=PI01;
TS01+=" seconds";
msg:TS01;

# compute the random solution, and update the map with the hints
MapPuzzleSetSolution::;
mpSolution[0]=1;
mpSolution[1]=2;
mpSolution[2]=3;
mpSolution[3]=4;    # set default, now mix it up.
    #mix up the order
TI01=random(0)(3);
TI02=mpSolution[0];
mpSolution[0]=mpSolution[TI01];
mpSolution[TI01]=TI02;
TI01=random(1)(3);
TI02=mpSolution[1];
mpSolution[1]=mpSolution[TI01];
mpSolution[TI01]=TI02;
TI01=random(2)(3);
TI02=mpSolution[2];
mpSolution[2]=mpSolution[TI01];
mpSolution[TI01]=TI02;
PY1=10;
PX1=1;
mpDrawRowSolution;
PY1=28;
PX1=34;
mpDrawColSolution;
PY1=30;
PX1=34;
mpDrawColSolution;

# input - PY1, PX1 starting position. Draw increasing in Y
# output - PY1 is one character past last one written (initial PY1+13)
mpDrawRowSolution::;
    # - first must clear entire region of sparkles. Set to recharge seam, then solid rock.
PY2=PY1+12;
PX2=PX1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
    # now draw each one. First draw it as recharge seam, then $(tRechargeSeamIntersect), this leaves the sparkles
    #PX2=PX1;  # did above
PY2=PY1+mpSolution[0];
PY1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=PY2+1;
PY2=PY1+mpSolution[1];
PY1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=PY2+1;
PY2=PY1+mpSolution[2];
PY1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=PY2+1;
PY2=PY1+mpSolution[3];
PY1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=PY2+1;

# input - PY1, PX1 starting position. Draw increasing in X
# output - PX1 is one character past last one written (initial PX1+13)
mpDrawColSolution::;
    # - first must clear entire region of sparkles. Set to recharge seam, then solid rock.
PX2=PX1+12;
PY2=PY1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
    # - now draw the solution
PY2=PY1;
PX2=mpSolution[0]+PX1;
PX1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PX1=PX2+1;
PX2=mpSolution[1]+PX1;
PX1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PX1=PX2+1;
PX2=mpSolution[2]+PX1;
PX1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PX1=PX2+1;
PX2=mpSolution[3]+PX1;
PX1+=1;
PI01=50;
TyabFill;
PI01=0;
TyabDrawRect;
PI01=53;
TyabFill;
PI01=0;
TyabDrawRect;
PX1=PX2+1;
    #PI01=41;
    #TyabDrawTile;

#open up passage to give hint
D2522::TyabTriggerLock;
shake:0.5;
PY1=25;
PX1=22;
PY2=25;
PX2=23;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;
TyabTriggerRelease;

D2832::TyabTriggerLock;
shake:0.5;
drill:28,33;
msg:msgCrystals;
PY1=18;
PX1=23;
SpawnLavaMonster;
PY1=19;
PX1=23;
SpawnLavaMonster;
TyabTriggerRelease;

D2824::TyabTriggerLock;
shake:1.0;
PY1=27;
PX1=20;
PI01=26;
TyabDrawTile;       # allow access to dampening field and thus puzzle
PY1=28;
PX1=32;
PY2=28;
PX2=33;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;  # allow path back to hint
PY1=26;
PX1=24;
PY2=28;
PX2=24;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;  # finish drilling this wall section
TyabTriggerRelease;

D3050::TyabTriggerLock;
shake:0.5;
PY1=28;
PX1=32;
PY2=28;
PX2=33;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;  # block return path, must deal with trap
drill:31,50;   # drill the crystals
msg:msgCrystals;
TyabTriggerRelease;

D3349::shake:0.5;
drill:34,49;
msg:msgCrystals;

D3548::shake:0.5;
drill:35,47;
msg:msgCrystals;

D3543::shake:0.5;
drill:35,42;
msg:msgCrystals;

E2942::TyabTriggerLock;
shake:0.4;
PY1=28;
PX1=28;
RndRIMon;
PY1=28;
PX1=30;
RndRIMon;
PY1=30;
PX1=33;
RndRIMon;
TyabTriggerRelease;

E3539::TyabTriggerLock;
shake:0.5;
PY1=28;
PX1=49;
RndRIMon;
PY1=32;
PX1=51;
RndRIMon;
PY1=35;
PX1=50;
RndRIMon;
TyabTriggerRelease;

D3232::TyabTriggerLock;
shake:0.5;
drill:32,31;
msg:msgCrystals;
PY1=32;
PX1=37;
PY2=32;
PX2=47;
PI01=6;
TyabFill;
TyabQueueDrawRect;  # landfalls into lava now
PY1=28;
PX1=49;
RndRIMon;
PX1=50;
RndRIMon;
PY1=36;
PX1=38;
RndRIMon;
TyabTriggerRelease;

D3436::TyabTriggerLock;
shake:0.5;
drill:33,36;
msg:msgCrystals;
PY1=31;
PX1=48;
RndRIMon;
PY1=32;
PX1=51;
RndRIMon;
PY1=35;
PX1=50;
RndRIMon;
TyabTriggerRelease;

e2940::((mpState!=4))msg:msgPuzzleHint1;  # if not solved, give the hint

D2530::TyabTriggerLock;
PY1=25;
PX1=30;
PY2=26;
PX2=30;
PI01=10;
TyabFill;
PI01=0;
TyabDrawRect;   # make exit from lava room
LavaRoomExit;
msg:msgAchievementJump;
TyabTriggerRelease;

#leaving lava room, open up path to 4 paths and ETS3, path back to start, init 4 paths drill order
LavaRoomExit::shake:0.7;
PY1=29;
PX1=51;
PI01=26;
TyabDrawTile;    # open up new passage
PY1=24;
PX1=26;
PI01=26;
TyabDrawTile;     # allow new passage to exit
PY1=5;
PX1=23;
PI01=26;
TyabDrawTile;     # allow exit for new passage

####### mind room.
int MindState=0    # tracts the state of the mind event. 0 is never started, -1 is finished. others are the state in the event
float MindStateStartTime=0.0

#timer only when MindState > 0 - used to change between the different states of the event
MindStateTimer::((MindState==10))MindState10;
((MindState==9))MindState9;
((MindState==8))MindState8;
((MindState==7))MindState7;
((MindState==6))MindState6;
((MindState==5))MindState5;
((MindState==3))MindState3;
((MindState==2))MindState2;

MindRoomOpen::TyabTriggerLock;
drill:35,58;     # open the mind room
PY1=18;
PX1=61;
RndRIMon;   # spawn some monsters to encourage you to go inside
PY1=19;
RndRIMon;
msg:msgMind01;
TyabTriggerRelease;

int mindSaveAir=0   # save air at beginning to restore

MindRoomWall::TyabTriggerLock;
mindSaveAir=air;        # save current air
air+=3000;              # set air to max , we restore orig air after event.
shake:0.3;
msg:msgMind01a;
PY1=37;
PX1=59;
PY2=37;
PX2=59;
PI01=6;
TyabFill;
TyabQueueDrawRect;  # can't leave room
PY1=36;
PX1=57;
PY2=36;
PX2=58;
PI01=6;
TyabFill;
TyabQueueDrawRect;  # can't leave room
PY1=34;
PX1=58;
PY2=37;
PX2=58;
PI01=6;
TyabFill;
TyabQueueDrawRect;  # can't leave room
TyabTriggerRelease;

MindRoomStart::TyabTriggerLock;   # lock for drawing
drill:47,61;
speed:1.0;
PY1=46;
PX1=60;
PI01=58;
TyabDrawTile;
PX1=62;
PI01=58;
TyabDrawTile;
    # trap us
PY1=42;
PX1=61;
PY2=43;
PX2=61;
PI01=58;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=43;
PX1=62;
PI01=57;
TyabDrawTile;
PX1=60;
PI01=57;
TyabDrawTile;
PY1=42;
PX1=62;
PI01=57;
TyabDrawTile;
PX1=60;
PI01=57;
TyabDrawTile;
msg:msgMind03;
MindState=1;
TyabTriggerRelease;             # done drawing, wait for role playing messages
wait:9.0;
msg:msgMind04;
wait:12.0;
msg:msgMind05;
wait:7.0;
msg:msgMind06;
wait:11.0;
msg:msgMind07;
wait:9.0;
msg:msgMind08;
wait:9.0;
msg:msgMind09;
wait:9.0;
msg:msgMind10;
wait:9.0;
msg:msgMind11;
wait:10.0;
msg:msgMind12;
wait:9.0;
msg:msgMind13;
wait:12.0;
msg:msgMind14;
wait:8.0;
msg:msgMind15;
wait:9.0;
msg:msgMind16;
wait:16.0;
msg:msgMind17;
wait:9.0;
msg:msgMind18;
wait:9.0;
msg:msgMind19;
wait:9.0;
msg:msgMind20;
TyabTriggerLock;              # lock for drawing
disable:lights;
crystals=10;
PY1=48;
PX1=61;
PY2=55;
PX2=61;
PI01=6;
TyabFill;
TyabQueueDrawRect;
PY1=52;
PX1=61;
PY2=53;
PX2=61;
PI01=11;
TyabFill;
TyabQueueDrawRect;
MindState=2;
TyabTriggerRelease;          # release done drawing

MindState2::MindStateStartTime=fNow;
MindState=3;

MindState3::TF01=fNow-MindStateStartTime;
((TF01>2.0))MindState3a;

MindState3a::MindState=4;  # NOP since it does not exist. Wait until change trigger on lava
pan:57,57;
enable:lights;
msg:msgMind21;
wait:12.0;
msg:msgMind22;
wait:8.0;
MindBaseMonsterRow;
msg:msgMind23;
wait:6.0;
MindBaseMonsterRow;
wait:5.0;

MindBaseMonsterRow::PY1=54;
PX1=60;
RndRLIMon;
PX1=59;
RndRLIMon;
PX1=58;
RndRLIMon;
PX1=57;
RndRLIMon;
PX1=56;
RndRLIMon;
PX1=55;
RndRLIMon;
PX1=54;
RndRLIMon;

MindRoomSLava::TyabTriggerLock;
msg:msgMind24;
drill:62,54;
drill:62,55;
MindBaseLavaMonRow;
TyabTriggerRelease;
wait:4.5;
TyabTriggerLock;
drill:62,56;
drill:62,57;
drill:62,58;
drill:62,59;
drill:62,60;
drill:62,61;
MindBaseLavaMonRow;
TyabTriggerRelease;
wait:4.5;
TyabTriggerLock;
MindBaseLavaMonRow;
TyabTriggerRelease;

MindBaseLavaMonRow::PY1=54;
PX1=60;
SpawnLavaMonster;
PX1=59;
SpawnLavaMonster;
PX1=58;
SpawnLavaMonster;
PX1=57;
SpawnLavaMonster;
PX1=56;
SpawnLavaMonster;
PX1=55;
SpawnLavaMonster;
PX1=54;
SpawnLavaMonster;

# call by change tile to lava event - not timer.
MindRoomELava::TyabTriggerLock;
shake:2.0;
disable:lights;
pan:45,61;
    # make sure all units are dead - turn entire area into lava
PY1=55;
PX1=54;
PY2=62;
Px2=62;
PI01=6;
TyabFill;
TyabQueueDrawRect;
    # turn entrance/exit back to solid rock
PY1=49;
PX1=61;
PY2=54;
Px2=61;
PI01=38;
TyabFill;
PI01=0;
TyabQueueDrawRect;
TyabTriggerRelease;  # done - allow timers to run
wait:1.5;   # allows draw to turn entire room to lava happens via timer
msg:msgMind25;
wait:1.5;
MindState=5;  # now after delay we change to the next state for next room

MindState5::MindStateStartTime=fNow+5.0;
wait:5.0;
    # first change last room to solid rock
PY1=54;
PX1=53;
PY2=62;
Px2=62;
PI01=38;
TyabFill;
PI01=0;
TyabQueueDrawRect;
PY1=49;
PX1=61;
PY2=51;
Px2=61;
PI01=6;
TyabFill;
TyabQueueDrawRect;
PY1=51;
PX1=57;
PY2=51;
Px2=61;
PI01=6;
TyabFill;
TyabQueueDrawRect;
MindState=6;

MindState6::TF01=fNow-MindStateStartTime;
((TF01>2.0))MindState6a;

MindState6a::shake:2.0;
msg:msgMind26;
pan:50,56;
enable:lights;
MindState=7;
MindStateStartTime=fNow;
wait:2.0;
PY1=52;
PX1=55;
RndRIMon;
RndRIMon;
RndRIMon;
RndRIMon;
RndRIMon;
RndRIMon;
RndRIMon;

MindState7::;  # wait until lava

MindCrystalELava::TyabTriggerLock;
MindState7a;  #lava at tile, get control back.
TyabTriggerRelease;

MindState7a::wait:3.0;
shake:2.0;
disable:lights;
pan:45,61;
PY1=49;
PX1=53;
PY2=52;
Px2=58;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=49;
PX1=59;
PY2=52;
Px2=61;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
MindState=8;
PY1=43;
PX1=61;
PI01=1;
TyabDrawTile;
PX1=60;
PI01=58;
TyabDrawTile;
PX1=62;
PI01=58;
TyabDrawTile;
PY1=42;
PX1=60;
PI01=58;
TyabDrawTile;
PX1=62;
PI01=58;
TyabDrawTile;
MindState=8;

MindState8::MindStateStartTime=fNow;
MindState=9;

MindState9::TF01=fNow-MindStateStartTime;
((TF01>1.0))MindState9a;

MindState9a::enable:lights;
shake:1.0;
crystals=0;
ore=0;
MindStateStartTime=fNow+59.0;
MindStateShieldMsg;
MindState=10;
TyabNotificationReset;
PY1=37;
PX1=58;
PY2=38;
PX2=59;
PI01=1;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=34;
PX1=58;
PY2=35;
PX2=58;
PI01=1;
TyabFill;
PI01=0;
TyabDrawRect;

MindState10::MindStateShieldMsg;

MindStateShieldMsg::;
TF01=MindStateStartTime-fNow;
TF01+=0.5;
((TF01<0.0))TF01=0.0;
PI01=TF01;
((PI01>0))[MindStateOKMsg][MindStateLoseGame];

MindStateOKMsg::TyabNotificationCheckAndSet;
((RI01==0))MindStateShieldDoMsg;

MindStateShieldDoMsg::;
TS01=msgMind27;
TS01+=PI01;
TS01+=" seconds";
msg:TS01;

MindStateLoseGame::msg:msgMindLoseGame;
MindState=TyNeg1;
((didLose==1))return;
didLose=1;
msg:msgMindLoseGame;
lose:msgMindLoseGame;

MindStateEnd::TyabTriggerLock;
MindState=TyNeg1;     # done with mind state
shake:1.5;
PY1=35;
PX1=57;
PY2=36;
Px2=59;
PI01=38;
TyabFill;
PI01=0;
TyabDrawRect;
PY1=37;
PX1=57;
PI01=58;
TyabDrawTile;
    #open path to lava room
PY1=7;
PX1=60;
PY2=8;
Px2=60;
PI01=26;
TyabFill;
PI01=0;
TyabDrawRect;
TyabTriggerRelease;
msg:msgMind28;
wait:10.0;
msg:msgMind29;
wait:10.0;
msg:msgMind30;
wait:10.0;
msg:msgMind31;
wait:12.0;
msg:msgMind32;
wait:10.0;
msg:msgMind33;
wait:12.0;
msg:msgMind34;
wait:11.0;
msg:msgAchievementMind;
resetspeed;
air=mindSaveAir;        # end of event, restore air to start value

D0132::TyabTriggerLock;
shake:0.5;
drill:1,33;
msg:msgCrystals;
PY1=18;
PX1=23;
SpawnLavaMonster;
PY1=19;
SpawnLavaMonster;
PY1=16;
PX1=22;
RndRLIMon;
TyabTriggerRelease;

D0344::TyabTriggerLock;
shake:0.5;
drill:2,44;
msg:msgCrystals;
PY1=1;
PX1=27;
RndRLIMon;
PY1=2;
PX1=23;
RndRLIMon;
PY1=3;
PX1=25;
RndRLIMon;
TyabTriggerRelease;

D0154::TyabTriggerLock;
shake:0.5;
drill:1,55;
msg:msgCrystals;
PY1=4;
PX1=34;
RndRLIMon;
PX1=33;
RndRLIMon;
PY1=3;
PX1=32;
RndRLIMon;
TyabTriggerRelease;

D0862::TyabTriggerLock;
shake:0.5;
drill:9,62;
msg:msgCrystals;
PY1=2;
PX1=42;
RndRLIMon;
PY1=4;
RndRLIMon;
PX1=43;
RndRLIMon;
TyabTriggerRelease;

D2261::TyabTriggerLock;
shake:0.5;
drill:22,60;
msg:msgCrystals;
PY1=1;
PX1=57;
RndLIMon;
PY1=4;
PX1=58;
RndRLIMon;
PY1=2;
PX1=60;
RndRIMon;
TyabTriggerRelease;

D3061::TyabTriggerLock;
shake:0.5;
drill:30,60;
PY1=12;
PX1=60;
RndRIMon;
PY1=13;
RndRIMon;
TyabTriggerRelease;

#---- lava room
int HeatState=0                   # 0 off, 1 on
float HeatOnTime=0.0              #time entered heat
float HeatShieldDuration=282.0    # number of secs for full charge heat shield
float HeatTimeLeft=282.0          # remaining time in seconds. We don't update this until heat is off

HeatTimer::HeatComputeValue;          # only called when heat state is on
((PI01>0))TyabNotificationCheckAndSet;  #flag we have set this range
((PI01>0))[HeatMsgStatus][HeatLoseGame];

# called when changing from off to on state
HeatTurningOn::HeatOnTime=fNow;    #record time entered
speed:1.0;
HeatState=1;                       #now in heat area
TyabNotificationReset;               #reset notifications
HeatComputeValue;                  #PI01 will have 0-100 percentage
((PI01>0))TyabNotificationCheckAndSet;         #flag we have set this range
RI01=0;                            #ignore return, always show message when turning on
((PI01>0))[HeatMsgStatus][HeatLoseGame];

# called when changing from on to off state
HeatTurningOff::resetspeed;
HeatComputeValue;  # first check to see if we just died
TF01=fNow-HeatOnTime;
HeatTimeLeft-=TF01;         # save where we are at in case we reenter heat on
HeatState=0;                # no longer tracking heat
RI01=0;                     #always show message
((PI01>0))[HeatMsgStatus][HeatLoseGame];

LavaRoomHeatOn::TyabTriggerLock;
((HeatState==0))HeatTurningOn;
TyabTriggerRelease;

LavaRoomHeatOff::TyabTriggerLock;
((HeatState==1))HeatTurningOff;
TyabTriggerRelease;

HeatLoseGame::HeatState=0;
((didLose==1))return;
didLose=1;
msg:msgHeatLoseGame;
lose:msgHeatLoseGame;

HeatComputeValue::TF01=fNow-HeatOnTime;           # how long since we turned on shield
TF01=HeatTimeLeft-TF01;         # decrement from HeatTimeLeft
((TF01<0.0))TF01=0.0;           # death
TF01*=100.0;
TF01/=HeatSHieldDuration;
TF01+=0.5;
PI01=TF01;                      # integer percentage
((PI01<=0))PI01=0;

#input PI01 int percentage 0-100.  RI01=0 show, =1 don't show
HeatMsgStatus::((RI01==0))HeatMsgShow;  # only show if range allowed it or we are forcing

HeatMsgShow::((HeatState==1))[HeatOnMsg][HeatOffMsg];

HeatOnMsg::((PI01<=20))[TS01=msgHeatShieldCrit][TS01=msgHeatShieldWrn];
TS01+=PI01;
TS01+="%";
msg:TS01;

HeatOffMsg::TS01=msgHeatShieldInfo;
TS01+=PI01;
TS01+="%";
msg:TS01;

D2951::TyabTriggerLock;
shake:0.6;
FourPathDrillOrderInit;     # now compute the drill order for the 4 paths
drill:28,51;
msg:msgCrystals;
PY1=28;
PX1=28;
RndRIMon;
PY1=28;
PX1=30;
RndRIMon;
PY1=30;
PX1=33;
RndRIMon;
TyabTriggerRelease;

E3154::TyabTriggerLock;
shake:0.5;
PY1=28;
PX1=49;
RndRIMon;
PY1=31;
PX1=48;
RndRIMon;
PY1=27;
PX1=52;
RndRIMon;
TyabTriggerRelease;

# called when allow entrance into area to set the initial order. Then we mix up each group of 4
FourPathDrillOrderInit::fourpdorIndex=0;        # make sure to start at 0
    # row 0
fourpdorY[0]=39;
fourpdorX[0]=39;
fourpdorDrillY[0]=40;
fourpdorDrillX[0]=39;
fourpdorY[1]=39;
fourpdorX[1]=42;
fourpdorDrillY[1]=40;
fourpdorDrillX[1]=42;
fourpdorY[2]=39;
fourpdorX[2]=46;
fourpdorDrillY[2]=40;
fourpdorDrillX[2]=46;
fourpdorY[3]=39;
fourpdorX[3]=52;
fourpdorDrillY[3]=39;
fourpdorDrillX[3]=53;
    # row 1
fourpdorY[4]=42;
fourpdorX[4]=38;
fourpdorDrillY[4]=43;
fourpdorDrillX[4]=38;
fourpdorY[5]=42;
fourpdorX[5]=42;
fourpdorDrillY[5]=43;
fourpdorDrillX[5]=42;
fourpdorY[6]=42;
fourpdorX[6]=46;
fourpdorDrillY[6]=43;
fourpdorDrillX[6]=46;
fourpdorY[7]=41;
fourpdorX[7]=55;
fourpdorDrillY[7]=42;
fourpdorDrillX[7]=55;
fourpdorY[8]=45;
fourpdorX[8]=38;
fourpdorDrillY[8]=46;
fourpdorDrillX[8]=38;
fourpdorY[9]=45;
fourpdorX[9]=41;
fourpdorDrillY[9]=46;
fourpdorDrillX[9]=41;
fourpdorY[10]=45;
fourpdorX[10]=46;
fourpdorDrillY[10]=45;
fourpdorDrillX[10]=47;
fourpdorY[11]=44;
fourpdorX[11]=58;
fourpdorDrillY[11]=45;
fourpdorDrillX[11]=58;    #row 2
fourpdorY[12]=47;
fourpdorX[12]=38;
fourpdorDrillY[12]=48;
fourpdorDrillX[12]=38;
fourpdorY[13]=47;
fourpdorX[13]=44;
fourpdorDrillY[13]=48;
fourpdorDrillX[13]=44;
fourpdorY[14]=47;
fourpdorX[14]=47;
fourpdorDrillY[14]=48;
fourpdorDrillX[14]=47;
fourpdorY[15]=47;
fourpdorX[15]=51;
fourpdorDrillY[15]=48;
fourpdorDrillX[15]=51;   #row 3
fourpdorY[16]=50;
fourpdorX[16]=39;
fourpdorDrillY[16]=51;
fourpdorDrillX[16]=39;
fourpdorY[17]=51;
fourpdorX[17]=44;
fourpdorDrillY[17]=51;
fourpdorDrillX[17]=43;
fourpdorY[18]=51;
fourpdorX[18]=47;
fourpdorDrillY[18]=51;
fourpdorDrillX[18]=46;
fourpdorY[19]=51;
fourpdorX[19]=51;
fourpdorDrillY[19]=51;
fourpdorDrillX[19]=50;  #row 4
    #now mix up each group of 4
TI01=0;
TI02=3;
FourPathRndOrder;
TI01=4;
TI02=7;
FourPathRndOrder;
TI01=8;
TI02=11;
FourPathRndOrder;
TI01=12;
TI02=15;
FourPathRndOrder;
TI01=16;
TI02=19;
FourPathRndOrder;
FourPathChangeTile;     # row 0, make it drillable

#we just drilled one, autodrill its neighbor to get crystals, then change next one to drillable
FourPathDrillTrigger::TyabTriggerLock;
shake:1.0;
doFourPathDrill;
TyabTriggerRelease;


doFourPathDrill::((fourpdorIndex>19))return;    #ignore should never happen
PY1=fourpdorDrillY[fourpdorIndex];
PX1=fourpdorDrillX[fourpdorIndex];
drill:PY1,PX1;   # drill the crystals next to the one we just changed to dirt wall
fourpdorIndex+=1;
((fourpdorIndex<=19))[FourPathChangeTile][FourPathOpenMonCave];


FourPathOpenMonCave::PY1=52;
PX1=39;
PY2=53;
PX2=39;
PI01=1;
TyabFill;
PI01=0;
TyabDrawRect;
air+=250;   # air adjustment

# just change the current index to drillable
FourPathChangeTile::PY1=fourpdorY[fourpdorIndex];
PX1=fourpdorX[fourpdorIndex];
PI01=26;
TyabDrawTile;           # change wall to dirt wall

# each group of 4 we randomize
#input TI01 = start index, TI02 = end index. Must be a range enclosing 4, starting at index 0
FourPathRndOrder::FourPathSwapValues; #swap first with random first-last
TI01+=1;
FourPathSwapValues;  #swap 2nd with random 2nd - last
TI01+=1;
FourPathSwapValues;  #swap 3rd with random 3rd - last

#input TI01 = start index, TI02=end index. Swap all arrays with random index [TI01,TI02]
FourPathSwapValues::TI03=random(TI01)(TI02);  # random index to use
TI04=fourpdorY[TI01];            # entrance Y's
fourpdorY[TI01]=fourpdorY[TI03];
fourpdorY[TI03]=TI04;
TI04=fourpdorX[TI01];           # entrance X's
fourpdorX[TI01]=fourpdorX[TI03];
fourpdorX[TI03]=TI04;
TI04=fourpdorDrillY[TI01];      # drill Y
fourpdorDrillY[TI01]=fourpdorDrillY[TI03];
fourpdorDRillY[TI03]=TI04;
TI04=fourpdorDrillX[TI01];      # drill X
fourpdorDrillX[TI01]=fourpdorDrillX[TI03];
fourpdorDrillX[TI03]=TI04;

D0121::msg:msgLongMode1;

int longMapMode=0

D0122::msg:msgLongMode2;
longMapMode=1;
ETSWinCrystals=75;  # long mode enables the 3rd ETS
ETSWinOre=30;

#-------------------------------------
##pragma include "TyabGenericScript.scr"
#.####################### Tyab Generic Script ##############################
#. TyabGenericScript.scr (c) 2022 Tyab All Rights Reserved
##pragma TyabScriptIncDate vy.m.d.g  v2025.03.30.
#
# useful utilities for dynamic map modifications
# convention used in this script is Y is row and X is column.
# Tyab functions all work in map space, 0,0 is the upper left corner including border.
# Most functions internally modify a memory tile store. It can be smaller then the map.
# Due to slow script processing speed, it is not viable to do large single mass changes
# at once, but you can do small changes in a large map.
# there is no limit on the size of a region but due to script engine limits the width or height
# should not exceed 800 or so.
# the general logic flow is the following:
#   1. Use TyabInit before calling any other method. Best is to call it from your init::EVENT;
#   2. Use TyabReadMapTiles to read in any tiles you will not modify as part of a later draw. This is optional.
#   3. Use Tyab* to change a portion of in memory tiles.
#   4. Use TyabDrawRect to draw changed portions of the region to the map.
#
# If you do #2 on a large map, realize the script engine is measured in 10's of thousands of lines
# per second and a 128x128 map is over 16K thousand cells so just the reading can take some time.
# It is best to just read a smaller subregion that you will then modify. If the functions are are calling
# do not skip cells, you don't need to read in tiles first.
# some functions may take longer processing time so they are resumable. TyabTimer should
# be called on a regular basis and it will finish in chunks things that take some time.
# TyabBusy is an int, and if it is non-zero, one of the functions is busy. Calling most functions
# when another function is busy will have that call ignored. This allows larger modifications to happen
# without significant impact on game play interaction. But it does mean if you are going to do
# large area modifications that you have to account for that. For example, creating a maze or path
# that is large, you will want to start it before you really need it and put a few time-sink type
# of user operations before you need the result. (drill a few walls, walk across a open area, etc)
# TyabDrawRect is special - it is queued up and will take place automatically once
# TyabBusy is 0, so you can make a maze and then draw it and not worry about if the maze is done or not.
# TyabFlood is also special, it is designed to always run off of TyabTimer so you may make any other call
# after calling TyabFlood - it will process the flood in the background. There are no limits to the number of
# active floods at the same time.
#
############################################################################
#
# Tyab API quick reference: See each method below for calling parameters
#   TyabInit         - Required before any Tyab method. Initialized vars and set up the tile store
#   TyabTimer        - Required. Call often to allow incremental update and larger mazes.
#   TyabReadMapTiles - Call to read map tiles back into internal array.
#   TyabFill         - Fill rectangular region with a tile ID.
#   TyabRandomRect   - Fill rectangular region with a probability list tile.
#   TyabWalkRect     - Change all walkable tiles to a probability list tile in a region.
#                      One will want to call TyabReadMapTiles before using this in most cases.
#   TyabDrillRect    - Change all drillable tiles to a probability list tile in a region.
#                      One will want to call TyabReadMapTiles before using this in most cases.
#   TyabDrilling     - drill every map tile in the given region. Tilemap is NOT updated.
#   TyabReplaceRect  - Replace the given tile with probability list tile in a region.
#   TyabDrawRect     - Draw map from internal array incrementally. Needs TyabTimer to be called to complete larger updates.
#   TyabQueueDrawRect- Same as DrawRect but queues the draw for a later TyabTimer event
#   TyabDrawTile     - Set a single map tile.
#   TyabGetTile      - Get a single map tile.
#   TyabMaze         - Create a random maze into internal array. Needs TyabTimer to make larger mazes.
#   TyabPath         - Create a random path between two points within a rect. Needs TyabTimer for larger paths.
#   TyabTightPath    - Like path but will zig/zag and only supports single tile paths. Is MUCH slower than path.
#   TyabObstructAdd  - Helper function to add region to obstruction data for Path and TightPath
#   TyabFlood        - start a flood with a given tile. Multiple may be started.
#   TyabFloodStop    - Stops all floods in progress.
#   TyabNotificationInit - setup notification values. It also calls TyabNotificationReset
#   TyabNotificationReset  - reset notifications so they can be done again
#   TyabNotificationCheckAndSet - check if value in the notification ranges has been seen before
#   TyabTriggerLock    - serialize access across triggers and timer
#   TyabTriggerRelease - release serial access across triggers and timers
#
############################  predefined tile types
# Tile IDs are mapped to their respective texture.
# There are four types of wall textures:
#   - Regular, where it has 3 neighbor tiles and 2 diagonal neighbors adjacent to each other
#   - Corner, where it has 4 neighbors and 3 diagonal neighbors
#   - Edge, where it has 2 neighbor tiles and 1 diagonal neighbors,
#   - Intersect, where it has 4 neighbors and 2 diagonal neighbors opposite to each other
#
#  tiles tagged in comments as cosmetic are generated by the engine automatically - not user settable
#  from script you place the regular tiles and engine will generate the correct corners/edges
# Reinforced walls have 50 added to the base value.
# Hidden walls have 100 added to the base value. From script I can't get hidden to work as intended -
# thus if you want to modify an area that will be discovered, it must be discovered first, then modify.
#
# negative and 0 are not used. Values unused or outside of range are an error and can generate an invalid tile in-game.
# all macros. Use $(name) to get the value, must process through Tyab MMDatUtil for macro processing
##pragma define tGround=1
##pragma define tRubble1=2
##pragma define tRubble2=3
##pragma define tRubble3=4
##pragma define tRubble4=5
##pragma define tLava=6
##pragma define tErosion4=7
##pragma define tErosion3=8
##pragma define tErosion2=9
##pragma define tErosion1=10
##pragma define tWater=11
##pragma define tSlimyHole=12
##pragma define tPowerpathInProgress=13
##pragma define tPowerpathBuilding=14
##pragma define tPowerpathBuildingpowered=15
##pragma define tPowerpath1=16
##pragma define tPowerpath1Powered=17
##pragma define tPowerpath2Adjacent=18
##pragma define tPowerpath2AdjacentPowered=19
##pragma define tPowerpath2Opposite=20
##pragma define tPowerpath2OppositePowered=21
##pragma define tPowerpath3=22
##pragma define tPowerpath3Powered=23
##pragma define tPowerpath4=24
##pragma define tPowerpath4Powered=25
##pragma define tDirtRegular=26
##pragma define tDirtCorner=27
##pragma define tDirtEdge=28
##pragma define tDirtIntersect=29
##pragma define tLooseRockRegular=30
##pragma define tLooseRockCorner=31
##pragma define tLooseRockEdge=32
##pragma define tLooseRockIntersect=33
##pragma define tHardRockRegular=34
##pragma define tHardRockCorner=35
##pragma define tHardRockEdge=36
##pragma define tHardRockIntersect=37
##pragma define tSolidRockRegular=38
##pragma define tSolidRockCorner=39
##pragma define tSolidRockEdge=40
##pragma define tSolidRockIntersect=41
##pragma define tCrystalSeamRegular=42
##pragma define tCrystalSeamCorner=43
##pragma define tCrystalSeamEdge=44
##pragma define tCrystalSeamIntersect=45
##pragma define tOreSeamRegular=46
##pragma define tOreSeamCorner=47
##pragma define tOreSeamEdge=48
##pragma define tOreSeamIntersect=49
##pragma define tRechargeSeamRegular=50
##pragma define tRechargeSeamCorner=51
##pragma define tRechargeSeamEdge=52
##pragma define tRechargeSeamIntersect=53
                                    # 54 Not used
                                    # 55 Not used
                                    # 56 Not used
                                    # 57 Not used
##pragma define tRoof=58
##pragma define tFakeRubble1=60
##pragma define tFakeRubble2=61
##pragma define tFakeRubble3=62
##pragma define tFakeRubble4=63
##pragma define tCliff1=64                          # collision barrier looks like rubble experimental
##pragma define tCliff2=65                          # collision barrier looks like solid rock experimental
##pragma define tDirtRegularReenforced=76           # 76 = 26 + 50  
##pragma define tLooseRockRegulaReenforced=80       # 80 = 30 + 50
##pragma define tHardRockRegularReenforced=84       # 84 = 34 + 50
##pragma define tSolidRockRegularReenforced=88      # 88 = 38 + 50
##pragma define tDirtRegularHidden=126              # 126 = 26 + 100
##pragma define tLooseRockRegulaHidden=130          # 130 = 30 + 100
##pragma define tHardRockRegularHidden=134          # 134 = 34 + 100
##pragma define tSolidRockRegularHidden=138         # 138 = 38 + 100

# remaining vars can change and are used to pass parameters to/from the Tyab methods
# also are defined internal temp vars. Do not assume values across Tyab methods.
# clients can use these themselves as long as no Tyab* is called since they are free to modify them
# clients must not remove any of these

# for loop simulation control variables. Add more as needed
int L01=0
int L02=0
int L03=0
#int L04=0
#int L05=0
#int L06=0
#int L07=0
#int L08=0
#int L09=0
#int L10=0

# general int parameters to pass to functions (events). Add more as needed

int PI01=0
int PI02=0
int PI03=0
int PI04=0
int PI05=0
int PI06=0
int PI07=0
#int PI08=0
#int PI09=0

# general intarray parameters. Add more as needed
intarray PIA01
intarray PIA02
intarray PIA03
intarray PIA04
#intarray PIA05

# parameters for X (column),Y (rows) values. Add more as needed
# Tyab* methods are free to modify any of these
int PX1=0
int PY1=0
int PX2=0
int PY2=0
int PX3=0
int PY3=0
int PX4=0
int PY4=0
#int PX5=0
#int PY5=0
#int PX6=0
#int PY6=0
#int PX7=0
#int PY7=0
#int PX8=0
#int PY8=0
#int PX9=0
#int PY9=0

# return values from methods (events). Add more as needed.
# Tyab* methods are free to modify any of these
int RI01=0
int RI02=0
int RI03=0
int RI04=0
#int RI05=0
#int RI06=0
#int RI07=0
#int RI08=0
#int RI09=0

# temp vars. Only used for short term calcs within a set of functions. Add more as needed
int TI01=0
int TI02=0
int TI03=0
int TI04=0
int TI05=0
int TI06=0
int TI07=0
int TI08=0
int TI09=0
int TI10=0
int TI11=0
int TI12=0
int TI13=0
int TI14=0

float TF01=0.0
float TF02=0.0
float TF03=0.0
#float TF04=0.0
#float TF05=0.0
#float TF06=0.0
#float TF07=0.0
#float TF08=0.0
#float TF09=0.0

# temporary strings. Add more as needed
string TS01=""
#string TS02=""
#string TS03=""
#string TS04=""
#string TS05=""
#string TS06=""
#string TS07=""
#string TS08=""
#string TS09=""

# messsage strings. Use with msg:   Change, add as needed
string S01="String01"
string S02="String02"
#string S03="String03"
#string S04="String04"
#string S05="String05"
#string S06="String06"
#string S07="String07"
#string S08="String08"
#string S09="String09"

###########
# memory tilemap
intarray TyMapTiles

int TyNeg1=0  # will become -1 since script does not like negative constants
int TynXtiles=0  # width of region
int TynYtiles=0  # height of region
int TynSize=0    # height*width
int TynX1=0      # col of region start
int TynY1=0      # row of region start
int TynX2=0      # col of region end
int TynY2=0      # row of region end
int TyabBusy=0   # 0=not busy, 1=maze building, 2=maze drawing, 3=path building, 4=path drawing, 5=tightpath building
int TyabTimerDraw=0  #1= Tyab did a draw during TyabTimer or its busy with maze/path

#.############### TyabTriggerLock / TyabTriggerRelease #########################
# --- trigger control to serialize access between timers and triggers
# -- from a trigger, call TriggerLock to get the lock. Prior to event returning, call TriggerRelease
# -- Do not do this from the main timer event - only from if/when triggers

int TyabInMyTimer=0            # detect timer recursion. Caller should set/clear this in their timer logic
int TyTriggerNeedsControl=0    # contains number of triggers waiting for control
int TyTriggerHasControl=0      # set when a trigger has control, 0 when it finishes, so another trigger waiting for control can get it.

TyabTriggerLock::TyTriggerNeedsControl+=1;    # a trigger want to get access, this has timer ignored
((TyabInMyTimer==0))[TyTriggerTimerDone][TyTriggerTimerLoop]; # wait until timer finished (if it was running)

TyTriggerTimerLoop::wait:random(0.035)(0.085);    # give timer a chance to finish - use short random time
((TyabInMyTimer==0))[TyTriggerTimerDone][TyTriggerTimerLoop]; # wait until timer finished (if it was running)

# timer has finished, now we need to get the lock to continue or wait until we get the lock
TyTriggerTimerDone::((TyTriggerHasControl==0))[TyTriggerHasControl=1][TyTriggerWaitLoop];

TyTriggerWaitLoop::wait:random(0.035)(0.085);   # multiple triggers waiting, wait random time
((TyTriggerHasControl==0))[TyTriggerHasControl=1][TyTriggerWaitLoop]

TyabTriggerRelease::TyTriggerHasControl=0;  # release lock
TyTriggerNeedsControl-=1;               # this trigger is no longer waiting
# ---


#.############### TyabEngineVer ##################################################
# check to see what version of the engine is playing.
# TyabMMEngineVer  0        = unknown. Engine is before 20220930
#       20220930 = engine is 20220930 or newer  ( supports divide // and /= )
#       20221212 = engine is 20221212 or newer  ( no longer supports / event separator )
#       20230414 = engine is 20230414 or newer  ( has return event )
int TyabMMEngineVer=0

TyabEngineVer::TyTry20230414;
((TyabMMEngineVer<20230414))TyNot20230414;

TyTry20230414::TyabMMEngineVer=20230414;
return;             # unknown event prior to 20230414
TyabMMEngineVer=0;  #older versions will execute this line

TyNot20230414::TyabMMEngineVer=10;
TyValid20220903;
((TyabMMEngineVer==5))[Ty20220903orLater][TyabMMEngineVer=0]; # if divide works at least 20220903

TyValid20220903::TyabMMEngineVer=TyabMMEngineVer//2;  # divide event

TyVerDummy1::;   #empty event chain to ensure above parses 

# 2022-09-03 or later
Ty20220903orLater::TyabMMEngineVer=10;
TyInvalidEvent20221212;
((TyabMMEngineVer==5))[TyabMMEngineVer=20220903][TyabMMEngineVer=20221212];

# this is invalid on 2022-12-12 or later. Prior 5 will be set
TyInvalidEvent20221212::TyabMMEngineVer=5/   # old style separator

TyVerDummy2::;   #empty event chain to ensure above parses 

#.############### TyabInit ##################################################
# defines inclusive region for memory tile map. Can be full map size for all maps
# since the tile store is not initialized.
# PY1, PX1 row,col start (usually 0,0 but can be any upper left corner)
# PY2, PX2: row,col end. Usually this is the highest row/col in the editor (height-1, width-1)
#          The resulting tilemap will be (height = PY2-PY1+1, width = PX2-PX1+1)
# NOTE: If you define a smaller region then the entire map, you cannot use Tyab methods to address
#       outside of that region. There are no checks for this, and most likly you will crash the game
#       due to negative array indexes. You are warned.
#       Likewise - it is invalid for any Tyab method to use coords outside the range of the map
#       again most likly you will crash the game engine.

TyabInit::;
TyNeg1=0-1;                    #neg 1 constant to work around negative constants script bug
TyabBusy=0;
TynX1=PX1;
TynY1=PY1;
TynX2=PX2;
TynY2=PY2;
TynYtiles=PY2-PY1;             #height
TynYtiles+=1;
TynXtiles=PX2-PX1;             #width
TynXtiles+=1;
TynSize=TynYtiles*TynXtiles;  #size of byte map
TyMapTiles[0]=0;
TI01=TynSize-1;
TyMapTiles[TI01]=0;     # make sure its allocated to this size
TyInitWalkDrill;        # initialize our walk/drill flags
TyMzConstInit;          # initialize maze/path bits/flags
TyFlInit;               # init flooding system
TyabNotificationInit;   # setup default message notification system
TyCmdEmpty;             # init command queue to empty

intarray TyWalkTile   # array for each tile, 0=not walkable, 1=walkable. only for tiles 0-255
intarray TyDrillTile  # array for each tile, 0=not drillable, 1=drillable. only for tiles 0-255.
intarray TyLavaOrWater # array for each tile, 0=not lava/water, 1=lava or water

# initialize the walkable and drillable tile flags

TyInitWalkDrill::;
L01=0;
TyInitWDL;

TyInitWDL::;
TI01=1;     #assume walkable
TI02=L01;
((L01>100))TI02-=100;
((TI02>=76))TI02-=50;
    # set lava/water
TyLavaOrWater[L01]=0;
((TI02==11))TyLavaOrWater[L01]=1;
((TI02==6))TyLavaOrWater[L01]=1;
    # set walkable
((TI02<1))TI01=0;
((TI02>25))TI01=0;
((TI02==6))TI01=0;
((TI02==11))TI01=0;
((TI02==60))TI01=1;
((TI02==61))TI01=1;
((TI02==62))TI01=1;
((TI02==63))TI01=1;
TyWalkTile[L01]=TI01;          # save walkable state
    # set drillable
TI01=1;       # assume drillable
((TI02<26))TI01=0;
((TI02>49))TI01=0;
((TI02==38))TI01=0;
((TI02==39))TI01=0;
((TI02==40))TI01=0;
((TI02==41))TI01=0;
TyDrillTile[L01]=TI01;         # save drillable state
L01+=1;
((L01<256))TyInitWDL;

#.############### TyabTimer #################################################
# timer event. Call often!. incremental output needs regular timers. We also spin the random to change sequence
# returns TyabTimerDraw=1 if we did draw something, 0 = did not draw
#priority: 1) Pending draw actions.
#          2) Pending maze/path actions
#          3) Pending command queue actions
#          4) Pending flood actions

TyabTimer::TI01=random(0)(1);  #next in psuedo random sequence
TyabTimerDraw=TyabBusy;
((TyabBusy>0))[TyTimerMz][TyDrawTimerChk];

# if pending updates, do those, otherwise do flood timer
TyDrawTimerChk::((TyDRnChunks>0))[TyDRNext][TyCmdTimerChk];

# return TyabTimerDraw=1 if something was drawn, 0=nothing drawn. Can be used to prevent mixing water/lava/other draws in same trigger
TyCmdTimerChk::((TyCmdRIndex<TyCmdWIndex))[TyCmdNextCommand][TyFlTimerChk];

TyFlTimerChk::((TyFlNRegions>0))TyFlRegionLInit;

TyTimerMz::((TyabBusy==2))TyabIMaze;  #maze draw first
((TyabBusy==1))TyabIMaze;             #then check maze generation
((TyabBusy==4))TyabIPath;             #path draw first
((TyabBusy==3))TyabIPath;             #then check path generation
((TyabBusy==5))TyabITightPath;        #tight path generation

#.############### TyabReadMapTiles ##########################################
# utility to read in map tile ID's into TyMapTiles intarray
# can be used to just read a subsection
# input parameters:
# PX1, PY1  start x,y location to read.
# PX2, PY2  end x,y location to read.
# output:
#   TyMapTiles intarray filled in with ID's for the range.

TyabReadMapTiles::L01=PY1;          # tile row
TyRMTRowL;


TyRMTRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;            # tile index
TI02=PX2-L02;
((TI02>=8))[TyRMTColLg][TyRMTColSm];   #large or small widths
L01+=1;
((L01<=PY2))TyRMTRowL;


TyRMTColSm::TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
((L02<=PX2))TyRMTColSm;


TyRMTColLg::TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TI02=PX2-L02;
((TI02>=8))[TyRMTColLg][TyRMTColSm];

#.############### TyabFill ##########################################
# utility to change a region to the given tile ID
#input parameters
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.
# PI01      tile id to fill

TyabFill::L01=PY1;
TyFrRowL;


TyFrRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyFrColLg][TyFrColSm];  # large columns or small columns
L01+=1;
((L01<=PY2))TyFrRowL;


TyFrColSm::TyMapTiles[TI01]=PI01;
TI01+=1;
L02+=1;
((L02<=PX2))TyFrColSm;


TyFrColLg::TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyFrColLg][TyFrColSm];  #do 8 at at time for performance

#.############### TyabDrilling ##########################################
# utility to drill every tile in a region
#input parameters
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.

TyabDrilling::L01=PY1;
TyDrillingRowL;

TyDrillingRowL::L02=PX1;
TyDrillingColSm;
L01+=1;
((L01<=PY2))TyDrillingRowL;

TyDrillingColSm::drill:L01,L02;
L02+=1;
((L02<=PX2))TyDrillingColSm;

#.############### TyabRandomRect ##########################################
# utility to change every tile in this region to a random tile
#input parameters
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
# PI04: number of path types in PIA01 and PIA02
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabRandomRect::L01=PY1;
TyFrngRowL;


TyFrngRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyFrngColLg][TyFrngColSm];  # column loop
L01+=1;
((L01<=PY2))TyFrngRowL;


TyFrngColSm::TyProbTile;   #get tile from list of probalities
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
L02+=1;
((L02<=PX2))TyFrngColSm;


TyFrngColLg::TyProbTile;   #get tile from list of probalities
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyFrngColLg][TyFrngColSm];

#.##################### Incremental DrawRect support ########################
# incremental draw. Will draw tiles into the map from our array. Total size per actual draw is limited.
intarray TyDRY1Chunk
intarray TyDRX1Chunk
intarray TyDRY2Chunk
intarray TyDRX2Chunk
intarray TyDRTyChunk    # type of draw, 0=all, -1 no water/lava, >0 only draw that id
int TyDRnChunks=0    # number of chunks to draw
int TyDRnMaxDraw=512 #max number of tiles to modify per draw

#call this to draw the next chuck queued up. If none, it does nothing.

TyDrTimer::((TyDRnChunks>0))TyDRNext;   #we have something, draw the next chunks

# draw next chunk.

TyDRNext::TyDRnChunks-=1;
TI04=TyDRY1Chunk[TyDRnChunks];
TI05=TyDRX1Chunk[TyDRnChunks];
TI06=TyDRY2Chunk[TyDRnChunks];
TI07=TyDRX2Chunk[TyDRnChunks];
TI08=TyDRTyChunk[TyDRnChunks];
TI02=TI06-TI04;
TI02+=1;           #height
TI03=TI07-TI05;
TI03+=1;           #width
TI01=TI02*TI03;    #size
TyabTimerDraw=1;        # return we are drawing something
((TI01<=TyDRnMaxDraw))[TyDR][TyDRSubdivide];   #either draw or subdivide

# TI04-TI07 too big. subdivide and try again Favor dividing up rows unless a row is too small

TyDRSubdivide::((TI02>1))[TyDRSubDivY][TyDRSubDivX];  #either split in row or col
TyDRNext;          #try again - eventually we will draw the end of the queue

# Subdividing rows by half. TI02 is height, TI04-TI07 is rect, TI08=type

TyDRSubDivY::TF01=TI02;   #height
TF01*=0.5;
TF01+=0.00001; #round off
TI01=TF01;  #height of first part
TI09=TI04+TI01;  #start of 2nd part
# adding top part
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI09-1;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;
# adding bottom part
TyDRY1Chunk[TyDRnChunks]=TI09;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;

# Subdividing cols by half. TI03 is width

TyDRSubDivX::TF01=TI03;   #width
TF01*=0.5;
TF01+=0.00001; #round off
TI01=TF01;      #width of first part
TI09=TI05+TI01;
# adding left side
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI09-1;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;
# adding right side
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI09;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;

#.############### TyabDrawRect ##########################################
# Draw region to the screen
#input parameters
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
# PI01      type. 0 = draw everything, -1 = draw all but water/lava, >0 only draw that id (normally just tLava and tWater)
# TyMapTiles     intarray of id's.
# you are safe to queue up more regions while the existing ones are drawn one per TyDrTimer event

TyabDrawRect::TyabIQueueDrawRect; # add to short term queue
((TyabBusy==0))TyDRNext;          # draw queue if not waiting for maze/path

TyabIQueueDrawRect::TyDRY1Chunk[TyDRnChunks]=PY1;
TyDRX1Chunk[TyDRnChunks]=PX1;
TyDRY2Chunk[TyDRnChunks]=PY2;
TyDRX2Chunk[TyDRnChunks]=PX2;
TyDRTyChunk[TyDRnChunks]=PI01;
TyDRnChunks+=1;

# draw a single region TI04=Y1, TI05=X1, TI06=Y2, TI07=X2, TI08=type

TyDR::L01=TI04;  #start row
((TI08==0))TyDrRowL;
((TI08==TyNeg1))TyDrRowLN1;
((TI08>0))TyDrRowLID;


TyDrRowL::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>8))[TyDrColLg][TyDrColSm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowL;


TyDrRowLN1::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>=8))[TyDrColN1Lg][TyDrColN1Sm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowLN1;


TyDrRowLID::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>=8))[TyDrColIDLg][TyDrColIDSm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowLID;

TyDrColSm::TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColSm;

# skip lava and water

TyDrColN1Sm::TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColN1Sm;


TyDrColDraw1::TI03=get(L01)(L02);  # read existing
((TI02!=TI03))place:L01,L02,TI02;  # only change if different

# only draw the given ID

TyDrColIDSm::TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColIDSm;



TyDrColLg::TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>=8))[TyDrColLg][TyDrColSm];


TyDrColN1Lg::TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>=8))[TyDrColN1Lg][TyDrColN1Sm];


TyDrColIDLg::TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>8))[TyDrColIDLg][TyDrColIDSm];    #remainder

#.############################ TyabDrawTile #################################
# PY1, PX1  Row, col location to change.
# PI01: TileID

TyabDrawTile::TI01=PY1-TynY1;
TI01*=TynXtiles;
TI01+=PX1;
TI01-=TynX1;
TyMapTiles[TI01]=PI01;
place:PY1,PX1,PI01;

int iPY1=0    # internal only variable
int iPX1=0    # internal only variable
int iPI01=0   # internal only variable
int iRI01=0   # internal only variable

#.############################ iTyabDrawTile #################################
# internal only
# iPY1, iPX1  Row, col location to change.
# iPI01: TileID
iTyabDrawTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
TyMapTiles[TI01]=iPI01;
place:iPY1,iPX1,iPI01;

#.############################ iTyabSetTile #################################
# internal only. Unlike iTyabDrawTile it does not use place, it only changes in-memory array
# iPY1, iPX1  Row, col location to change.
# iPI01: TileID
iTyabSetTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
TyMapTiles[TI01]=iPI01;

#.############################ TyabGetTile #################################
# PY1, PX1  Row, col location to change.
# Return: RI01: TileID

TyabGetTile::TI01=PY1-TynY1;
TI01*=TynXtiles;
TI01+=PX1;
TI01-=TynX1;
RI01=get(PY1)(PX1);
TyMapTiles[TI01]=RI01;

#.############################ iTyabGetTile #################################
# internal only
# iPY1, iPX1  Row, col location to change.
# Return: iRI01: TileID

iTyabGetTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
iRI01=get(iPY1)(iPX1);
TyMapTiles[TI01]=iRI01;


#.################### TyabWalkRect ##########################################
# replace all walkable tiles with a random walkable tile
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
#   PI04: number of path types in IAP01 and IAP02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabWalkRect::L01=PY1;
TyWRowL;

TyWRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyWColLg][TyWColSm];
L01+=1;
((L01<=PY2))TyWRowL;


TyWDR1::TyProbTile;
TyMapTiles[TI01]=RI01;


TyWColSm::RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
L02+=1;
((L02<=PX2))TyWColSm;


TyWColLg::RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyWColLg][TyWColSm];

#.################### TyabDrillRect ##########################################
# replace all drillable tiles with a random walkable tile
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
#   PI04: number of tile types in IAP01 and IAP02
#   PIA01: intarray: each item is the tile id.
#   PIA02: intarray: each item is the odds 0-1000 of using that tile ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabDrillRect::L01=PY1;
TyDrillRowL;


TyDrillRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyDrillColLg][TyDrillColSm];  # columns
L01+=1;
((L01<=PY2))TyDrillRowL;

TyDrillColSm::RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
L02+=1;
((L02<=PX2))TyDrillColSm;

TyDrillColLg::RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyDrillColLg][TyDrillColSm];  # columns

#.################### TyabReplaceRect ##########################################
# replace given tile with probability list tile for region.
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.
#   PI01: Tile to replace.
#   PI04: number of tile types in IAP01 and IAP02
#   PIA01: intarray: each item is the tile id.
#   PIA02: intarray: each item is the odds 0-1000 of using that tile ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabReplaceRect::L01=PY1;
TyReplaceRowL;

TyReplaceRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyReplaceColLg][TyReplaceColSm];  # columns
L01+=1;
((L01<=PY2))TyReplaceRowL;

TyReplaceColSm::((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
L02+=1;
((L02<=PX2))TyReplaceColSm;

TyReplaceColLg::((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyReplaceColLg][TyReplaceColSm];  # columns

##################### TyProbTile ##########################################
# return a random tile based on the array of allowed tiles each with a given probability
# inputs:
#   PI04: number of path types in PIA01 and PIA02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 1-1000 of using that path type ID from PIA01, each value is 0.1%
#                    The sum of all of the odds should be 1000. If sum under 1000, the last item will be selected
#                    If sum is over 1000, the one that breaks the 1000 sum is the last one that can be selected.
#                    You can use 0 to prevent a tile from being selected.
# returns:
#   RI01 is the tile ID for the path.

TyProbTile::TI10=0;   # probability sum
TI12=0;               # loop through probabilities
TI11=random(1)(1000); # get random probability
TyProbTileL;

TyProbTileL::TI10+=PIA02[TI12];  # add in next probability
RI01=PIA01[TI12];                # id of current one
((TI11<=TI10))return;            # found it return
TI12+=1;                         # next loop
((TI12<PI04))TyProbTileL;        # loop until found or run out of items

##################### TyiProbTile ##########################################
# return a random tile based on the array of allowed tiles each with a given probability
# used by routines that use the command queue - var names do not conflict with user vars
# inputs:
#   iPI04: number of path types in iPIA01 and iPIA02
#   iPIA01: intarray: each item is the path type ID.
#   iPIA02: intarray: each item is the odds 1-1000 of using that path type ID from PIA01, each value is 0.1%
#                    The sum of all of the odds should be 1000. If sum under 1000, the last item will be selected
#                    If sum is over 1000, the one that breaks the 1000 sum is the last one that can be selected.
#                    You can use 0 to prevent a tile from being selected.
# returns:
#   iRI01 is the tile ID for the path.

int iPI04=0
intarray iPIA01
intarray iPIA02
int iPSum=0
int iPLoop=0
int iPFind=0

TyiProbTile::iPSum=0;   # probability sum
iPLoop=0;               # loop through probabilities
iPFind=random(1)(1000); # get random probability
TyiProbTileL;

TyiProbTileL::iPSum+=iPIA02[iPLoop];  # add in next probability
iRI01=iPIA01[iPLoop];                 # id of current one
((iPFind<=iPSum))return;              # found it, force loop end
iPLoop+=1;                            # next loop
((iPLoop<iPI04))TyiProbTileL;         # loop until found or run out of items


#.################################## Random Maze #############
#. Random Maze generation. Based on Growing Tree Algorithm.
#. see: https://weblog.jamisbuck.org/2011/1/27/maze-generation-growing-tree-algorithm
# 
# basic psuedo code is as follows
# 1. Let C be a collection of cells - initially empty.
# 2. Put a random cell into C. Tag it as visited.
# 3. Repeat until C is empty
# 4.     Pick a cell from C.  (how you do this changes the behavior - see below)
# 5.     Look at the 4 neighbors of that cell. Are any of them unvisisted?
#           Yes: pick one of the unvisited randomly, make a path to it, add that neighbor to C and tag neighbor as visited.
#           No: Remove the cell from C.
#   
# how you pick the cell in #4 changes the behavior. If it is random, you have Prims algorithm.
# if you pick the newest you get Recursive Backtracking algorithm. As suggested in above link I use a 50/50 mix to get a blend of both.
# Tyab Path is the same but only uses the newest thus Recursive Backtracking.
#
# For conventions the 4 directions (neighbors) are:
#  North:  row-1, col
#  South:  row+1, col
#  East:   row, col+1
#  West:   row, col-1
#  rows and cols are mapped via: index = (row * TyMzXsize) + col

##### define vars we will use.
int TyMzYsize=0
int TyMzXsize=0
int TyMzSize=0          # will be TyMzYsize*TyMzXsize
intarray TyMzXset       # collection class to store cell columns for cells that have paths in progress
intarray TyMzYset       # collection class to store cell rows    for cells that have paths in progress
int TyMzSizeSet=0       # size of collection class
intarray TyMzNeighbors  # internal list of valid directions for a cell
int TyMzSizeNeighbors=0 # number of neighbors in array
intarray TyMzVisited    # 0: not visited, >=1: visited
int TyMzMapScale=0      # number of map tiles per maze cell (1,2,3,4 supported)
float TyMzfMap2Cell=0.0 # convert from map to cell
intarray TyMzDirXInc    # for each dir, contains the x increment value
intarray TyMzDirYInc    # for each dir, contains the Y increment value
intarray TyMzDir2Bit    # map from dir (1-4) to the bit value (1,2,4,8)
intarray TyMzDirB2Bit   # map from dir (1-4) to the return direction bit (2,1,8,4)
intarray TyMzDirN       # map from combined direction bits to single bit for North
intarray TyMzDirS       # map from combined direction bits to single bit for South
intarray TyMzDirE       # map from combined direction bits to single bit for East
intarray TyMzDirW       # map from combined direction bits to single bit for West
intarray TyTpBack1      # map from direction to first backtrack direction to check
intarray TyTpBack2      # map from direction to the 2nd backtrack direction to check
intarray TyTpDDir       # map from 5x5 grid to movement direction

#initialize one time vars and arrays for mazes and paths

TyMzConstInit::;
TyMzDirXInc[0]=0;
TyMzDirYInc[0]=0;     # not used no direction
TyMzDirXInc[1]=0;
TyMzDirYInc[1]=TyNeg1;  # north
TyMzDirXInc[2]=0;
TyMzDirYInc[2]=1;     # south
TyMzDirXInc[3]=1;
TyMzDirYInc[3]=0;     # east
TyMzDirXInc[4]=TyNeg1;
TyMzDirYInc[4]=0;    # west
    # we also add the diagonals - used by TightPath
TyMzDirXInc[5]=1;
TyMzDirYInc[5]=TyNeg1;  # North East
TyMzDirXInc[6]=1;
TyMzDirYInc[6]=1;       # south east
TyMzDirXInc[7]=TyNeg1;
TyMzDirYInc[7]=1;       # south west
TyMzDirXInc[8]=TyNeg1;
TyMzDirYInc[8]=TyNeg1;  # north west
TyMzDir2Bit[0]=0;    # none
TyMzDir2Bit[1]=1;    # North is bit 0
TyMzDir2Bit[2]=2;    # South is bit 1
TyMzDir2Bit[3]=4;    # East is bit 2
TyMzDir2Bit[4]=8;    # West is bit 3
TyMzDirB2Bit[0]=0;    # none
TyMzDirB2Bit[1]=2;    # neighbor goes south for cell north
TyMzDirB2Bit[2]=1;    # neighbor goes north for cell south
TyMzDirB2Bit[3]=8;    # neighbor goes west for cell east
TyMzDirB2Bit[4]=4;    # neighbor goes east for cell west
TyMzDirN[0]=0;      # combined bits into 0,1 for N
TyMzDirN[1]=1;
TyMzDirN[2]=0;
TyMzDirN[3]=1;
TyMzDirN[4]=0;
TyMzDirN[5]=1;
TyMzDirN[6]=0;
TyMzDirN[7]=1;
TyMzDirN[8]=0;
TyMzDirN[9]=1;
TyMzDirN[10]=0;
TyMzDirN[11]=1;
TyMzDirN[12]=0;
TyMzDirN[13]=1;
TyMzDirN[14]=0;
TyMzDirN[15]=1;
TyMzDirS[0]=0;   # combined bits into 0,2 for S
TyMzDirS[1]=0;
TyMzDirS[2]=2;
TyMzDirS[3]=2;
TyMzDirS[4]=0;
TyMzDirS[5]=0;
TyMzDirS[6]=2;
TyMzDirS[7]=2;
TyMzDirS[8]=0;
TyMzDirS[9]=0;
TyMzDirS[10]=2;
TyMzDirS[11]=2;
TyMzDirS[12]=0;
TyMzDirS[13]=0;
TyMzDirS[14]=2;
TyMzDirS[15]=2;
TyMzDirE[0]=0;   # combined bits into 0,4 for E
TyMzDirE[1]=0;
TyMzDirE[2]=0;
TyMzDirE[3]=0;
TyMzDirE[4]=4;
TyMzDirE[5]=4;
TyMzDirE[6]=4;
TyMzDirE[7]=4;
TyMzDirE[8]=0;
TyMzDirE[9]=0;
TyMzDirE[10]=0;
TyMzDirE[11]=0;
TyMzDirE[12]=4;
TyMzDirE[13]=4;
TyMzDirE[14]=4;
TyMzDirE[15]=4;
TyMzDirW[0]=0;     # combined bits into 0,8 for W
TyMzDirW[1]=0;
TyMzDirW[2]=0;
TyMzDirW[3]=0;
TyMzDirW[4]=0;
TyMzDirW[5]=0;
TyMzDirW[6]=0;
TyMzDirW[7]=0;
TyMzDirW[8]=8;
TyMzDirW[9]=8;
TyMzDirW[10]=8;
TyMzDirW[11]=8;
TyMzDirW[12]=8;
TyMzDirW[13]=8;
TyMzDirW[14]=8;
TyMzDirW[15]=8;
    # backtrack dirs are used by TightPath to make sure when backtracking, there is room to escape.
TyTpBack1[0]=0;
TyTpBack1[1]=3; # north checks E
TyTpBack1[2]=3; # south checks E
TyTpBack1[3]=1; # East check N
TyTpBack1[4]=1; # West check N
TyTpBack2[0]=0;
TyTpBack2[1]=4; # north checks W
TyTpBack2[2]=4; # south checks W
TyTpBack2[3]=2; # East check S
TyTpBack2[4]=2; # West check S
    # tight path, when we are within the 5x5 grid of destination, use these directions to get to dest
TyTpDDir[0]=3;   #east
TyTpDDir[1]=2;   #south
TyTpDDir[2]=2;   #south
TyTpDDir[3]=2;   #south
TyTpDDir[4]=4;   #west
TyTpDDir[5]=3;   #east
TyTpDDir[6]=3;   #east
TyTpDDir[7]=2;   #south
TyTpDDir[8]=4;   #west
TyTpDDir[9]=4;   #west
TyTpDDir[10]=3;  #east
TyTpDDir[11]=3;  #east
TyTpDDir[12]=0;  #at destination
TyTpDDir[13]=4;  #west
TyTpDDir[14]=4;  #west
TyTpDDir[15]=3;  #east
TyTpDDir[16]=3;  #east
TyTpDDir[17]=1;  #north
TyTpDDir[18]=4;  #west
TyTpDDir[19]=4;  #west
TyTpDDir[20]=3;  #east
TyTpDDir[21]=1;  #north
TyTpDDir[22]=1;  #north
TyTpDDir[23]=1;  #north
TyTpDDir[24]=4;  #west

#mazes saves input parameters into these so it can continue while some other Tyab methods can be used.
# some are just private versions to avoid conflict with other routines
int TyMzSPX1=0
int TyMzSPY1=0
int TyMzSPX2=0
int TyMzSPY2=0
int TyMzSPX3=0
int TyMzSPY3=0
int TyMzSPX4=0
int TyMzSPY4=0
int TyMzSPX5=0  # not saved, internal use
int TyMzSPY5=0  # not saved, internal use
int TyMzSPX6=0  # not saved, internal use
int TyMzSPY6=0  # not saved, internal use
int TyMzSPI01=0
int TyMzSPI02=0
int TyMzSPI03=0
int TyMzSPI05=0
int TyMzSRI05=0 #not saved, internal use
int TyMzSRI06=0 #not saved, internal use
int TyMzSL01=0  #not saved, internal use
int TyMzSL02=0  #not saved, internal use
int TyMzSL03=0  #not saved, internal use
int TyMzSL05=0  #not saved, internal use
int TyMzSL06=0  #not saved, internal use
int TyMzSL07=0  #not saved, internal use
int TyMzSL08=0  #not saved, internal use
int TyMzSL09=0  #not saved, internal use
int TyMzSL10=0  #not saved, internal use

TyMzSaveVars::TyMzSPX1=PX1;
TyMzSPY1=PY1;
TyMzSPX2=PX2;
TyMzSPY2=PY2;
TyMzSPX3=PX3;
TyMzSPY3=PY3;
TyMzSPX4=PX4;
TyMzSPY4=PY4;
TyMzSPI01=PI01;
TyMzSPI02=PI02;
TyMzSPI03=PI03;
TyMzSPI05=PI05;

# clear out visited array

TyMzVarInit::TyMzSL01=0;    # now init visited array to 0. TyMzYsize and TyMzXsize must have been setup
TI01=0;
TyMz01IRowL;


TyMz01IRowL::TyMzSL02=0;
((TyMzXsize>=8))[TyMz02IColLg][TyMz02IColSm];
TyMzSL01+=1;
((TyMzSL01<TyMzYsize))TyMz01IRowL;


TyMz02IColSm::TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzSL02+=1;
((TyMzSL02<TyMzXsize))TyMz02IColSm;


TyMz02IColLg::TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzSL02+=8;
TI02=TyMzXsize-TyMzSL02;
((TI02>=8))[TyMz02IColLg][TyMz02IColSm];

#.##########################  TyabMaze ######################################
# the maze generation. Caller provides the usable space inside of the maze, we do not change/modify any cells outside of maze
# thus this can be used to generate a submaze inside an existing map and entrances/exits are setup by the caller as ground or
# drillable cells.  Caller defines the size of the path and the size of the internal cells used.
# this does not directly modify the map, it does modify TyMapTiles. Use TyabDrawRect to show the results
# on input:
#   PX1: The starting Y (row) for the maze.
#   PY1: The starting X (column) for the maze
#   PY2: Ending row for use by the maze.
#   PX2: Ending column for use by the maze.
#   PI01: path size. Either 1 or 2. Cannot be larger than cell size. If same as cell size, everything is filled (no maze)
#   PI02: cell size. Either 1, 2, 3, 4 (1 can be used internally for paths)
#   PI03: TileID for walls
#   PI04: number of path types in PIA01 and PIA02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

# command queue deserial entry
TyIMaze::TyabBusy=0;  # should not be necessary but does not hurt
TyabIMaze;            # start normal maze recallable logic

# called from TyabTimer to continue where it left off
TyabIMaze::((TyabBusy==0))[TyMz0][TyMzContinue12];  #start new or continue

# - calling with either state 1 = generation, or 2 = drawing
TyMzContinue12::((TyabBusy==1))[TyMzBusy1][TyMzBusy2];

# - continuing to generate. 
TyMzBusy1::TyMzGenerateBegin;
((TyabBusy==0))TyabBusy=2;   # finished generation, move to drawing
((TyabBusy==2))TyMzDrawInit;  # starting draw, just do init, next time we draw

# - continue with drawing
TyMzBusy2::((TyabBusy==2))TyMzUpdateMap;

TyMz0::TyMzSaveVars;  # copy input, use own vars
TyMzStartNew;    # start a new one
TyMzAddRndCell;             # start from a random cell
TyMzGenerateBegin;          # run the maze engine, build visible and directions
((TyabBusy!=0))return;      # not done, so return
TyMzDrawInit;      #done get ready to draw
TyMzUpdateMap;     #done now draw

# this is callable by one of the path routines.

TyMzStartNew::TyMzInit;                    # compute our internal cell space
TyMzSize=TyMzYsize*TyMzXsize; # number of maze cells
TyMzSizeSet=0;              # no partial paths yet
TyMzVarInit;                # setup TyMzVisited, and directions

# start off with a random cell

TyMzAddRndCell::TI03=TyMzYsize-1;
TI01=random(0)(TI03);
TI03=TyMzXsize-1;
TI02=random(0)(TI03);    # pick random cell (row,col)
TI03=TI01*TyMzXsize;
TI03+=TI02;              # random cell index
TyMzVisited[TI03]=16;    # 16 is visited but no directions
TyMzYset[0]=TI01;        # add to mazeCollection
TyMzXset[0]=TI02;        # add to mazeCollection
TyMzSizeSet=1;           # now in collection

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyMzGenerateBegin::TyabBusy=0;   # assume we finish
TyMzSL03=50;                     # max number of loops in generate
TyMzGenerate;                    # build maze
((TyMzSizeSet>0))TyabBusy=1;     # set that we need continue

# each maze cell is either 2x2, 3x3, 4x4 map tiles.

TyMzInit::TyMzMapScale=TyMzSPI02;
TyMzfMap2Cell=1.0//TyMzMapScale;
TI01=TyMzSPY2-TyMzSPY1;
TI01+=1;          #height
TI01+=TyMzMapScale;
TI01-=1;          #allow final cell on bottom even if partially clipped
TF01=TI01;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzYsize=TF01;   # cell height
TI01=TyMzSPX2-TyMzSPX1;
TI01+=1;          #width
TI01+=TyMzMapScale;
TI01-=1;          #allow final cell on right even if partially clipped
TF01=TI01;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    #round off error
TyMzXsize=TF01;   # cell width

#### maze generation engine. Loop while anything in collection On entry we have something

TyMzGenerate::TI04=TyMzSizeSet-1;
((random(0)(1)==0))TI04=random(0)(TI04);    # get either random cell or last one 50/50 oods
TI02=TyMzYset[TI04];     # row
TI03=TyMzXset[TI04];     # col
TyMzSizeNeighbors=0;    # start off with no neighbors
TI05=1;      # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
((TI06>=0))TyMzBNChkDirVis; #not outside, see its been visited
TI05=2;      # check south
TI06=TI02+1;        #row of neighbor
    #TI07=TI03;          #col of neighbor
((TI06<TyMzYsize))TyMzBNChkDirVis; #not outside, see its been visited
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
((TI07<TyMzXsize))TyMzBNChkDirVis; #not outside, see its been visited
TI05=4;      # check west
    #TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
((TI07>=0))TyMzBNChkDirVis; #not outside, see its been visited
((TyMzSizeNeighbors>0))[TyMz05CP2N][TyMz06RemoveCell];
TyMzSL03-=1;                   #have to keep track of iterations to avoid script limits
((TyMzSizeSet<=0))return;      # collection is empty so exit
((TyMzSL03>0))TyMzGenerate;    #loop until we are done or must stop

###### remove cell from collection
#input
#  TI04: collection index of cell to remove

TyMz06RemoveCell::TyMzSizeSet-=1;       # removing the last one by copying the last one to where cell to remove is.
TyMzYset[TI04]=TyMzYset[TyMzSizeSet];   # move last to our position
TyMzXset[TI04]=TyMzXset[TyMzSizeSet];   # move last to our position

# TI05=dir (1-4) TI06=row, TI07=col neighbor. 

TyMzBNChkDirVis::TI08=TI06*TyMzXsize;
TI08+=TI07;                 #index of neighbor
TI01=TyMzVisited[TI08];
TyMzNeighbors[TyMzSizeNeighbors]=TI05;  #assume we will add it
((TI01==0))TyMzSizeNeighbors+=1;       # and add for real if its not already processed

### we have some unvisisted neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell with direction to neighbor, and set neighbor direction back to us. Both cells are thus made visited.
# TI02, TI03: cell row,col:  TI04 collection index of cell

TyMz05CP2N::TI01=TyMzSizeNeighbors-1;
TI05=TyMzNeighbors[random(0)(TI01)];     # get direction we picked
    # set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TI01=TyMzVisited[TI06];       #cell valid directions
((TI01==16))TI01=0;           #first time init, clear so no directions
TyMzVisited[TI06]=TI01+TyMzDir2Bit[TI05];       #direction added
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]+=TyMzDirB2Bit[TI05];       #neighbor dir back to cell

##### debug out of maze directions

#TyMzDBGDirs::TS01="";
    #TI02=0;
    #TyMzDBGDirsO;
    #msg:TS01;


#TyMzDBGDirsO::TI03=0;
    #TyMzDBGDirsI;
    #TI02+=1;
    #((TI02>0))TyMzDBGDirsO;


#TyMzDBGDirsI::TyMzDBGDirsCell;
    #TI03+=1;
    #((TI03>0))TyMzDBGDirsI;

#input TI02: row, TI03: col

#TyMzDBGDirsCell::TI04=TI02*TyMzXsize;
    #TI04+=TI03;
    #TI01=TyMzVisited[TI04];
    #TS01+="[";
    #TS01+=TI04;
    #TS01+=":";
    #TS01+=TyMzDirN[TI01];  #N
    #TS01+=" ";
    #TS01+=TyMzDirS[TI01];  #S
    #TS01+=" ";
    #TS01+=TyMzDirE[TI01];  #E
    #TS01+=" ";
    #TS01+=TyMzDirW[TI01];  #W
    #TS01+="] ";

# modifying the map to include the maze. All of the passed in values are still available.
# note: Since map is filled in from UL towards LR, the left side (west) and top side(north) cells will be against
#       the border allowing easy connections to rest of map. But right side (east) and bottom (south) may not
#       be on the border (if maze is smaller than tiles, it may not align perfectly).
#       Thus we always extend paths east from east most cells and south for south most cells to the maze boundary.

TyMzUpdateMap::((TyabBusy==0))TyMzDrawInit;   # first time, start on first row
TI01=TyMzVisited[0];
((TI01==16))TyMzVisited[0]=0;     # single cell maze case
TyabBusy=0; #assume we finish
TyMzSL10=50;    #we will stop on next row after this many cells
TyMz19MMRL;
((TyMzSL01<TyMzYsize))TyabBusy=2;  # we are not done drawing

TyMzDrawInit::TyMzSL01=0;   #start on first row

TyMz19MMRL::TyMzSL02=0;          #col
TyMz20MMCL;
TyMzSL01+=1;
TI01=1;
((TyMzSL10<=0))TI01=0;
((TyMzSL01>=TyMzYsize))TI01=0;
((TI01==1))TyMz19MMRL;


# every cell in the maze column

TyMz20MMCL::TyMzSL10-=1;    #doing a cell - count for too many
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;                       # get maze cell index
TI03=TyMzSL01*TyMzMapScale;
TI03+=TyMzSPY1;                       # map row for this cell
TI04=TyMzSL02*TyMzMapScale;
TI04+=TyMzSPX1;
    #inline TyMzFillCell
    # TyMzSL01, TyMzSL02, cell row, TI02: cell index,  TI03, TI04. map row,col
    #every cell has UL, the cell itself path UR is either wall or path. LL is wall or path, LR is wall. Some areas are null depending on cell size and path size
TI01=TyMzVisited[TI02]; # get directions
RI02=TyMzDirS[TI01];    # do we go south
RI03=TyMzDirE[TI01];    # do we go east
    # first do the UL cell - its a path
TI09=1;             # path
TyMzSL05=0;              #starting row,col offset values
TyMzSL06=TyMzSPI01;           # path size
TyMzSL07=TyMzSPI01;
    #inline TyMzFillRect
TyMzSL08=0;              # row offset
TyMzFRRL;           #start Y loops
    #end TyMzFillRect
    #now look at UR, either path or wall
TyMzSL05=TyMzSPI01;           # now on UR subsection
TyMzSL06=TyMzSPI01;
TyMzSL07=TyMzMapScale;
TI09=RI03;           # either path or wall going east
TI01=TyMzXsize-1;
((TyMzSL02>=TI01))TI09=1;    #if right most col, we path to the east to connect to map
    #inline TyMzFillRect
TyMzSL08=0;              #row offset
TyMzFRRL;           #start Y loops
    #end TyMzFillRect
    #now look at LL, either path or wall
TyMzSL05=0;
TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzSPI01;
TI09=RI02;             # either path or wall going south
TI01=TyMzYsize-1;
((TyMzSL01>=TI01))TI09=1;    #if bottom most row we path to the south to connect to map
    #inline TyMzFillRect
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzSL06))TI01=0;           #outside
((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
((TI01==1))TyMzFRRL;           #start Y loops
    #end TyMzFillRect
    #final is LR which is wall
TyMzSL05=TyMzSPI01;
    #TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzMapScale;
TI09=0;    #wall
    #inline TyMzFillRect
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzSL06))TI01=0;           #outside
((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
((TI01==1))TyMzFRRL;           #start Y loops
    #end TyMzFillRect
    #endif TyMzFillCell
TyMzSL02+=1;
((TyMzSL02<TyMzXsize))TyMz20MMCL;     # all maze columns for this row

# fill in cell starting at TI03,TI04. using offset range [L04,TyMzSL05] -> (TyMzSL06,TyMzSL07). Clamp to cell size.
# if TI09=1, get random tile, else use PI04.
# deal with clipping and even if nothing to do

#TyMzFillRect::;  
    #TyMzSL08=L04;
    #TI01=1;   #assume ok to y loop
    #((TyMzSL08>=TyMzSL06))TI01=0;           #outside
    #((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
    #((TI01==1))TyMzFRRL;           #start Y loops

TyMzFRRL::TyMzSL09=TyMzSL05;               # starting col offset
TI05=TI03+TyMzSL08;          #tile row
TI01=1;                # assume ok to run columns
((TyMzSL09>=TyMzSL07))TI01=0;         # outside
((TyMzSL09>=TyMzMapScale))TI01=0; # outside
((TI05>TyMzSPY2))TI01=0;           #row outside
((TI01==1))TyMzFRRC;          # inside on Row, process columns
TyMzSL08+=1;
((TyMzSL08>=TyMzSL06))return;      #outside
((TyMzSL08<TyMzMapScale))TyMzFRRL;   # keep looping while inside

TyMzFRRC::((TI09>0))[TyProbTile][RI01=TyMzSPI03];   #either path or wall tile
TI06=TI04+TyMzSL09;          #tile col
TI01=TI05-TynY1;
TI01*=TynXtiles;
TI01+=TI06;
TI01-=TynX1;              # compute index
((TI06<=TyMzSPX2))TyMapTiles[TI01]=RI01;   #draw if col is within range
TyMzSL09+=1;
((TyMzSL09>=TyMzSL07))return;       #outside
((TyMzSL09<TyMzMapScale))TyMzFRRC;  #keep looping while not outside

### convert map row, col to the maze call row, col
#input
#  TI02 map row
#  TI03 map col
#output
#  TI02 maze cell row
#  TI03 maze cell col

#TyMzMap2Cell::TI01=TI02-TyMzSPY1;          # map offset to range Corner
    #TF01=TI01;
    #TF01*=TyMzfMap2Cell;
    #TF01+=0.00001;    # round off error
    #TI02=TF01;
    #TI01=TI03-TyMzSPX1;          # map offset to range Corner
    #TF01=TI01;
    #TF01*=TyMzfMap2Cell;
    #TF01+=0.00001;    # round off error
    #TI03=TF01;

#.############################ TyabPath ##################
# generates a random path. Between the two points. Is constrained by the provided rectangle.
# internally we are generating a maze. We run the recursive backtracker from the start point
# and it builds internally the maze visited bits just like a maze but the key is - we exit
# the generation phase once we hit the destination cell. The path is then cells in the collection.
# start and end do not need to be on the border generating an island maze. You may also include
# obstructions to stay away from. It is caller responsiblity to ensure that obstructions do not
# block a valid path , make sure to take into account PI02 cell size.
# TODO - add in cells as obstacles to go around!
# TODO - do we fill-in around the path or just make it in an existing area
#input:
# PX1, PY1    upper left starting bounding region
# PX2, PY2    lower right Ending bounding region
# PX3, PY3    starting point of path
# PX4, PY4    ending point of path
# PI01        size of path (1,2) must be smaller than PI02
# PI02        cell size (1,2,3,4)
# PI04        number of entries in IAP01
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01
#                    The sum of all of the odds should be 0-1000. If under 1000, tDirt will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.
# PI05        number of obstructions
# PIA03
# PIA04.      Each is a row, col (PIA03[i],PIA04[i]) in map coords of an obstruction to not generate a path through

# command queue entry
TyIPath::TyabBusy=0;    # should not be needed but ensures starting a new one
TyabIPath;

# TyabTimer entry
TyabIPath::((TyabBusy==0))[TyRp0][TyRpContinue34];  #start new or continue

# convert PX3, PY3 to starting cell row,col saved as first in collection
# convert PX4, PY4 to starting cell row,col in PY6, PX6
# - starting a new random path
TyRp0::TyMzSaveVars;   # copy input, use own vars
TyMzStartNew;   # init maze stuff since we use it
TyRpStartNew;
TyRpGenerateBegin;  # run the maze engine, build visible and directions
((TyabBusy==0))TyRpUpdateMap;   # if we are finished, draw it


TyRpStartNew::;
    #inline TyMzMap2Cell
TF01=TyMzSPY3-TyMzSPY1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzYset[0]=TF01;      # start path from start point
TF01=TyMzSPX3-TyMzSPX1;          # map offset to range Corner
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzXset[0]=TF01;     #start path from start point
    #end inline TyMzMap2Cell
    #inline TyMzMap2Cell
TF01=TyMzSPY4-TyMzSPY1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzSPY6=TF01;
TF01=TyMzSPX4-TyMzSPX1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzSPX6=TF01;
    #end inline TyMzMap2Cell
TyMzSizeSet=1;  # preloading the start cell. Visited is set to 0 via init
((TyMzSPI05>0))TyRpObstructions;   # fill in obstructions as already visited cells.


TyRpObstructions::TyMzSL01=0;
TyRpLObstruct;


TyRpLObstruct::TF01=PIA03[TyMzSL01]-TyMzSPY1;   # map row
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TI02=TF01;        # cell row
TF01=PIA04[TyMzSL01]-TyMzSPX1;   # map col
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TI03=TF01;        # now row,col in maze coords
TI01=1;                     #assume in range
((TI02<0))TI01=0;           # outside
((TI02>=TyMzYsize))TI01=0;  # outside
((TI03<0))TI01=0;           # outside
((TI03>=TyMzXsize))TI01=0;  # outside
((TI01==1))TyRpLObstructAdd;  #add if in range
TyMzSL01+=1;
((TyMzSL01<TyMzSPI05))TyRpLObstruct;

TyRpLObstructAdd::TI01=TI02*TyMzXsize;
TI01+=TI03;
TyMzVisited[TI01]=TyNeg1;  # -1 means already visited (ok to use -1 in this case since they are excluded from path)

# - calling with either state 3 = generation, or 4 = drawing
TyRpContinue34::((TyabBusy==3))[TyRpBusy3][TyRpBusy4];

# - continuing to generate. 
TyRpBusy3::TyRpGenerateBegin;
((TyabBusy==0))TyabBusy=4;   # finished generation, move to drawing
((TyabBusy==4))TyRpDrawInit;  # starting draw, just do init, next time we draw

# - continue with drawing
TyRpBusy4::((TyabBusy==4))TyRpUpdateMap;

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyRpGenerateBegin::TyMzSRI05=0;                 # solution not found
TyMzSL03=50;               # max number of loops in generate
TI04=TyMzSizeSet-1;    # get the last cell (using backtracker)
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TI01=0;                # assume solution found
((TI02!=TyMzSPY6))TI01=1;
((TI03!=TyMzSPX6))TI01=1;   #check to see if start == end
TyabBusy=0;     # assume we finish
((TI01==1))TyRpGenerate;  # not, find path, else found it
((TyMzSRI05==0))TyabBusy=3; # set that we need continue

#### path generation engine. Loop until we hit the end point
# on entry at every loop. 
# TI02 cell row
# TI03 cell col

TyRpGenerate::TyMzSizeNeighbors=0;   # start off with no neighbors
TI05=1;         # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
((TI06>=0))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=2;     # check south
TI06=TI02+1;        #row of neighbor
    #TI07=TI03;          #col of neighbor
((TI06<TyMzYsize))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
((TI07<TyMzXsize))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=4;     # check west
    #TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
((TI07>=0))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
((TyMzSizeNeighbors>0))[TyRpPickNext][TyMzSizeSet-=1];   # process neighbor or remove this cell
TI04=TyMzSizeSet-1;    # get the last cell
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TyMzSRI05=1;                # assume solution found
((TI02!=TyMzSPY6))TyMzSRI05=0;
((TI03!=TyMzSPX6))TyMzSRI05=0;   #check to see if start == end
((TyMzSRI05==1))return;      #found solution, need to exit
TyMzSL03-=1;                #have to keep track of iterations to avoid script limits
((TyMzSL03>0))TyRpGenerate;    #loop until we are done or must stop

### we have some unvisited neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell only with the direction bit we are going. Set neighbor as the maze does
# TI02, TI03: cell row,col:  TI04 collection index of cell

TyRpPickNext::TI01=TyMzSizeNeighbors-1;
TI01=random(0)(TI01);         # pick a random neighbor
TI05=TyMzNeighbors[TI01];     # get direction we picked
    # set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TyMzVisited[TI06]=TyMzDir2Bit[TI05];       #direction added
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]=TyMzDirB2Bit[TI05];       #back direction

# - get ready to draw from beginning
TyRpDrawInit::TI03=TyMzSizeSet-1;
TyMzSL01=TyMzYset[TI03];   #last cell if on bottom or right needs connecting paths to map
TyMzSL02=TyMzXset[TI03];
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI01=0;
TI03=TyMzYsize-1;
((TyMzSL01==TI03))TyMzVisited[TI02]+=2;   # last cell on bottom, needs path south
TI04=TyMzXsize-1;
((TyMzSL02==TI04))TyMzVisited[TI02]+=4;   # last cell on bottom, needs path east
    #first cell if on bottom or right needs connecting paths to map
TyMzSL01=TyMzYset[0];
TyMzSL02=TyMzXset[0];
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI01=0;
TI03=TyMzYsize-1;
TyMzSRI05=0;                 #will have last direction from prior cell so we can make back paths
TyMzSRI06=0;
((TyMzSL01==TI03))TyMzSRI05=1;   # first cell on bottom, needs path south
((TyMzSPI01==TyMzSPI02))TyMzSRI05=0;  # if path size == cell size, we don't need any directions
TI04=TyMzXsize-1;
((TyMzSL02==TI04))TyMzSRI06=1;   # first cell on bottom, needs path east
((TyMzSPI01==TyMzSPI02))TyMzSRI06=0;  # if path size == cell size, we don't need any directions
TyMzSL03=0;          # collection index

# we have the path, it is in the collection. For each step, the visited gives direction to next one.

TyRpUpdateMap::((TyabBusy==0))TyRpDrawInit;
TyMzSL10=100;       #number of cells to draw
TyRp20MMCL;    # start/restart drawing

# TyMzSL03 loops for every cell in the collection. TyMzSRI05 if S path needed, TyMzSRI06 if east path needed

TyRp20MMCL::TyMzSL01=TyMzYset[TyMzSL03];     # row
TyMzSL02=TyMzXset[TyMzSL03];     # cell
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI03=TyMzSL01*TyMzMapScale;
TI03+=TyMzSPY1;             #map row
TI04=TyMzSL02*TyMzMapScale;
TI04+=TyMzSPX1;             # map col
TI01=TyMzVisited[TI02]; # get direction to fill
((TyMzSPI01==TyMzSPI02))TI01=0;  # if path size == cell size, we don't need any directions
RI01=TyMzDirN[TI01];
RI02=TyMzDirS[TI01];
RI03=TyMzDirE[TI01];
RI04=TyMzDirW[TI01];
RI02+=TyMzSRI05;             # add in possible S backtrack path
RI03+=TyMzSRI06;             # add in possible E backtrack path
((RI01>0))[TyMzSRI05=1][TyMzSRI05=0];      # we are going north, next cell needs a path south
((RI04>0))[TyMzSRI06=1][TyMzSRI06=0];      # we are going west, next cell needs path east
    # TyMzSL01, TyMzSL02, cell row, TI02: cell index,  TI03, TI04. map row,col
    #every cell has UL, the cell itself path UR is either wall or path. LL is wall or path, LR is wall. Some areas are null depending on cell size and path size
    # first do the UL cell - its a path
TI09=1;             # path
TyMzSL05=0;              # starting row,col offset values
TyMzSL06=TyMzSPI01;           # path size
TyMzSL07=TyMzSPI01;
TyMzSL08=0;              # row offset
TyMzFRRL;           # start Y loops
    #see if we need a path east
    #TI09=1;             #path 
TyMzSL05=TyMzSPI01;           # now on UR subsection
TyMzSL06=TyMzSPI01;
TyMzSL07=TyMzMapScale;
TyMzSL08=0;              #row offset
((RI03>0))TyMzFRRL;       #start Y loops
    #see if we need a path S
    #TI09=1;             #path 
TyMzSL05=0;
TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzSPI01;
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzMapScale))TI01=0;   #outside
((RI02==0))TI01=0;
((TI01==1))TyMzFRRL;           #start Y loops
TyMzSL03+=1;
TI01=1;   #assume not done
((TyMzSL03>=TyMzSizeSet))TI01=0;   #stop
TyMzSL10-=1;
((TyMzSL10<=0))TI01=0;
((TI01==1))TyRp20MMCL;     # keep going
((TyMzSL03>=TyMzSizeSet))[TyabBusy=0][TyabBusy=4];  # either done or need another call

#.############################ TyabTightPath ##################
# generates a random path. Between the two points. Is constrained by the provided rectangle.
# internally use the same type of logic as the path method, but we have more complex
# rules defining what direction we can go and we are fixed to a cell and path sizes of 1.
# This results in variable sized cells, so we are no longer generating maze.
# from the start point random directions are chosen and the path grows until we get
# near the destination. Once near the destination, we suck in the path to the destination based on
# fixed rules. If a dead end is hit, we back up forgetting those cells so they can be used again.
# Thus the path can whip around randomly until we get lucky to be near the destination.
# there are checks to try and detect paths that backtrack with no way to get out to help it
# find a solution sooner.
# because we are not making an internal maze, processing time is random and it can take some time.
# Once the destination is found, the path is the cells in the collection.
# start and end do not need to be on the border generating an island maze. You may also include
# obstructions to stay away from. It is caller responsiblity to ensure that obstructions do not
# block a valid path.
#input:
# PX1, PY1    upper left starting bounding region
# PX2, PY2    lower right Ending bounding region
# PX3, PY3    starting point of path
# PX4, PY4    ending point of path
# PI04        number of entries in IAP01
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01
#                    The sum of all of the odds should be 0-1000. If under 1000, tDirt will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.
# PI05        number of obstructions
# PIA03
# PIA04.      Each is a row, col (PIA03[i],PIA04[i]) in map coords of an obstruction to not generate a path through

#command queue entry
TyITightPath::TyabBusy=0;
TyabITightPath;

#TyabTimer entry
TyabITightPath::((TyabBusy==0))[TyTp0][TyTpContinue5];  #start new or continue

# convert PX3, PY3 to starting cell row,col saved as first in collection
# convert PX4, PY4 to starting cell row,col in PY6, PX6
# - starting a new random path
TyTp0::TyMzSaveVars;   # save input vars, use own vars
TyMzSPI01=1;  # force to 1 path width
TyMzSPI02=1;  # force to 1 cell size
TyMzStartNew;   # init maze stuff since we use it
TyRpStartNew;      # same init as path
TyTpGenerateBegin;  # run the maze engine, build visible and directions
((TyabBusy==0))TyTpDraw;   # if we are finished, draw it

# - calling with state 5
TyTpContinue5::((TyabBusy==5))TyTpBusy5;

# - continuing to generate. 
TyTpBusy5::TyTpGenerateBegin;
((TyabBusy==0))TyTpDraw;   # finished generation, move to drawing - using path draw

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyTpGenerateBegin::TyMzSL03=50; # max number of loops in generate
TI04=TyMzSizeSet-1;    # get the last cell (using backtracker)
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TI01=0;                # assume solution found
((TI02!=TyMzSPY6))TI01=1;
((TI03!=TyMzSPX6))TI01=1;   #check to see if start == end
TyabBusy=0;     # assume we finish
TyMzSRI05=1;         # assume finish
((TI01==1))TyTpGenerate;  # not, find path, else found it
((TyMzSRI05==0))TyabBusy=5; # set that we need continue


#for tight path, we are tracking in TyMzVisited the dirs we have tried so far
#### path generation engine. Loop until we hit the end point
# on entry at every loop. 
# TI02 cell row
# TI03 cell col

TyTpGenerate::TI04=TI02*TyMzXsize;
TI04+=TI03;         # cell index
TyMzSizeNeighbors=0;   # start off with no neighbors
TI05=1;         # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
TI04=TyMzVisited[TI04];  # bits we have tried (also has back connection so we don't try that dir)
TI01=TyMzDirN[TI04]; # if non-zero we have tried this dir
((TI06<0))TI01=1;    # outside
((TI01==0))TyTpChkDirVis; #north not outside and north has not been already tried
TI05=2;     # check south
TI06=TI02+1;        #row of neighbor
    #TI07=TI03;          #col of neighbor
TI01=TyMzDirS[TI04]; # if non-zero we have gone this dir
((TI06>=TyMzYsize))TI01=1; #outside
((TI01==0))TyTpChkDirVis; #south not outside and south has not been already tried
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
TI01=TyMzDirE[TI04]; # if non-zero we have gone this dir
((TI07>=TyMzXsize))TI01=1; #outside
((TI01==0))TyTpChkDirVis; #east not outside and east has not been already tried
TI05=4;     # check west
    #TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
TI01=TyMzDirW[TI04]; # if non-zero we have gone this dir
((TI07<0))TI01=1;   #outside
((TI01==0))TyTpChkDirVis; #west not outside and west has not been already tried
((TyMzSizeNeighbors>0))[TyTpPickNext][TyTpRemoveCell];   # process neighbor or remove this cell
TI04=TyMzSizeSet-1;    # get the last cell
((TI04<0))TI04=0;      #don't crash if we run out of cells
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TyTpDestAttract;       # are we withing the 5x5 grid of destination (or at dest)
((TyMzSizeSet<=0))TyMzSRI05=1;   #abort, we have run out of cells (solution never found)
((TyMzSRI05==1))return;          #found solution, need to exit
TyMzSL03-=1;                     #have to keep track of iterations to avoid script limits
((TyMzSL03>0))TyTpGenerate;    #loop until we are done or must stop

#destination will draw in if within 2 cells
#TI02,TI03 current cell
#TyMzSRI05 0=not drawn in or not at dest. =1 draw in.

TyTpDestAttract::TyMzSRI05=0;
TI04=TI02-TyMzSPY6;
TI04+=2;     # scale 0-4 if in range
TI05=TI03-TyMzSPX6;
TI05+=2;     # scale 0-4 if in range
((TI04<0))return;
((TI04>4))return;
((TI05<0))return;
((TI05>4))return;
TyMzSRI05=1;  # have solution
TyTpAtDest;


#TI04,TI05 now define a 5x5 array of positions with the dest in the center
#no checks for obstructions
TyTpAtDest::TI06=TI04*5;
TI06+=TI05;
((TI06!=12))TyTpMove2Dest;  # loop until we hit dest

TyTpMove2Dest::TI01=TyTpDDir[TI06];    #get movment dir
TI02+=TyMzDirYInc[TI01];
TI03+=TyMzDirXInc[TI01];
TyMzYset[TyMzSizeSet]=TI02;
TyMzXset[TyMzSizeSet]=TI03;
TyMzSizeSet+=1;     # note we don't have to set any visited bits for tight path draw
TI04+=TyMzDirYInc[TI01];
TI05+=TyMzDirXInc[TI01];
TyTpAtDest;

#tight path when we remove a cell since this path ran into a dead end, we must forget its connections
# since the maze is now changing, it may go back far enough so that cell is no longer a dead end.
# we remove multiple cells once we have more than 20 in length to get out faster. TODO do we need to make this configurable?

TyTpRemoveCell::((TyMzSizeSet>20))[TyTpRemoveMore][TyTpRemoveOne];

TyTpRemoveOne::;
TI01=TyMzSizeSet-1;
TI04=TyMzYset[TI01]*TyMzXsize;
TI04+=TyMzXset[TI01];
TyMzVisited[TI04]=0;   #forget that cells connections since maze is changing
TyMzSizeSet-=1;        #remove cell
    #TI02=TyMzYset[TI01]+TyMzSPY1;   #debug
    #TI03=TyMzXset[TI01]+TyMzSPX1;   #debug
    #place:TI02,TI03,$(tGround);   #debug

TyTpRemoveMore::TF01=TyMzSizeSet;
TF01*=0.2;              # going back 1/5 of the way. TODO do we need to make this configurable?
TI05=TF01;
TyTpRemoveMoreL;

TyTpRemoveMoreL::TyTpRemoveOne;
TI05-=1;
((TI05>0))TyTpRemoveMoreL;

# tight path has far more complex logic to see if a direction is viable. Here are the rules:
# must not be out of range (already checked in the main loop)
# must not be in use (TyMzVisited entry is 0) same as path/maze
# new for tight path:
#   In same direction 2 cells must be free or wall/obstruction
#   In both 90's, 2 cells must be free or wall/obstruction
#   if backtracking, one of the two 90's must also be free and inside for 3rd cell.
#   diagonals cannot be visited unless they are cell-2 (zigzag path)  TODO
#   2nd diagonals cannot be visited
# do not change TI02, TI03, TI04, TI05, TI06, TI07

TyTpChkDirVis::TI01=TI06*TyMzXsize;
TI01+=TI07;                 #index of neighbor
((TyMzVisited[TI01]==0))TyTpUnVisted;

# next cell same dir must also be open or obstruction if still in range

TyTpUnVisted::TI08=TI05;      # same dir, check two cells
TI01=1;                   # assume not valid
TyTpChkDirection;
TI08=TyTpBack1[TI05];     #get one of the 90's
((TI01==1))TyTpChkDirection;
TI08=TyTpBack2[TI05];     #get other 90's
((TI01==1))TyTpChkDirection;
    #now we check the diagonals. We do allow cell-2 to be on a diagonal for zigzag
TI08=5;     # North west
((TI01==1))TyTpChkDDirection;
TI08=6;     # South West
((TI01==1))TyTpChkDDirection;
TI08=7;     # South East
((TI01==1))TyTpChkDDirection;
TI08=8;     # North East
((TI01==1))TyTpChkDDirection;
TyMzNeighbors[TyMzSizeNeighbors]=TI05;  # in case we add
((TI01==1))TyMzSizeNeighbors+=1;  #TyTpChkBacktrack;  #TODO backtracking checks not done, are they really necessary and does it prevent some interesting paths? Its alot of code so it has to be worth it

#neighbor cell in TI06,TI07. TI08 is dir to check. Two cells from this cell must be unvisited or wall/obstruction
#return TI01=0 visited. 1 = wall/obstruction/unvisted

TyTpChkDirection::TI09=TI06+TyMzDirYInc[TI08];
TI10=TI07+TyMzDirXInc[TI08];
TyTpChkWallObstruct;
TI09+=TyMzDirYInc[TI08];
TI10+=TyMzDirXInc[TI08];
((TI01==1))TyTpChkWallObstruct;

# return TI01 = 0 visited. TI01=unvisited or wall or obstruction. TI09,TI10 cell

TyTpChkWallObstruct::((TI09<0))return;
((TI09>=TyMzYsize))return;
((TI10<0))return;
((TI10<TyMzXsize))TyTpChkWOInside;    # cell is inside


TyTpChkWOInside::TI01=TI09*TyMzXsize;
TI01+=TI10;
((TyMzVisited[TI01]<=0))[TI01=1][TI01=0];

# diagonal check. We do allow cell-2 to be on the diagonal for zigzag path

#return TI01=0 visited. 1 = wall/obstruction/unvisted
TyTpChkDDirection::TI09=TI06+TyMzDirYInc[TI08];
TI10=TI07+TyMzDirXInc[TI08];
TI11=TyMzSizeSet-2;    # this is the 2nd prior cell
((TI11<0))[TyTpChkWallObstruct][TyTpDiag1];

# see if 2nd prior cell is the corner, if so, its good.
TyTpDiag1::((TI09==TyMzYset[TI11]))return;
((TI10!=TyMzXset[TI11]))TyTpChkWallObstruct;  # 2nd prior cell is not this corner, continue normal tests


#TODO I need to rethink backtracking - what does it really mean?
# determine if backtracking, if not add the cell. If so, one of the 90's must be open and inside for 3 cells (have to have a way to get back out)

#TyTpChBacktrack::TI08=TyMzSPY6-TI06;          # row distance for neighbor
    #((TI08<0))TI08=0-TI08;  # abs
    #TI09=TyMzSPY6-TI02;          # row distance for cell
    #((TI09<0))TI09=0-TI09;  # abs
    #TI01=0;
    #((TI08>TI09))TI01=1;    # neighbor is farther away in row - we are backtracking
    #TI08=TyMzSPX6-TI07;          # col distance for neighbor
    #((TI08<0))TI08=0-TI08;  # abs
    #TI09=TyMzSPY6-TI03;          # col distance for cell 
    #((TI09<0))TI09=0-TI09;  # abs
    #((TI08>TI09))TI01=1;    # neighbor is farther away in col - we are backtracking
    #TyMzNeighbors[TyMzSizeNeighbors]=TI05;  # in case we add
    #((TI01==1))[TyTpBackTRK][TyMzSizeNeighbors+=1];  # we are doing a backtrack if not, add this direction

#TyTpBackTRK::TI08=TyTpBack1[TI05];   # first back dir
    #TyMzCheckBack;
    #TI08=TyTpBack2[TI05];
    #((TI01==0))TyTpCheckBack;   # try the other dir
    #((TI01==1))TyMzSizeNeighbors+=1;  # one of the backtrack tests passes, add the direction

#TyTpN1Inside::TI10=TI08*TyMzXSize;
    #TI10+=TI09;
    #((TyMzVisited[TI10]<=0))TyTpN1Inside1;  # not visited or obstruction ok

#TyTpN1Inside1::((TyMzVisited[TI10]<0))[TyTpChBacktrack][TyTpN1Inside2];  #obstruction good, else check next following

#TyTpN1Inside2::TI08+=TyMzDirYInc[TI05];
    #TI09+=TyMzDirXInc[TI05];    # row,col of the 2nd following
    #TI01=1;
    #((TI08<0))TI01=0;
    #((TI08>=TyMzYsize))TI01=0;
    #((TI09<0))TI01=0;
    #((TI09>=TyMzXsize))TI01=0;
    #((TI01==1))[TyTpN2Inside][TyTpChBacktrack];  # inside check visited, outside now move to backtrack check

#TyTpN2Inside::TI10=TI08*TyMzXSize;
    #TI10+=TI09;
    #((TyMzVisited[TI10]<=0))TyTpChBacktrack;  # not visited or obstruction ok

#go three in the 90 direction, final one must be inside. All must be unvisited
#TI08 is the dir to go (1-4)
#return TI01 0 = reject, 1 = ok.

#TyTpCheckBack::TI09=TI06+TyMzDirYInc[TI08];
    #TI10=TI07+TyMzDirXInc[TI08];    #TI09,TI10  +1 90
    #TI11=TI09+TyMzDirYInc[TI08];
    #TI12=TI10+TyMzDirXInc[TI08];    #TI11,TI12  +2 90
    #TI13=TI11+TyMzDirYInc[TI08];
    #TI14=TI12+TyMzDirXInc[TI08];    #TI13,TI14  +3 90
    #TI01=1;
    #((TI13<0))TI01=0;
    #((TI13>=TyMzYsize))TI01=0;
    #((TI14<0))TI01=0;
    #((TI14>=TyMzXsize))TI01=0;
    #((TI01==1))TyTpBack3VisChk;   # range inside check visited

#TyTpBack3VisChk::TI08=TI09*TyMzXsize;
    #TI08+=TI10;
    #((TyMzVisited[TI08]!=0))TI01=0;
    #TI08=TI11*TyMzXsize;
    #TI08+=TI12;
    #((TyMzVisited[TI08]!=0))TI01=0;
    #TI08=TI13*TyMzXsize;
    #TI08+=TI14;
    #((TyMzVisited[TI08]!=0))TI01=0;

### we have some unvisited neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell only with the direction bit we are going. Set neighbor as the maze does
# TI02, TI03: cell row,col:

TyTpPickNext::TI01=TyMzSizeNeighbors-1;
TI01=random(0)(TI01);         # pick a random neighbor
TI05=TyMzNeighbors[TI01];     # get direction we picked
    # set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TyMzVisited[TI06]+=TyMzDir2Bit[TI05];       #direction added, remember so we only try a dir once
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]=TyMzDirB2Bit[TI05];       #back direction
    #TI06+=TyMzSPY1;   #debug
    #TI07+=TyMzSPX1;   #debug
    #place:TI06,TI07,$(tErosion1);   #debug

TyTpDraw::TyMzSL03=0;
TyTpDrawLoop;
TyabBusy=0;

TyTpDrawLoop::TyProbTile;
TI02=TyMzYset[TyMzSL03]+TyMzSPY1;
TI03=TyMzXset[TyMzSL03]+TyMzSPX1;
TI01=TI02-TynY1;
TI01*=TynXtiles;
TI01+=TI03;
TI01-=TynX1;
TyMapTiles[TI01]=RI01;
TyMzSL03+=1;
((TyMzSL03<TyMzSizeSet))TyTpDrawLoop;

#.#################### TyabObstructAdd #####################################
# helper function to add all of the cells for a region to the obstruction list
# input:
#  PY1, PX1  Upper left corner of region
#  PY2, PX2  Lower right corner of region (inclusive) 
#  PI05 Current number of cells in the obstruction list.
#       First time, set to 0, don't touch on later calls
#  PIA03, PIA04   row,col for existing obstruction cells
# output:
#  PI05 Updated with number of cells in input region
#  PIA03, PIA04  row,col with new cells at end
TyabObstructAdd::L01=PY1;   #start row
TyObAddRL;

TyObAddRL::L02=PX1;     #start col
TyObAddCL;
L01+=1;                 #next col
((L01<=PY2))TyObAddRL;

TyObAddCL::PIA03[PI05]=L01;  #save row
PIA04[PI05]=L02;             #save col
PI05+=1;                #added entry
L02+=1;                 #next col
((L02<=PX2))TyObAddCL;

#.############################# TyabFlood ##################################

#storage for every region
intarray TyFlPY1
intarray TyFlPX1
intarray TyFlPX2
intarray TyFlPY2
intarray TyFlPI01
intarray TyFlPI02
intarray TyFlPI03
intarray TyFlPI05
intarray TyFlFIndex   # oldest cell in region (0 is empty)
intarray TyFlLIndex   # newest cell in region (0 is empty)

int TyFlNRegions=0   #number of regions
int TyFlRegNum=0     #region to process

# this is our grow only heap used by all regions, this allows any number of regions and we treat it like a single direction linked list
intarray TyFlRow
intarray TyFlCol
intarray TyFlTime
intarray TyFlNext     #index of next cell for this region (0 = end of list)
intarray TyFlDir      #N,S,E,W,NE,SE,SW,NW  N,S,E,W may only go that dir. 

int TyFlLLSize=0  #number of cells in linked list (so we know the end) Never shrinks unless all regions done (set back to 0)
int TyFlTNow=0    #time we are processing
intarray TyFlRndDir   # array used to mix up directions for more random growth
intarray TyFlDiag1    # map direction 1-4 to one of the diagonals that cover it
intarray TyFlDiag2    # map direction 1-4 to the other diagonal that covers it

#set heap to empty, no regions
TyFlInit::TyFlRow[0]=0;
TyFlCol[0]=0;
TyFlTime[0]=0;
TyFlNext[0]=0;
TyFlDir[0]=0;
TyFlLLSize=0;
TyFlNRegions=0;
TyFlRegNum=0;
    # setup diagonal mapping used to see if a cell will be covered by ray diagonal checks
TyFlDiag1[0]=0;     # not used
TyFlDiag2[0]=0;     # not used
TyFlDiag1[1]=5;     # N is covered by NE
TyFlDiag2[1]=8;     # N is covered by NW
TyFlDiag1[2]=6;     # S is covered by SE
TyFlDiag2[2]=7;     # S is covered by SW
TyFlDiag1[3]=5;     # E is covered by NE
TyFlDiag2[3]=6;     # E is covered by SE
TyFlDiag1[4]=7;     # W is covered by SW
TyFlDiag2[4]=8;     # W is covered by NW
TyFlDiag1[5]=1;     # NE goes N
TyFlDiag2[5]=3;     # NE goes E
TyFlDiag1[6]=2;     # SE goes S
TyFlDiag2[6]=3;     # SE goes E
TyFlDiag1[7]=2;     # SW goes S
TyFlDiag2[7]=4;     # SW goes W
TyFlDiag1[8]=1;     # NW goes N
TyFlDiag2[8]=4;     # NW goes W

# will flood a region from a start point over time.
# only walkable tiles will be flooded. The exception is the start point - it will ALWAYS be turned into a flood tile.
# flooding for a region stops when there are no more unflooded walkable tiles that are touching a flooded tile.
# the entire region will be processed. For a tile to become flooded, it must have one of its N,S,E,W neighbors flooded except for the start - it is always flooded.
# This means you can have safe area surrounded by walls that will not be flooded. If you have a flood tile inside that space, it will flood.
# if the map is modified while flooding is in progress, it does not try and pick up that modification.
# flood regions may be queued - so you can have multiple regions. To reduce processing try to have non-overlapping regions.
# all internal vars are saved so it is safe to call any routine after this. All updates happen from the TyabTimer calls.
# in our list they are sorted by ready to process time, front of list has oldest one, end of the list is newest.
# input.
#   on init, push the start cell into linked list for that region with its start time.
#   For the 8 neighbors, add them to link list with expected start time.The start cell is the only one that spawns 8 neighbors.
#   Diagonals are 2x later (since we can't grow diagonal). Tag each cell with direction. Direction for start cell is -1.
#   TimeSlice processing:
#       for regions in queue   (we now wrap around so we don't have to do any move to back type of operations)
#           while cells and allowed draws
#               Look at first cell (oldest)
#               If time has expired
#                   if walkable or dir==-1
#                       if (dir == -1) or are any N,S,E,W flooded
#                       Yes - convert to flood - draw.  +1 number of draws.
#                           For each N,S,E,W if walkable - add that neighbor with dir 0. This allows backtracking paths to flood
#                           (this may result in same cell being added multiple times due to scan below, but that is ok)
#                          
#                   remove from list (we still access its data)
#                   get dir.
#                   If -1 or 0 nothing (start cell or N,S,E,W added above)
#                   if N, S, E, W spawn neighbor (if in range) in that direction only.
#                   if NE, spawn N, E and NE in those directions if they are in range
#                   if SE, spawn S, E and SE in those directions if they are in range
#                   if SW, spawn S, W and SW in those directions if they are in range
#                   if NW, spawn N, W and NW in those directions if they are in range
#               else
#                   done with region (oldest is not ready for processing - move to next region)       
#           while end
#           if we did a draw
#              return RI03=1 
#       for end
#       if all regions are empty, clear everything out.
#
# for each time slice only do a single region. After a region has a draw, move to end of queue. If a region does not have a draw
# move to next region.

#  PY1, PX1  Upper left corner of region
#  PY2, PX2  Lower right corner of region
#  PY3, PX3  Start point for flooding
#  PI01      Tile to flood with.
#  PI02      min time to wait before flooding a cell (100 = 1 second)
#  PI03      max tiles to change in a draw call - should be kept low for best visual appearance 1-3
#  PI04      Delay start of region processing (100 = 1 second)
#  PI05      2 = fill mode (everything is turned to flood) 1 = use Rays to cross areas, 0 = walkable flood only

TyabFlood::;
TyFlPY1[TyFlNRegions]=PY1;
TyFlPX1[TyFlNRegions]=PX1;
TyFlPY2[TyFlNRegions]=PY2;
TyFlPX2[TyFlNRegions]=PX2;
TyFlPI01[TyFlNRegions]=PI01;
TyFlPI02[TyFlNRegions]=PI02;
TyFlPI03[TyFlNRegions]=PI03;
TyFlPI05[TyFlNRegions]=PI05;
    #add start cell
TF01=time;    # get current time
TF01*=100.0;  # we work in 1/100 of seconds
TF01+=0.5;    # round
TyFlTNow=TF01;    # current time
TyFlTNow+=PI04;   # add in start delay
TyFlLLSize+=1;  #this is index (we don't use index 0)
TyFlRow[TyFlLLSize]=PY3;
TyFlCol[TyFlLLSize]=PX3;
TyFlTime[TyFlLLSize]=TyFlTNow;  # time to process cell
TyFlNext[TyFlLLSize]=0;  # we are first cell
TyFlDir[TyFlLLSize]=TyNeg1;  # -1 is special for first cell
TyFlFIndex[TyFlNRegions]=TyFlLLSize;  # we are first
TyFlLIndex[TyFlNRegions]=TyFlLLSize;  # we are last
TyFlRegNum=TyFlNRegions;    # region
TyFlNRegions+=1;     # now we are in queue
((PI05>0))TyFlSetupRays;

# now add at the next cell time later to process its rays - put them in random order to mix up growths
TyFlSetupRays::TI03=TyFlLLSize;      # cell index
TI05=PY3;
TI06=PX3;
TyFlRndDir14;    # mix up 1-4 directions
TI07=TyFlRndDir[0];
TyFlAddNInRange;
TI07=TyFlRndDir[1];
TyFlAddNInRange;
TI07=TyFlRndDir[2];
TyFlAddNInRange;
TI07=TyFlRndDir[3];
TyFlAddNInRange;
TyFlRndDir58;    # mix up 5-8 directions
TI07=TyFlRndDir[4];
TyFlAddNInRange;
TI07=TyFlRndDir[5];
TyFlAddNInRange;
TI07=TyFlRndDir[6];
TyFlAddNInRange;
TI07=TyFlRndDir[7];
TyFlAddNInRange;

# mix up directions 1, 2, 3, 4 (N, S, E, W)
TyFlRndDir14::TyFlRndDir[0]=1;   # start off N, S, E, W
TyFlRndDir[1]=2;
TyFlRndDir[2]=3;
TyFlRndDir[3]=4;
TI10=random(0)(3);  # pick one to make first
TI11=TyFlRndDir[0];
TyFlRndDir[0]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(1)(3);  # pick one to make second
TI11=TyFlRndDir[1];
TyFlRndDir[1]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(2)(3);  # pick one to make third
TI11=TyFlRndDir[2];
TyFlRndDir[2]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;

# mix up directions 5, 6, 7, 8 (NE, SE, SW, NW)
TyFlRndDir58::TyFlRndDir[4]=5;   # start off NE, SE, SW, NW
TyFlRndDir[5]=6;
TyFlRndDir[6]=7;
TyFlRndDir[7]=8;
TI10=random(4)(7);  # pick one to make first
TI11=TyFlRndDir[4];
TyFlRndDir[4]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(5)(7);  # pick one to make second
TI11=TyFlRndDir[5];
TyFlRndDir[5]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(6)(7);  # pick one to make third
TI11=TyFlRndDir[6];
TyFlRndDir[6]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;

# force stop of all flooding
TyabFloodStop::TyFlInit;

TyFlRegionLInit::TF01=time;      # current time
TF01*=100.0;    # we work in 1/100 of seconds 
TF01+=0.5;      # round off
TyFlTNow=TF01;  # current time in int from scaled
L01=0;          # region count loop
L03=60;         # max number of cells to look at before we get out
TyabTimerDraw=0; # set to 1 if we did a draw. we exit after any region does a draw
RI02=0;         # assume all regions are empty, set to 1 if any region is not empty
TyFlRegionLoop;
((RI02==0))TyFlInit;  # all regions empty, so clear everything out

TyFlRegionLoop::((TyFlRegNum>=TyFlNRegions))TyFlRegNum=0;  #wrap around
TyFlBeginProcessRegion;
TyFlRegNum+=1;              # always move to next region - check for wrap around next time
TI01=TyabTimerDraw;   #0 nothing, 1=did draw
L01+=1;
((L01>=TyFlNRegions))TI01=1;
((L03<=0))TI01=1;      # only allow a limited number of cell visits
((TI01==0))TyFlRegionLoop;

# input
#   TyFlRegNum region index
# return
#   TyabTimerDraw 1= did a draw, 0 = no draw
TyFlBeginProcessRegion::L02=TyFlPI03[TyFlRegNum];      # number of draws allowed
TyFlProcessRegion;

# input
#   TyFlRegNum region index
# return
#   TyabTimerDraw 1= did a draw, 0 = no draw
#   RI02 1= not empty, 0 = empty
TyFlProcessRegion::TI03=TyFlFIndex[TyFlRegNum];   # first (oldest) cell index
((TI03>0))TyFlProcessCell;

#input TyFlRegNum region index, L02 number of draws remaining, TI03=cell index
TyFlProcessCell::RI02=1;         # region is not empty
((TyFlTNow>=TyFlTime[TI03]))TyFlCellTimeExpired;  # oldest cell is ready, else done with region

# this cell is ready for processing based on time.
#input TyFlRegNum region index, L02 number of draws remaining, TI03=cell index
TyFlCellTimeExpired::TI05=TyFlRow[TI03];
TI06=TyFlCol[TI03];
    #inline the following
    #iPY1=TI05;     #row
    #iPX1=TI06;     #col
    #iTyabGetTile;  #read single tile update map
TI02=TI05-TynY1;
TI02*=TynXtiles;
TI02+=TI06;
TI02-=TynX1;
iRI01=get(TI05)(TI06);
TyMapTiles[TI02]=iRI01;
    # end inline iTyabGetTile
TI01=TyWalkTile[iRI01];
((TyFlDir[TI03]==TyNeg1))TI01=1;         # always make start cell a flood tile no matter what
((TyFlPI05[TyFlRegNum]==2))TI01=1;       # fill mode, convert everything to flood
((TI01==1))TyFlWalkable;                 # cell is walkable - make it a flood tile and do all that processing
TyFlRemoveCell;                          # remove from collection since we done with it
((TyFlPI05[TyFlRegNum]>0))TyFlCellAddDirs;   # add ray cells that we need to check
L03-=1;
((L02<=0))return;    # we only allow a given number of draws
((L03>0))TyFlProcessRegion;  # more checks allowed keep checking

#TyFlRegNum=region, TI03=cell index, TI05=cell row, TI06=cell col
#walkable tile or first one. If not first, we have to have one of N,S,E,W that is flooded to draw
TyFlWalkable::((TyFlPI05[TyFlRegNum]==2))[TyFlFillWalkable][TyFlNonFillWalkable];

# non-fill mode, check neighbors
TyFlNonFillWalkable::TI01=0;
((TyFlDir[TI03]==TyNeg1))TI01=1;  # first cell no neighbor check
TI07=1;
((TI01==0))TyFlCheckDirFlood;  # see if neighbor is flooded
TI07=2;
((TI01==0))TyFlCheckDirFlood;
TI07=3;
((TI01==0))TyFlCheckDirFlood;
TI07=4;
((TI01==0))TyFlCheckDirFlood;
((TI01==1))TyFlDrawTile;

# fill mode, do not check neighbors.
# iRI01 is current tile read from map
# TI02 index into TyMapTiles for the row,col

TyFlFillWalkable::iPI01=TyFlPI01[TyFlRegNum];   # tileid to flood with
((iPI01==iRI01))return;     # cell is already flood, ignore
TyMapTiles[TI02]=iPI01;
place:TI05,TI06,iPI01;      # draw new tile
L02-=1;                    # did a draw
TyabTimerDraw=1;           # we did a draw

#TyFlRegNum=region, TI01=0, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
# return TI01: 0 = neighbor not flooded, 1 = neighbor is flooded
#EVENT
TyFlCheckDirFlood::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
((TI08<TyFlPY1[TyFlRegNum]))return;  # outside
((TI08>TyFlPY2[TyFlRegNum]))return;  # outside
((TI09<TyFlPX1[TyFlRegNum]))return;  # outside
((TI09>TyFlPX2[TyFlRegNum]))return;  # outside
    #inline
    #iPY1=TI08;   #row
    #iPX1=TI09;     #col
    #iTyabGetTile;  # read tile, update map
TI01=TI08-TynY1;
TI01*=TynXtiles;
TI01+=TI09;
TI01-=TynX1;
iRI01=get(TI08)(TI09);
TyMapTiles[TI01]=iRI01;
    #end inline
((iRI01==TyFlPI01[TyFlRegNum]))[TI01=1][TI01=0];  #return 1 if neighbor is already a flood tile

#this cell needs to be made a flood tile.
#EVENT
TyFlDrawTile::iPY1=TI05;
iPX1=TI06;
iPI01=TyFlPI01[TyFlRegNum];
iTyabDrawTile;
L02-=1;         # did a draw
TyabTimerDraw=1;         # we did a draw
TI01=TyFlPI05[TyFlRegNum];
((TyFlDir[TI03]==0))TI01=0;   #if this cell is a flood - it has no direction, so do not do any ray processing
((TI01==1))[TyFlChkWalkRays][TyFlChkWalkNoRays];

#EVENT
#ray mode, if start cell do nothing since we already added all its rays
TyFlChkWalkRays::((TyFlDir[TI03]>0))TyFldoChkWalkRays;  # not start, so see if ray dir matches a walk dir if so ,don't add it

TyFldoChkWalkRays::TyFlRndDir14;   # get random dirs 1-4
    # if N,S,E,W neighbor is walkable add it to deal with backtrack paths already ignored. However don't do it if we will add it in TyFlCellAddDirs
TI07=TyFlRndDir[0];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[1];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[2];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[3];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0

# check walkables in random order, no ray checks
#EVENT
TyFlChkWalkNoRays::TyFlRndDir14;
TI07=TyFlRndDir[0];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[1];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[2];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[3];
TyFlAddWalkableNeighbor;

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
TyFlAddWalkableNeighbor::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
TI07=0;    # clear dir since this will not itself spawn rays
((TI08<TyFlPY1[TyFlRegNum]))return;  # outside
((TI08>TyFlPY2[TyFlRegNum]))return;  # outside
((TI09<TyFlPX1[TyFlRegNum]))return;  # outside
((TI09>TyFlPX2[TyFlRegNum]))return;  # outside
    # in range, add neighbor dir
    # inline
    #iPY1=TI08;
    #iPX1=TI09;
    #iTyabGetTile;
TI01=TI08-TynY1;
TI01*=TynXtiles;
TI01+=TI08;
TI01-=TynX1;
iRI01=get(TI08)(TI09);
TyMapTiles[TI01]=iRI01;
    # end inline
((TyWalkTile[iRI01]==1))TyFlAddNDir;  # neighbor is walkable so add cell.

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
TyFlAddNInRange::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
TI01=1;
((TI08<TyFlPY1[TyFlRegNum]))return;     # outside
((TI08>TyFlPY2[TyFlRegNum]))return;     # outside
((TI09<TyFlPX1[TyFlRegNum]))return;     # outside
((TI09<=TyFlPX2[TyFlRegNum]))TyFlAddNDir;    # in range, add neighbor dir

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8), TI08,TI09=neighbor cell to add.
# also used by walkable to add N,S,E,W cells that have a dir of 0 to handle backtracking paths.

TyFlAddNDir::TyFlLLSize+=1;      #new cell
TyFlRow[TyFlLLSize]=TI08;
TyFlCol[TyFlLLSize]=TI09;
TI01=TyFlPI02[TyFlRegNum];         # time between cells
((TI07>4))TI01*=2;          # corner cells take 2x the time
TyFlTime[TyFlLLSize]=TyFlTNow+TI01;    # expire time based on now
TyFlNext[TyFlLLSize]=0;     # we are the new end
TyFlDir[TyFlLLSize]=TI07;   # direction
    #now add to end of linked list
((TyFlFIndex[TyFlRegNum]==0))TyFlFIndex[TyFlRegNum]=TyFlLLSize;   #if first empty, this is first
TI01=TyFlLIndex[TyFlRegNum];      # get current last so we can update the last cell to point to this new end
TyFlLIndex[TyFlRegNum]=TyFlLLSize;  # now the end
((TI01>0))TyFlNext[TI01]=TyFlLLSize;   # prior end if there was one now points to this as the end

#TyFlRegNum=region, TI03=cell index 
# we always remove the oldest (first cell) it is the only one we look at so TI03 is the first one.

TyFlRemoveCell::TI01=TyFlNext[TI03];               # get our next
TyFlFIndex[TyFlRegNum]=TI01;              # set as first
((TI01==0))TyFlLIndex[TyFlRegNum]=TI01;   # completely empty now

# add the dirs for this cell
#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col
TyFlCellAddDirs::TI07=TyFlDir[TI03];
((TI07>0))TyFlRayCellAddDirs;   # only add rays for cells that are themselves rays

TyFlRayCellAddDirs::((TI07<=4))[TyFlAddNInRange][TyFlAdd58NInRange];  # do dirs 1-4 or we have diagonal

# process a diagonal. First to the two primary dirs (random which one is first), then the diagonal
TyFlAdd58NInRange::;
TyFlRndDir[0]=TyFlDiag1[TI07];     # get first primary for this diagonal
TyFlRndDir[1]=TyFlDiag2[TI07];     # get second primary for this diagonal
TI10=random(0)(1);    # mix up which one is done first each time
TI11=TyFlRndDir[0];
TyFlRndDir[0]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI07=TyFlRndDir[0];   # first primary
TyFlAddNInRange;
TI07=TyFlRndDir[1];
TyFlAddNInRange;      # 2nd primary
TI07=TyFlDir[TI03];
TyFlAddNInRange;  # and go the actual diagonal

#.############################# TyabNotification ##################################
#### notification system based on a value that is decreasing
intarray TyabNotification         # fill in with values that define when to notify
intarray TyabNotificationDone     # matching index will be set to 1 when we have done the notification
int      TyabNotificationSize=0   # size of each array

TyabNotificationInit::TyabNotification[0]=2;
TyabNotification[1]=3;
TyabNotification[2]=4;
TyabNotification[3]=5;
TyabNotification[4]=6;
TyabNotification[5]=7;
TyabNotification[6]=9;
TyabNotification[7]=11;
TyabNotification[8]=16;
TyabNotification[9]=21;
TyabNotification[10]=26;
TyabNotification[11]=31;
TyabNotification[12]=41;
TyabNotification[13]=51;
TyabNotification[14]=61;
TyabNotification[15]=81;
TyabNotification[16]=101;
TyabNotification[17]=126;
TyabNotification[18]=151;
TyabNotification[19]=176;
TyabNotification[20]=201;
TyabNotification[21]=251;
TyabNotification[22]=301;
TyabNotification[23]=351;
TyabNotification[24]=401;
TyabNotification[25]=501;
TyabNotification[26]=601;
TyabNotification[27]=701;
TyabNotification[28]=801;
TyabNotification[29]=901;
TyabNotification[30]=1001;
TyabNotificationSize=31;
TyabNotificationReset;

# reset notification ranges for a new set of notifications
TyabNotificationReset::TyabNotificationDone[0]=0;
TyabNotificationDone[1]=0;
TyabNotificationDone[2]=0;
TyabNotificationDone[3]=0;
TyabNotificationDone[4]=0;
TyabNotificationDone[5]=0;
TyabNotificationDone[6]=0;
TyabNotificationDone[7]=0;
TyabNotificationDone[8]=0;
TyabNotificationDone[9]=0;
TyabNotificationDone[10]=0;
TyabNotificationDone[11]=0;
TyabNotificationDone[12]=0;
TyabNotificationDone[13]=0;
TyabNotificationDone[14]=0;
TyabNotificationDone[15]=0;
TyabNotificationDone[16]=0;
TyabNotificationDone[17]=0;
TyabNotificationDone[18]=0;
TyabNotificationDone[19]=0;
TyabNotificationDone[20]=0;
TyabNotificationDone[21]=0;
TyabNotificationDone[22]=0;
TyabNotificationDone[23]=0;
TyabNotificationDone[24]=0;
TyabNotificationDone[25]=0;
TyabNotificationDone[26]=0;
TyabNotificationDone[27]=0;
TyabNotificationDone[28]=0;
TyabNotificationDone[29]=0;
TyabNotificationDone[30]=0;

# input PI01 value to check
# output RI01: 1 value has already been seen for this range
#              0 value has not been seen for this range, it is now tagged as seen.
# values below the first range will always return 0. Values above the highest range map to that highest range
TyabNotificationCheckAndSet::L01=0;  # start at beginning
RI01=0;                            # assume notification for too small
((TyabNotificationSize>0))TyNChkL;   # if we have an array check it

TyNChkL::((PI01==TyabNotification[L01]))[TyNGetAndSet][TyNChkL1];  #handle equal

TyNChkL1::((PI01>TyabNotification[L01]))[TyNChkNext][TyNChkPast];  #handle > and <

TyNChkNext::L01+=1;
((L01<TyabNotificationSize))[TyNChkL][TyNChkPast];

# L01 is past the range
TyNChkPast::L01-=1;
((L01<0))return;                 # handle first one is too large
RI01=TyabNotificationDone[L01];  # get range flag
TyabNotificationDone[L01]=1;     # set that this range is done

TyNGetAndSet::RI01=TyabNotificationDone[L01];  # get range flag
TyabNotificationDone[L01]=1;                   # set that this range is done

### ------- Internal Tyab Command queue
# maze, path (others to come) are now serialized into a single intarray. All parameters are added to the queue
# this allows multiple calls to be made without worry if the previous call has finished or not. It is
# very useful when making chain paths.
# format:
#   method number:  0 = end of queue, 1 = maze, 2 = path, 3 = tight path, 4 = TyabQueueDrawRect
#   Total length:   total number of indexes needed to serial this command. This length defines how to find the next one.
#                    includes this value and the method number. 
#   following are the serialized values for each command. That is command specific and is done by the command itself.

intarray TyCmdQueue   # this is the queue
# only used to write commands
int      TyCmdWIndex=0  # current end+1. Can be == to start if empty While a command is serialzing it can update this value
int      TyCmdRIndex=0  # while reading index that updates during deserialization

# when writing a command. TyCmdWIndex always points to end+1 of last command written.
# When reading a command. TyCmdRIndex points to start of next command to read. IF same as TyCmdWIndex, queue is empty.

# set queue to empty
TyCmdEmpty::TyCmdWIndex=0;
TyCmdRIndex=0;
RI01=0;

### - path entry
TyabPath::TI01=2;
TyPathorTightSerialize;

### - tight path entry
TyabTightPath::TI01=3;
TyPathorTightSerialize;

TyPathorTightSerialize::TI02=TyCmdWIndex;   # save start for length calculation
TyCmdQueue[TyCmdWIndex]=TI01;               # add command index
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY3;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX3;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY4;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX4;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # path width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI02;   # cell width
TyCmdWIndex+=1;
TyCmdSerializeProbData;         # serialized PI04 and PIA01 and PIA02
TyCmdSerializeObstruct;         # serialized PI05 and PIA03 and PIA04
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

### - maze entry
TyabMaze::TI02=TyCmdWIndex;  # get ready to serialize, start always has where to start
TyCmdQueue[TyCmdWIndex]=1;   # maze ID
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # path width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI02;   # cell width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI03;   # walls
TyCmdWIndex+=1;
TyCmdSerializeProbData;         # serialized PI04 and PIA01 and PIA02
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

TyabQueueDrawRect::TI02=TyCmdWIndex;  # get ready to serialize, start always has where to start
TyCmdQueue[TyCmdWIndex]=4;   # draw queue rect
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # draw code
TyCmdWIndex+=1;
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

TyCmdSerializeProbData::TyCmdQueue[TyCmdWIndex]=PI04;      # serialized PI04 and PIA01 and PIA02
TyCmdWIndex+=1;
L01=0;
((PI04>0))TyCmdSerProbDataL;

TyCmdSerProbDataL::TyCmdQueue[TyCmdWIndex]=PIA01[L01]; # save probability
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PIA02[L01];                    # save tile id for that probability
TyCmdWIndex+=1;
L01+=1;
((L01<PI04))TyCmdSerProbDataL;

TyCmdSerializeObstruct::TyCmdQueue[TyCmdWIndex]=PI05;      # serialized PI05 and PIA03 and PIA04
TyCmdWIndex+=1;
L01=0;
((PI05>0))TyCmdSerObstL;

TyCmdSerObstL::TyCmdQueue[TyCmdWIndex]=PIA03[L01];   # row
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PIA04[L01]; # col
TyCmdWIndex+=1;
L01+=1;
((L01<PI05))TyCmdSerObstL;

#TI02 has start index of command prior to write
TyCmdSetSize::TI01=TyCmdWIndex-TI02;   # length of this one.
TI02+=1;                        # 2nd parameter is length
TyCmdQueue[TI02]=TI01;          # save length
TyCmdQueue[TyCmdWIndex]=0;      # put end of queue marker just in case

# process next command.
# return RI01=1 a command was run. 0 = queue empty
TyCmdNextCommand::RI01=0;
((TyCmdRIndex<TyCmdWIndex))[TyCmdDoNextComamnd][TyCmdEmpty];

TyCmdDoNextComamnd::RI01=1;
((TyCmdQueue[TyCmdRIndex]==1))[TyCmdRMaze][TyCmdRNot1];

TyCmdRNot1::((TyCmdQueue[TyCmdRIndex]==2))[TyCmdRPath][TyCmdRNot2];

TyCmdRNot2::((TyCmdQueue[TyCmdRIndex]==3))[TyCmdRTPath][TyCmdRNot3];

TyCmdRNot3::((TyCmdQueue[TyCmdRIndex]==4))[TyCmdRQueueDrawRect][TyCmdRNot4];

TyCmdRNot4::TyCmdEmpty;   # unknown, treat as queue empty

# process maze command
TyCmdRMaze::TyCmdRIndex+=2;  # skip ID and length
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];   # path width
TyCmdRIndex+=1;
PI02=TyCmdQueue[TyCmdRIndex];   # cell width
TyCmdRIndex+=1;
PI03=TyCmdQueue[TyCmdRIndex];   # walls
TyCmdRIndex+=1;
TyCmdDeSerializeProbData;  # serialized PI04 and PIA01 and PIA02
TyIMaze;                   # internal maze         

# process path command
TyCmdRPath::TyCmdPathorTightDeSerialize;
TyIPath;    # internal path routine

# process tight path command
TyCmdRTPath::TyCmdPathorTightDeSerialize;
TyITightPath; #internal tight path routine

TyCmdPathorTightDeSerialize::TyCmdRIndex+=2;  #skip command and length
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY3=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX3=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY4=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX4=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];   # path width
TyCmdRIndex+=1;
PI02=TyCmdQueue[TyCmdRIndex];   # cell width
TyCmdRIndex+=1;
TyCmdDeSerializeProbData;       # deserialized PI04 and PIA01 and PIA02
TyCmdDeSerializeObstruct;       # deserialized PI05 and PIA03 and PIA04

TyCmdRQueueDrawRect::TyCmdRIndex+=1;              #skip command, already processed
TyCmdRIndex+=1;              #skip length, don't need
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
TyabDrawRect;

TyCmdDeSerializeProbData::PI04=TyCmdQueue[TyCmdRIndex];      # deserialized PI04 and PIA01 and PIA02
TyCmdRIndex+=1;
L01=0;
((PI04>0))TyCmdDeSerProbDataL;

TyCmdDeSerProbDataL::PIA01[L01]=TyCmdQueue[TyCmdRIndex]; # get probability
TyCmdRIndex+=1;
PIA02[L01]=TyCmdQueue[TyCmdRIndex];                    # get tile id for that probability
TyCmdRIndex+=1;
L01+=1;
((L01<PI04))TyCmdDeSerProbDataL;

TyCmdDeSerializeObstruct::PI05=TyCmdQueue[TyCmdRIndex];      # deserialized PI05 and PIA03 and PIA04
TyCmdRIndex+=1;
L01=0;
((PI05>0))TyCmdDeSerObstL;

TyCmdDeSerObstL::PIA03[L01]=TyCmdQueue[TyCmdRIndex];   # row
TyCmdRIndex+=1;
PIA04[L01]=TyCmdQueue[TyCmdRIndex]; # col
TyCmdRIndex+=1;
L01+=1;
((L01<PI05))TyCmdDeSerObstL;

#. End --- TyabGenericScript.scr
#-------------------------------------
#.end --- Tyab-002-Cam.scr


}
