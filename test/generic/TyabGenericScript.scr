#.####################### Tyab Generic Script ##############################
#. TyabGenericScript.scr (c) 2022 Tyab All Rights Reserved
#pragma TyabScriptIncDate vy.m.d.g 
#
# useful utilities for dynamic map modifications
# convention used in this script is Y is row and X is column.
# Tyab functions all work in map space, 0,0 is the upper left corner including border.
# Most functions internally modify a memory tile store. It can be smaller then the map.
# Due to slow script processing speed, it is not viable to do large single mass changes
# at once, but you can do small changes in a large map.
# there is no limit on the size of a region but due to script engine limits the width or height
# should not exceed 800 or so.
# the general logic flow is the following:
#   1. Use TyabInit before calling any other method. Best is to call it from your init::EVENT;
#   2. Use TyabReadMapTiles to read in any tiles you will not modify as part of a later draw. This is optional.
#   3. Use Tyab* to change a portion of in memory tiles.
#   4. Use TyabDrawRect to draw changed portions of the region to the map.
#
# If you do #2 on a large map, realize the script engine is measured in 10's of thousands of lines
# per second and a 128x128 map is over 16K thousand cells so just the reading can take some time.
# It is best to just read a smaller subregion that you will then modify. If the functions are are calling
# do not skip cells, you don't need to read in tiles first.
# some functions may take longer processing time so they are resumable. TyabTimer should
# be called on a regular basis and it will finish in chunks things that take some time.
# TyabBusy is an int, and if it is non-zero, one of the functions is busy. Calling most functions
# when another function is busy will have that call ignored. This allows larger modifications to happen
# without significant impact on game play interaction. But it does mean if you are going to do
# large area modifications that you have to account for that. For example, creating a maze or path
# that is large, you will want to start it before you really need it and put a few time-sink type
# of user operations before you need the result. (drill a few walls, walk across a open area, etc)
# TyabDrawRect is special - it is queued up and will take place automatically once
# TyabBusy is 0, so you can make a maze and then draw it and not worry about if the maze is done or not.
# TyabFlood is also special, it is designed to always run off of TyabTimer so you may make any other call
# after calling TyabFlood - it will process the flood in the background. There are no limits to the number of
# active floods at the same time.
#
############################################################################
#
# Tyab API quick reference: See each method below for calling parameters
#   TyabInit         - Required before any Tyab method. Initialized vars and set up the tile store
#   TyabTimer        - Required. Call often to allow incremental update and larger mazes.
#   TyabReadMapTiles - Call to read map tiles back into internal array.
#   TyabFill         - Fill rectangular region with a tile ID.
#   TyabRandomRect   - Fill rectangular region with a probability list tile.
#   TyabWalkRect     - Change all walkable tiles to a probability list tile in a region.
#                      One will want to call TyabReadMapTiles before using this in most cases.
#   TyabDrillRect    - Change all drillable tiles to a probability list tile in a region.
#                      One will want to call TyabReadMapTiles before using this in most cases.
#   TyabDrilling     - drill every map tile in the given region. Tilemap is NOT updated.
#   TyabReplaceRect  - Replace the given tile with probability list tile in a region.
#   TyabDrawRect     - Draw map from internal array incrementally. Needs TyabTimer to be called to complete larger updates.
#   TyabQueueDrawRect- Same as DrawRect but queues the draw for a later TyabTimer event
#   TyabDrawTile     - Set a single map tile.
#   TyabGetTile      - Get a single map tile.
#   TyabMaze         - Create a random maze into internal array. Needs TyabTimer to make larger mazes.
#   TyabPath         - Create a random path between two points within a rect. Needs TyabTimer for larger paths.
#   TyabTightPath    - Like path but will zig/zag and only supports single tile paths. Is MUCH slower than path.
#   TyabObstructAdd  - Helper function to add region to obstruction data for Path and TightPath
#   TyabFlood        - start a flood with a given tile. Multiple may be started.
#   TyabFloodStop    - Stops all floods in progress.
#   TyabNotificationInit - setup notification values. It also calls TyabNotificationReset
#   TyabNotificationReset  - reset notifications so they can be done again
#   TyabNotificationCheckAndSet - check if value in the notification ranges has been seen before
#   TyabTriggerLock    - serialize access across triggers and timer
#   TyabTriggerRelease - release serial access across triggers and timers
#
############################  predefined tile types
# Tile IDs are mapped to their respective texture.
# There are four types of wall textures:
#   - Regular, where it has 3 neighbor tiles and 2 diagonal neighbors adjacent to each other
#   - Corner, where it has 4 neighbors and 3 diagonal neighbors
#   - Edge, where it has 2 neighbor tiles and 1 diagonal neighbors,
#   - Intersect, where it has 4 neighbors and 2 diagonal neighbors opposite to each other
#
#  tiles tagged in comments as cosmetic are generated by the engine automatically - not user settable
#  from script you place the regular tiles and engine will generate the correct corners/edges
# Reinforced walls have 50 added to the base value.
# Hidden walls have 100 added to the base value. From script I can't get hidden to work as intended -
# thus if you want to modify an area that will be discovered, it must be discovered first, then modify.
#
# negative and 0 are not used. Values unused or outside of range are an error and can generate an invalid tile in-game.
# all macros. Use $(name) to get the value, must process through Tyab MMDatUtil for macro processing
#pragma define tGround=1
#pragma define tRubble1=2
#pragma define tRubble2=3
#pragma define tRubble3=4
#pragma define tRubble4=5
#pragma define tLava=6
#pragma define tErosion4=7
#pragma define tErosion3=8
#pragma define tErosion2=9
#pragma define tErosion1=10
#pragma define tWater=11
#pragma define tSlimyHole=12
#pragma define tPowerpathInProgress=13
#pragma define tPowerpathBuilding=14
#pragma define tPowerpathBuildingpowered=15
#pragma define tPowerpath1=16
#pragma define tPowerpath1Powered=17
#pragma define tPowerpath2Adjacent=18
#pragma define tPowerpath2AdjacentPowered=19
#pragma define tPowerpath2Opposite=20
#pragma define tPowerpath2OppositePowered=21
#pragma define tPowerpath3=22
#pragma define tPowerpath3Powered=23
#pragma define tPowerpath4=24
#pragma define tPowerpath4Powered=25
#pragma define tDirtRegular=26
#pragma define tDirtCorner=27
#pragma define tDirtEdge=28
#pragma define tDirtIntersect=29
#pragma define tLooseRockRegular=30
#pragma define tLooseRockCorner=31
#pragma define tLooseRockEdge=32
#pragma define tLooseRockIntersect=33
#pragma define tHardRockRegular=34
#pragma define tHardRockCorner=35
#pragma define tHardRockEdge=36
#pragma define tHardRockIntersect=37
#pragma define tSolidRockRegular=38
#pragma define tSolidRockCorner=39
#pragma define tSolidRockEdge=40
#pragma define tSolidRockIntersect=41
#pragma define tCrystalSeamRegular=42
#pragma define tCrystalSeamCorner=43
#pragma define tCrystalSeamEdge=44
#pragma define tCrystalSeamIntersect=45
#pragma define tOreSeamRegular=46
#pragma define tOreSeamCorner=47
#pragma define tOreSeamEdge=48
#pragma define tOreSeamIntersect=49
#pragma define tRechargeSeamRegular=50
#pragma define tRechargeSeamCorner=51
#pragma define tRechargeSeamEdge=52
#pragma define tRechargeSeamIntersect=53
                                    # 54 Not used
                                    # 55 Not used
                                    # 56 Not used
                                    # 57 Not used
#pragma define tRoof=58
#pragma define tFakeRubble1=60
#pragma define tFakeRubble2=61
#pragma define tFakeRubble3=62
#pragma define tFakeRubble4=63
#pragma define tCliff1=64                          # collision barrier looks like rubble experimental
#pragma define tCliff2=65                          # collision barrier looks like solid rock experimental
#pragma define tDirtRegularReenforced=76           # 76 = 26 + 50  
#pragma define tLooseRockRegulaReenforced=80       # 80 = 30 + 50
#pragma define tHardRockRegularReenforced=84       # 84 = 34 + 50
#pragma define tSolidRockRegularReenforced=88      # 88 = 38 + 50
#pragma define tDirtRegularHidden=126              # 126 = 26 + 100
#pragma define tLooseRockRegulaHidden=130          # 130 = 30 + 100
#pragma define tHardRockRegularHidden=134          # 134 = 34 + 100
#pragma define tSolidRockRegularHidden=138         # 138 = 38 + 100

# remaining vars can change and are used to pass parameters to/from the Tyab methods
# also are defined internal temp vars. Do not assume values across Tyab methods.
# clients can use these themselves as long as no Tyab* is called since they are free to modify them
# clients must not remove any of these

# for loop simulation control variables. Add more as needed
int L01=0
int L02=0
int L03=0
#int L04=0
#int L05=0
#int L06=0
#int L07=0
#int L08=0
#int L09=0
#int L10=0

# general int parameters to pass to functions (events). Add more as needed

int PI01=0
int PI02=0
int PI03=0
int PI04=0
int PI05=0
int PI06=0
int PI07=0
#int PI08=0
#int PI09=0

# general intarray parameters. Add more as needed
intarray PIA01
intarray PIA02
intarray PIA03
intarray PIA04
#intarray PIA05

# parameters for X (column),Y (rows) values. Add more as needed
# Tyab* methods are free to modify any of these
int PX1=0
int PY1=0
int PX2=0
int PY2=0
int PX3=0
int PY3=0
int PX4=0
int PY4=0
#int PX5=0
#int PY5=0
#int PX6=0
#int PY6=0
#int PX7=0
#int PY7=0
#int PX8=0
#int PY8=0
#int PX9=0
#int PY9=0

# return values from methods (events). Add more as needed.
# Tyab* methods are free to modify any of these
int RI01=0
int RI02=0
int RI03=0
int RI04=0
#int RI05=0
#int RI06=0
#int RI07=0
#int RI08=0
#int RI09=0

# temp vars. Only used for short term calcs within a set of functions. Add more as needed
int TI01=0
int TI02=0
int TI03=0
int TI04=0
int TI05=0
int TI06=0
int TI07=0
int TI08=0
int TI09=0
int TI10=0
int TI11=0
int TI12=0
int TI13=0
int TI14=0

float TF01=0.0
float TF02=0.0
float TF03=0.0
#float TF04=0.0
#float TF05=0.0
#float TF06=0.0
#float TF07=0.0
#float TF08=0.0
#float TF09=0.0

# temporary strings. Add more as needed
string TS01=""
#string TS02=""
#string TS03=""
#string TS04=""
#string TS05=""
#string TS06=""
#string TS07=""
#string TS08=""
#string TS09=""

# messsage strings. Use with msg:   Change, add as needed
string S01="String01"
string S02="String02"
#string S03="String03"
#string S04="String04"
#string S05="String05"
#string S06="String06"
#string S07="String07"
#string S08="String08"
#string S09="String09"

###########
# memory tilemap
intarray TyMapTiles

int TyNeg1=0  # will become -1 since script does not like negative constants
int TynXtiles=0  # width of region
int TynYtiles=0  # height of region
int TynSize=0    # height*width
int TynX1=0      # col of region start
int TynY1=0      # row of region start
int TynX2=0      # col of region end
int TynY2=0      # row of region end
int TyabBusy=0   # 0=not busy, 1=maze building, 2=maze drawing, 3=path building, 4=path drawing, 5=tightpath building
int TyabTimerDraw=0  #1= Tyab did a draw during TyabTimer or its busy with maze/path

#.############### TyabTriggerLock / TyabTriggerRelease #########################
# --- trigger control to serialize access between timers and triggers
# -- from a trigger, call TriggerLock to get the lock. Prior to event returning, call TriggerRelease
# -- Do not do this from the main timer event - only from if/when triggers

int TyabInMyTimer=0            # detect timer recursion. Caller should set/clear this in their timer logic
int TyTriggerNeedsControl=0    # contains number of triggers waiting for control
int TyTriggerHasControl=0      # set when a trigger has control, 0 when it finishes, so another trigger waiting for control can get it.

TyabTriggerLock::TyTriggerNeedsControl+=1;    # a trigger want to get access, this has timer ignored
((TyabInMyTimer==0))[TyTriggerTimerDone][TyTriggerTimerLoop]; # wait until timer finished (if it was running)

TyTriggerTimerLoop::wait:random(0.035)(0.085);    # give timer a chance to finish - use short random time
((TyabInMyTimer==0))[TyTriggerTimerDone][TyTriggerTimerLoop]; # wait until timer finished (if it was running)

# timer has finished, now we need to get the lock to continue or wait until we get the lock
TyTriggerTimerDone::((TyTriggerHasControl==0))[TyTriggerHasControl=1][TyTriggerWaitLoop];

TyTriggerWaitLoop::wait:random(0.035)(0.085);   # multiple triggers waiting, wait random time
((TyTriggerHasControl==0))[TyTriggerHasControl=1][TyTriggerWaitLoop]

TyabTriggerRelease::TyTriggerHasControl=0;  # release lock
TyTriggerNeedsControl-=1;               # this trigger is no longer waiting
# ---


#.############### TyabEngineVer ##################################################
# check to see what version of the engine is playing.
# TyabMMEngineVer  0        = unknown. Engine is before 20220930
#       20220930 = engine is 20220930 or newer  ( supports divide // and /= )
#       20221212 = engine is 20221212 or newer  ( no longer supports / event seperator )
#       20230414 = engine is 20230414 or newer  ( has return event )
int TyabMMEngineVer=0

TyabEngineVer::TyTry20230414;
((TyabMMEngineVer<20230414))TyNot20230414;

TyTry20230414::TyabMMEngineVer=20230414;
return;             # unknown event prior to 20230414
TyabMMEngineVer=0;  #older versions will execute this line

TyNot20230414::TyabMMEngineVer=10;
TyValid20220903;
((TyabMMEngineVer==5))[Ty20220903orLater][TyabMMEngineVer=0]; # if divide works at least 20220903

TyValid20220903::TyabMMEngineVer=TyabMMEngineVer//2;

# 2022-09-03 or later
Ty20220903orLater::TyabMMEngineVer=10;
TyInvalidEvent20221212;
((TyabMMEngineVer==5))[TyabMMEngineVer=20220903][TyabMMEngineVer=20221212];

# this is invalid on 2022-12-12 or later. Prior 5 will be set
TyInvalidEvent20221212::TyabMMEngineVer=5/   # old style separator


#.############### TyabInit ##################################################
# defines inclusive region for memory tile map. Can be full map size for all maps
# since the tile store is not initialized.
# PY1, PX1 row,col start (usually 0,0 but can be any upper left corner)
# PY2, PX2: row,col end. Usually this is the highest row/col in the editor (height-1, width-1)
#          The resulting tilemap will be (height = PY2-PY1+1, width = PX2-PX1+1)
# NOTE: If you define a smaller region then the entire map, you cannot use Tyab methods to address
#       outside of that region. There are no checks for this, and most likly you will crash the game
#       due to negative array indexes. You are warned.
#       Likewise - it is invalid for any Tyab method to use coords outside the range of the map
#       again most likly you will crash the game engine.

TyabInit::TyNeg1=0-1;                    #neg 1 constant to work around negative constants script bug
TyabBusy=0;
TynX1=PX1;
TynY1=PY1;
TynX2=PX2;
TynY2=PY2;
TynYtiles=PY2-PY1;             #height
TynYtiles+=1;
TynXtiles=PX2-PX1;             #width
TynXtiles+=1;
TynSize=TynYtiles*TynXtiles;  #size of byte map
TyMapTiles[0]=0;
TI01=TynSize-1;
TyMapTiles[TI01]=0;     # make sure its allocated to this size
TyInitWalkDrill;        # initialize our walk/drill flags
TyMzConstInit;          # initialize maze/path bits/flags
TyFlInit;               # init flooding system
TyabNotificationInit;   # setup default message notification system
TyCmdEmpty;             # init command queue to empty

intarray TyWalkTile   # array for each tile, 0=not walkable, 1=walkable. only for tiles 0-255
intarray TyDrillTile  # array for each tile, 0=not drillable, 1=drillable. only for tiles 0-255.
intarray TyLavaOrWater # array for each tile, 0=not lava/water, 1=lava or water

# initialize the walkable and drillable tile flags

TyInitWalkDrill::L01=0;
TyInitWDL;


TyInitWDL::TI01=1;     #assume walkable
TI02=L01;
((L01>100))TI02-=100;
((TI02>=$(tDirtRegularReenforced)))TI02-=50;
# set lava/water
TyLavaOrWater[L01]=0;
((TI02==$(tWater)))TyLavaOrWater[L01]=1;
((TI02==$(tLava)))TyLavaOrWater[L01]=1;
# set walkable
((TI02<$(tGround)))TI01=0;
((TI02>$(tPowerpath4Powered)))TI01=0;
((TI02==$(tLava)))TI01=0;
((TI02==$(tWater)))TI01=0;
((TI02==$(tFakeRubble1)))TI01=1;
((TI02==$(tFakeRubble2)))TI01=1;
((TI02==$(tFakeRubble3)))TI01=1;
((TI02==$(tFakeRubble4)))TI01=1;
TyWalkTile[L01]=TI01;          # save walkable state
# set drillable
TI01=1;       # assume drillable
((TI02<$(tDirtRegular)))TI01=0;
((TI02>$(tOreSeamIntersect)))TI01=0;
((TI02==$(tSolidRockRegular)))TI01=0;
((TI02==$(tSolidRockCorner)))TI01=0;
((TI02==$(tSolidRockEdge)))TI01=0;
((TI02==$(tSolidRockIntersect)))TI01=0;
TyDrillTile[L01]=TI01;         # save drillable state
L01+=1;
((L01<256))TyInitWDL;

#.############### TyabTimer #################################################
# timer event. Call often!. incremental output needs regular timers. We also spin the random to change sequence
# returns TyabTimerDraw=1 if we did draw something, 0 = did not draw
#priority: 1) Pending draw actions.
#          2) Pending maze/path actions
#          3) Pending command queue actions
#          4) Pending flood actions

TyabTimer::TI01=random(0)(1);  #next in psuedo random sequence
TyabTimerDraw=TyabBusy;
((TyabBusy>0))[TyTimerMz][TyDrawTimerChk];

# if pending updates, do those, otherwise do flood timer
TyDrawTimerChk::((TyDRnChunks>0))[TyDRNext][TyCmdTimerChk];

# return TyabTimerDraw=1 if something was drawn, 0=nothing drawn. Can be used to prevent mixing water/lava/other draws in same trigger
TyCmdTimerChk::((TyCmdRIndex<TyCmdWIndex))[TyCmdNextCommand][TyFlTimerChk];

TyFlTimerChk::((TyFlNRegions>0))TyFlRegionLInit;

TyTimerMz::((TyabBusy==2))TyabIMaze;  #maze draw first
((TyabBusy==1))TyabIMaze;             #then check maze generation
((TyabBusy==4))TyabIPath;             #path draw first
((TyabBusy==3))TyabIPath;             #then check path generation
((TyabBusy==5))TyabITightPath;        #tight path generation

#.############### TyabReadMapTiles ##########################################
# utility to read in map tile ID's into TyMapTiles intarray
# can be used to just read a subsection
# input parameters:
# PX1, PY1  start x,y location to read.
# PX2, PY2  end x,y location to read.
# output:
#   TyMapTiles intarray filled in with ID's for the range.

TyabReadMapTiles::L01=PY1;          # tile row
TyRMTRowL;


TyRMTRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;            # tile index
TI02=PX2-L02;
((TI02>=8))[TyRMTColLg][TyRMTColSm];   #large or small widths
L01+=1;
((L01<=PY2))TyRMTRowL;


TyRMTColSm::TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
((L02<=PX2))TyRMTColSm;


TyRMTColLg::TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TyMapTiles[TI01]=get(L01)(L02);    # read and store tile ID
TI01+=1;
L02+=1;
TI02=PX2-L02;
((TI02>=8))[TyRMTColLg][TyRMTColSm];

#.############### TyabFill ##########################################
# utility to change a region to the given tile ID
#input parameters
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.
# PI01      tile id to fill


TyabFill::L01=PY1;
TyFrRowL;


TyFrRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyFrColLg][TyFrColSm];  # large columns or small columns
L01+=1;
((L01<=PY2))TyFrRowL;


TyFrColSm::TyMapTiles[TI01]=PI01;
TI01+=1;
L02+=1;
((L02<=PX2))TyFrColSm;


TyFrColLg::TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
TyMapTiles[TI01]=PI01;
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyFrColLg][TyFrColSm];  #do 8 at at time for performance

#.############### TyabDrilling ##########################################
# utility to drill every tile in a region
#input parameters
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.

TyabDrilling::L01=PY1;
TyDrillingRowL;

TyDrillingRowL::L02=PX1;
TyDrillingColSm;
L01+=1;
((L01<=PY2))TyDrillingRowL;

TyDrillingColSm::drill:L01,L02;
L02+=1;
((L02<=PX2))TyDrillingColSm;

#.############### TyabRandomRect ##########################################
# utility to change every tile in this region to a random tile
#input parameters
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
# PI04: number of path types in PIA01 and PIA02
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.


TyabRandomRect::L01=PY1;
TyFrngRowL;


TyFrngRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyFrngColLg][TyFrngColSm];  # column loop
L01+=1;
((L01<=PY2))TyFrngRowL;


TyFrngColSm::TyProbTile;   #get tile from list of probalities
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
L02+=1;
((L02<=PX2))TyFrngColSm;


TyFrngColLg::TyProbTile;   #get tile from list of probalities
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
TyProbTile;
TyMapTiles[TI01]=RI01;       #save it
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyFrngColLg][TyFrngColSm];

#.##################### Incremental DrawRect support ########################
# incremental draw. Will draw tiles into the map from our array. Total size per actual draw is limited.
intarray TyDRY1Chunk
intarray TyDRX1Chunk
intarray TyDRY2Chunk
intarray TyDRX2Chunk
intarray TyDRTyChunk    # type of draw, 0=all, -1 no water/lava, >0 only draw that id
int TyDRnChunks=0    # number of chunks to draw
int TyDRnMaxDraw=512 #max number of tiles to modify per draw

#call this to draw the next chuck queued up. If none, it does nothing.

TyDrTimer::((TyDRnChunks>0))TyDRNext;   #we have something, draw the next chunks

# draw next chunk.

TyDRNext::TyDRnChunks-=1;
TI04=TyDRY1Chunk[TyDRnChunks];
TI05=TyDRX1Chunk[TyDRnChunks];
TI06=TyDRY2Chunk[TyDRnChunks];
TI07=TyDRX2Chunk[TyDRnChunks];
TI08=TyDRTyChunk[TyDRnChunks];
TI02=TI06-TI04;
TI02+=1;           #height
TI03=TI07-TI05;
TI03+=1;           #width
TI01=TI02*TI03;    #size
TyabTimerDraw=1;        # return we are drawing something
((TI01<=TyDRnMaxDraw))[TyDR][TyDRSubdivide];   #either draw or subdivide

# TI04-TI07 too big. subdivide and try again Favor dividing up rows unless a row is too small

TyDRSubdivide::((TI02>1))[TyDRSubDivY][TyDRSubDivX];  #either split in row or col
TyDRNext;          #try again - eventually we will draw the end of the queue

# Subdividing rows by half. TI02 is height, TI04-TI07 is rect, TI08=type

TyDRSubDivY::TF01=TI02;   #height
TF01*=0.5;
TF01+=0.00001; #round off
TI01=TF01;  #height of first part
TI09=TI04+TI01;  #start of 2nd part
# adding top part
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI09-1;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;
# adding bottom part
TyDRY1Chunk[TyDRnChunks]=TI09;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;

# Subdividing cols by half. TI03 is width

TyDRSubDivX::TF01=TI03;   #width
TF01*=0.5;
TF01+=0.00001; #round off
TI01=TF01;      #width of first part
TI09=TI05+TI01;
# adding left side
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI05;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI09-1;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;
# adding right side
TyDRY1Chunk[TyDRnChunks]=TI04;
TyDRX1Chunk[TyDRnChunks]=TI09;
TyDRY2Chunk[TyDRnChunks]=TI06;
TyDRX2Chunk[TyDRnChunks]=TI07;
TyDRTyChunk[TyDRnChunks]=TI08;
TyDRnChunks+=1;

#.############### TyabDrawRect ##########################################
# Draw region to the screen
#input parameters
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
# PI01      type. 0 = draw everything, -1 = draw all but water/lava, >0 only draw that id (normally just tLava and tWater)
# TyMapTiles     intarray of id's.
# you are safe to queue up more regions while the existing ones are drawn one per TyDrTimer event

TyabDrawRect::TyabIQueueDrawRect; # add to short term queue
((TyabBusy==0))TyDRNext;          # draw queue if not waiting for maze/path

TyabIQueueDrawRect::TyDRY1Chunk[TyDRnChunks]=PY1;
TyDRX1Chunk[TyDRnChunks]=PX1;
TyDRY2Chunk[TyDRnChunks]=PY2;
TyDRX2Chunk[TyDRnChunks]=PX2;
TyDRTyChunk[TyDRnChunks]=PI01;
TyDRnChunks+=1;

# draw a single region TI04=Y1, TI05=X1, TI06=Y2, TI07=X2, TI08=type

TyDR::L01=TI04;  #start row
((TI08==0))TyDrRowL;
((TI08==TyNeg1))TyDrRowLN1;
((TI08>0))TyDrRowLID;


TyDrRowL::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>8))[TyDrColLg][TyDrColSm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowL;


TyDrRowLN1::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>=8))[TyDrColN1Lg][TyDrColN1Sm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowLN1;


TyDrRowLID::L02=TI05;   #start cp;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;               # tile index
TI02=TI07-L02;
((TI02>=8))[TyDrColIDLg][TyDrColIDSm];   #column loop
L01+=1;
((L01<=TI06))TyDrRowLID;


TyDrColSm::TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColSm;

# skip lava and water

TyDrColN1Sm::TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColN1Sm;


TyDrColDraw1::TI03=get(L01)(L02);  # read existing
((TI02!=TI03))place:L01,L02,TI02;  # only change if different

# only draw the given ID

TyDrColIDSm::TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
((L02<=TI07))TyDrColIDSm;



TyDrColLg::TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
TI03=get(L01)(L02);      # read existing
((TI02!=TI03))place:L01,L02,TI02; # only change if different
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>=8))[TyDrColLg][TyDrColSm];


TyDrColN1Lg::TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TyLavaOrWater[TI02]==0))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>=8))[TyDrColN1Lg][TyDrColN1Sm];


TyDrColIDLg::TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TyMapTiles[TI01];
((TI02==TI08))TyDrColDraw1;
TI01+=1;
L02+=1;
TI02=TI07-L02;
((TI02>8))[TyDrColIDLg][TyDrColIDSm];    #remainer

#.############################ TyabDrawTile #################################
# PY1, PX1  Row, col location to change.
# PI01: TileID

TyabDrawTile::TI01=PY1-TynY1;
TI01*=TynXtiles;
TI01+=PX1;
TI01-=TynX1;
TyMapTiles[TI01]=PI01;
place:PY1,PX1,PI01;

int iPY1=0    # internal only variable
int iPX1=0    # internal only variable
int iPI01=0   # internal only variable
int iRI01=0   # internal only variable

#.############################ iTyabDrawTile #################################
# internal only
# iPY1, iPX1  Row, col location to change.
# iPI01: TileID
iTyabDrawTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
TyMapTiles[TI01]=iPI01;
place:iPY1,iPX1,iPI01;

#.############################ iTyabSetTile #################################
# internal only. Unlike iTyabDrawTile it does not use place, it only changes in-memory array
# iPY1, iPX1  Row, col location to change.
# iPI01: TileID
iTyabSetTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
TyMapTiles[TI01]=iPI01;

#.############################ TyabGetTile #################################
# PY1, PX1  Row, col location to change.
# Return: RI01: TileID

TyabGetTile::TI01=PY1-TynY1;
TI01*=TynXtiles;
TI01+=PX1;
TI01-=TynX1;
RI01=get(PY1)(PX1);
TyMapTiles[TI01]=RI01;

#.############################ iTyabGetTile #################################
# internal only
# iPY1, iPX1  Row, col location to change.
# Return: iRI01: TileID

iTyabGetTile::TI01=iPY1-TynY1;
TI01*=TynXtiles;
TI01+=iPX1;
TI01-=TynX1;
iRI01=get(iPY1)(iPX1);
TyMapTiles[TI01]=iRI01;


#.################### TyabWalkRect ##########################################
# replace all walkable tiles with a random walkable tile
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
#   PI04: number of path types in IAP01 and IAP02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabWalkRect::L01=PY1;
TyWRowL;


TyWRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyWColLg][TyWColSm];
L01+=1;
((L01<=PY2))TyWRowL;


TyWDR1::TyProbTile;
TyMapTiles[TI01]=RI01;


TyWColSm::RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
L02+=1;
((L02<=PX2))TyWColSm;


TyWColLg::RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
RI01=TyMapTiles[TI01];
((TyWalkTile[RI01]==1))TyWDR1;
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyWColLg][TyWColSm];

#.################### TyabDrillRect ##########################################
# replace all drillable tiles with a random walkable tile
# PX1, PY1  start x,y location to change.
# PX2, PY2  end x,y location to change.
#   PI04: number of tile types in IAP01 and IAP02
#   PIA01: intarray: each item is the tile id.
#   PIA02: intarray: each item is the odds 0-1000 of using that tile ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabDrillRect::L01=PY1;
TyDrillRowL;


TyDrillRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyDrillColLg][TyDrillColSm];  # columns
L01+=1;
((L01<=PY2))TyDrillRowL;


TyDrillColSm::RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
L02+=1;
((L02<=PX2))TyDrillColSm;


TyDrillColLg::RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
RI01=TyMapTiles[TI01];
((TyDrillTile[RI01]==1))TyWDR1;        #get tile from list of probalities
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyDrillColLg][TyDrillColSm];  # columns

#.################### TyabReplaceRect ##########################################
# replace given tile with probability list tile for region.
# PY1, PX1  start row,col location to change.
# PY2, PX2  end row,col location to change.
#   PI01: Tile to replace.
#   PI04: number of tile types in IAP01 and IAP02
#   PIA01: intarray: each item is the tile id.
#   PIA02: intarray: each item is the odds 0-1000 of using that tile ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

TyabReplaceRect::L01=PY1;
TyReplaceRowL;


TyReplaceRowL::L02=PX1;
TI01=L01-TynY1;
TI01*=TynXtiles;
TI01+=L02;
TI01-=TynX1;         # tile index
TI02=PX2-L02;
((TI02>=8))[TyReplaceColLg][TyReplaceColSm];  # columns
L01+=1;
((L01<=PY2))TyReplaceRowL;


TyReplaceColSm::((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
L02+=1;
((L02<=PX2))TyReplaceColSm;


TyReplaceColLg::((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
((TyMapTiles[TI01]==PI01))TyWDR1;        #replace tile from list of probalities
TI01+=1;
L02+=8;
TI02=PX2-L02;
((TI02>=8))[TyReplaceColLg][TyReplaceColSm];  # columns


##################### TyProbTile ##########################################
# return a random tile based on the array of allowed tiles each with a given probability
# inputs:
#   PI04: number of path types in PIA01 and PIA02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 1-1000 of using that path type ID from PIA01, each value is 0.1%
#                    The sum of all of the odds should be 1000. If sum under 1000, the last item will be selected
#                    If sum is over 1000, the one that breaks the 1000 sum is the last one that can be selected.
#                    You can use 0 to prevent a tile from being selected.
# returns:
#   RI01 is the tile ID for the path.

TyProbTile::TI10=0;   # probability sum
TI12=0;               # loop through probabilities
TI11=random(1)(1000); # get random probability
TyProbTileL;


TyProbTileL::TI10+=PIA02[TI12];  # add in next probability
RI01=PIA01[TI12];                # id of current one
((TI11<=TI10))return;            # found it return
TI12+=1;                         # next loop
((TI12<PI04))TyProbTileL;        # loop until found or run out of items


##################### TyiProbTile ##########################################
# return a random tile based on the array of allowed tiles each with a given probability
# used by routines that use the command queue - var names do not conflict with user vars
# inputs:
#   iPI04: number of path types in iPIA01 and iPIA02
#   iPIA01: intarray: each item is the path type ID.
#   iPIA02: intarray: each item is the odds 1-1000 of using that path type ID from PIA01, each value is 0.1%
#                    The sum of all of the odds should be 1000. If sum under 1000, the last item will be selected
#                    If sum is over 1000, the one that breaks the 1000 sum is the last one that can be selected.
#                    You can use 0 to prevent a tile from being selected.
# returns:
#   iRI01 is the tile ID for the path.

int iPI04=0
intarray iPIA01
intarray iPIA02
int iPSum=0
int iPLoop=0
int iPFind=0


TyiProbTile::iPSum=0;   # probability sum
iPLoop=0;               # loop through probabilities
iPFind=random(1)(1000); # get random probability
TyiProbTileL;


TyiProbTileL::iPSum+=iPIA02[iPLoop];  # add in next probability
iRI01=iPIA01[iPLoop];                 # id of current one
((iPFind<=iPSum))return;              # found it, force loop end
iPLoop+=1;                            # next loop
((iPLoop<iPI04))TyiProbTileL;         # loop until found or run out of items


#.################################## Random Maze #############
#. Random Maze generation. Based on Growing Tree Algorithm.
#. see: https://weblog.jamisbuck.org/2011/1/27/maze-generation-growing-tree-algorithm
# 
# basic psuedo code is as follows
# 1. Let C be a collection of cells - initially empty.
# 2. Put a random cell into C. Tag it as visited.
# 3. Repeat until C is empty
# 4.     Pick a cell from C.  (how you do this changes the behavior - see below)
# 5.     Look at the 4 neighbors of that cell. Are any of them unvisisted?
#           Yes: pick one of the unvisited randomly, make a path to it, add that neighbor to C and tag neighbor as visited.
#           No: Remove the cell from C.
#   
# how you pick the cell in #4 changes the behavior. If it is random, you have Prims algorithm.
# if you pick the newest you get Recursive Backtracking algorithm. As suggested in above link I use a 50/50 mix to get a blend of both.
# Tyab Path is the same but only uses the newest thus Recursive Backtracking.
#
# For conventions the 4 directions (neighbors) are:
#  North:  row-1, col
#  South:  row+1, col
#  East:   row, col+1
#  West:   row, col-1
#  rows and cols are mapped via: index = (row * TyMzXsize) + col

##### define vars we will use.
int TyMzYsize=0
int TyMzXsize=0
int TyMzSize=0          # will be TyMzYsize*TyMzXsize
intarray TyMzXset       # collection class to store cell columns for cells that have paths in progress
intarray TyMzYset       # collection class to store cell rows    for cells that have paths in progress
int TyMzSizeSet=0       # size of collection class
intarray TyMzNeighbors  # internal list of valid directions for a cell
int TyMzSizeNeighbors=0 # number of neighbors in array
intarray TyMzVisited    # 0: not visited, >=1: visited
int TyMzMapScale=0      # number of map tiles per maze cell (1,2,3,4 supported)
float TyMzfMap2Cell=0.0 # convert from map to cell
intarray TyMzDirXInc    # for each dir, contains the x increment value
intarray TyMzDirYInc    # for each dir, contains the Y increment value
intarray TyMzDir2Bit    # map from dir (1-4) to the bit value (1,2,4,8)
intarray TyMzDirB2Bit   # map from dir (1-4) to the return direction bit (2,1,8,4)
intarray TyMzDirN       # map from combined direction bits to single bit for North
intarray TyMzDirS       # map from combined direction bits to single bit for South
intarray TyMzDirE       # map from combined direction bits to single bit for East
intarray TyMzDirW       # map from combined direction bits to single bit for West
intarray TyTpBack1      # map from direction to first backtrack direction to check
intarray TyTpBack2      # map from direction to the 2nd backtrack direction to check
intarray TyTpDDir       # map from 5x5 grid to movement direction

#initialize one time vars and arrays for mazes and paths

TyMzConstInit::;
TyMzDirXInc[0]=0;
TyMzDirYInc[0]=0;     # not used no direction
TyMzDirXInc[1]=0;
TyMzDirYInc[1]=TyNeg1;  # north
TyMzDirXInc[2]=0;
TyMzDirYInc[2]=1;     # south
TyMzDirXInc[3]=1;
TyMzDirYInc[3]=0;     # east
TyMzDirXInc[4]=TyNeg1;
TyMzDirYInc[4]=0;    # west
# we also add the diagonals - used by TightPath
TyMzDirXInc[5]=1;
TyMzDirYInc[5]=TyNeg1;  # North East
TyMzDirXInc[6]=1;
TyMzDirYInc[6]=1;       # south east
TyMzDirXInc[7]=TyNeg1;
TyMzDirYInc[7]=1;       # south west
TyMzDirXInc[8]=TyNeg1;
TyMzDirYInc[8]=TyNeg1;  # north west
TyMzDir2Bit[0]=0;    # none
TyMzDir2Bit[1]=1;    # North is bit 0
TyMzDir2Bit[2]=2;    # South is bit 1
TyMzDir2Bit[3]=4;    # East is bit 2
TyMzDir2Bit[4]=8;    # West is bit 3
TyMzDirB2Bit[0]=0;    # none
TyMzDirB2Bit[1]=2;    # neighbor goes south for cell north
TyMzDirB2Bit[2]=1;    # neighbor goes north for cell south
TyMzDirB2Bit[3]=8;    # neighbor goes west for cell east
TyMzDirB2Bit[4]=4;    # neighbor goes east for cell west
TyMzDirN[0]=0;      # combined bits into 0,1 for N
TyMzDirN[1]=1;
TyMzDirN[2]=0;
TyMzDirN[3]=1;
TyMzDirN[4]=0;
TyMzDirN[5]=1;
TyMzDirN[6]=0;
TyMzDirN[7]=1;
TyMzDirN[8]=0;
TyMzDirN[9]=1;
TyMzDirN[10]=0;
TyMzDirN[11]=1;
TyMzDirN[12]=0;
TyMzDirN[13]=1;
TyMzDirN[14]=0;
TyMzDirN[15]=1;
TyMzDirS[0]=0;   # combined bits into 0,2 for S
TyMzDirS[1]=0;
TyMzDirS[2]=2;
TyMzDirS[3]=2;
TyMzDirS[4]=0;
TyMzDirS[5]=0;
TyMzDirS[6]=2;
TyMzDirS[7]=2;
TyMzDirS[8]=0;
TyMzDirS[9]=0;
TyMzDirS[10]=2;
TyMzDirS[11]=2;
TyMzDirS[12]=0;
TyMzDirS[13]=0;
TyMzDirS[14]=2;
TyMzDirS[15]=2;
TyMzDirE[0]=0;   # combined bits into 0,4 for E
TyMzDirE[1]=0;
TyMzDirE[2]=0;
TyMzDirE[3]=0;
TyMzDirE[4]=4;
TyMzDirE[5]=4;
TyMzDirE[6]=4;
TyMzDirE[7]=4;
TyMzDirE[8]=0;
TyMzDirE[9]=0;
TyMzDirE[10]=0;
TyMzDirE[11]=0;
TyMzDirE[12]=4;
TyMzDirE[13]=4;
TyMzDirE[14]=4;
TyMzDirE[15]=4;
TyMzDirW[0]=0;     # combined bits into 0,8 for W
TyMzDirW[1]=0;
TyMzDirW[2]=0;
TyMzDirW[3]=0;
TyMzDirW[4]=0;
TyMzDirW[5]=0;
TyMzDirW[6]=0;
TyMzDirW[7]=0;
TyMzDirW[8]=8;
TyMzDirW[9]=8;
TyMzDirW[10]=8;
TyMzDirW[11]=8;
TyMzDirW[12]=8;
TyMzDirW[13]=8;
TyMzDirW[14]=8;
TyMzDirW[15]=8;
# backtrack dirs are used by TightPath to make sure when backtracking, there is room to escape.
TyTpBack1[0]=0;
TyTpBack1[1]=3; # north checks E
TyTpBack1[2]=3; # south checks E
TyTpBack1[3]=1; # East check N
TyTpBack1[4]=1; # West check N
TyTpBack2[0]=0;
TyTpBack2[1]=4; # north checks W
TyTpBack2[2]=4; # south checks W
TyTpBack2[3]=2; # East check S
TyTpBack2[4]=2; # West check S
# tight path, when we are within the 5x5 grid of destination, use these directions to get to dest
TyTpDDir[0]=3;   #east
TyTpDDir[1]=2;   #south
TyTpDDir[2]=2;   #south
TyTpDDir[3]=2;   #south
TyTpDDir[4]=4;   #west
TyTpDDir[5]=3;   #east
TyTpDDir[6]=3;   #east
TyTpDDir[7]=2;   #south
TyTpDDir[8]=4;   #west
TyTpDDir[9]=4;   #west
TyTpDDir[10]=3;  #east
TyTpDDir[11]=3;  #east
TyTpDDir[12]=0;  #at destination
TyTpDDir[13]=4;  #west
TyTpDDir[14]=4;  #west
TyTpDDir[15]=3;  #east
TyTpDDir[16]=3;  #east
TyTpDDir[17]=1;  #north
TyTpDDir[18]=4;  #west
TyTpDDir[19]=4;  #west
TyTpDDir[20]=3;  #east
TyTpDDir[21]=1;  #north
TyTpDDir[22]=1;  #north
TyTpDDir[23]=1;  #north
TyTpDDir[24]=4;  #west

#mazes saves input parameters into these so it can continue while some other Tyab methods can be used.
# some are just private versions to avoid conflict with other routines
int TyMzSPX1=0
int TyMzSPY1=0
int TyMzSPX2=0
int TyMzSPY2=0
int TyMzSPX3=0
int TyMzSPY3=0
int TyMzSPX4=0
int TyMzSPY4=0
int TyMzSPX5=0  # not saved, internal use
int TyMzSPY5=0  # not saved, internal use
int TyMzSPX6=0  # not saved, internal use
int TyMzSPY6=0  # not saved, internal use
int TyMzSPI01=0
int TyMzSPI02=0
int TyMzSPI03=0
int TyMzSPI05=0
int TyMzSRI05=0 #not saved, internal use
int TyMzSRI06=0 #not saved, internal use
int TyMzSL01=0  #not saved, internal use
int TyMzSL02=0  #not saved, internal use
int TyMzSL03=0  #not saved, internal use
int TyMzSL05=0  #not saved, internal use
int TyMzSL06=0  #not saved, internal use
int TyMzSL07=0  #not saved, internal use
int TyMzSL08=0  #not saved, internal use
int TyMzSL09=0  #not saved, internal use
int TyMzSL10=0  #not saved, internal use

TyMzSaveVars::TyMzSPX1=PX1;
TyMzSPY1=PY1;
TyMzSPX2=PX2;
TyMzSPY2=PY2;
TyMzSPX3=PX3;
TyMzSPY3=PY3;
TyMzSPX4=PX4;
TyMzSPY4=PY4;
TyMzSPI01=PI01;
TyMzSPI02=PI02;
TyMzSPI03=PI03;
TyMzSPI05=PI05;

# clear out visited array

TyMzVarInit::TyMzSL01=0;    # now init visited array to 0. TyMzYsize and TyMzXsize must have been setup
TI01=0;
TyMz01IRowL;


TyMz01IRowL::TyMzSL02=0;
((TyMzXsize>=8))[TyMz02IColLg][TyMz02IColSm];
TyMzSL01+=1;
((TyMzSL01<TyMzYsize))TyMz01IRowL;


TyMz02IColSm::TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzSL02+=1;
((TyMzSL02<TyMzXsize))TyMz02IColSm;


TyMz02IColLg::TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzVisited[TI01]=0;    # cell not visited
TI01+=1;
TyMzSL02+=8;
TI02=TyMzXsize-TyMzSL02;
((TI02>=8))[TyMz02IColLg][TyMz02IColSm];

#.##########################  TyabMaze ######################################
# the maze generation. Caller provides the usable space inside of the maze, we do not change/modify any cells outside of maze
# thus this can be used to generate a submaze inside an existing map and entrances/exits are setup by the caller as ground or
# drillable cells.  Caller defines the size of the path and the size of the internal cells used.
# this does not directly modify the map, it does modify TyMapTiles. Use TyabDrawRect to show the results
# on input:
#   PX1: The starting Y (row) for the maze.
#   PY1: The starting X (column) for the maze
#   PY2: Ending row for use by the maze.
#   PX2: Ending column for use by the maze.
#   PI01: path size. Either 1 or 2. Cannot be larger than cell size. If same as cell size, everything is filled (no maze)
#   PI02: cell size. Either 1, 2, 3, 4 (1 can be used internally for paths)
#   PI03: TileID for walls
#   PI04: number of path types in PIA01 and PIA02
#   PIA01: intarray: each item is the path type ID.
#   PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01. Each value is 0.1%
#                    The sum of all of the odds should be 1000. If under 1000, tDirtRegular will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.

# command queue deserial entry
TyIMaze::TyabBusy=0;  # should not be necessary but does not hurt
TyabIMaze;            # start normal maze recallable logic

# called from TyabTimer to continue where it left off
TyabIMaze::((TyabBusy==0))[TyMz0][TyMzContinue12];  #start new or continue

# - calling with either state 1 = generation, or 2 = drawing
TyMzContinue12::((TyabBusy==1))[TyMzBusy1][TyMzBusy2];

# - continuing to generate. 
TyMzBusy1::TyMzGenerateBegin;
((TyabBusy==0))TyabBusy=2;   # finished generation, move to drawing
((TyabBusy==2))TyMzDrawInit;  # starting draw, just do init, next time we draw

# - continue with drawing
TyMzBusy2::((TyabBusy==2))TyMzUpdateMap;


TyMz0::TyMzSaveVars;  # copy input, use own vars
TyMzStartNew;    # start a new one
TyMzAddRndCell;             # start from a random cell
TyMzGenerateBegin;          # run the maze engine, build visible and directions
((TyabBusy!=0))return;      # not done, so return
TyMzDrawInit;      #done get ready to draw
TyMzUpdateMap;     #done now draw

# this is callable by one of the path routines.

TyMzStartNew::TyMzInit;                    # compute our internal cell space
TyMzSize=TyMzYsize*TyMzXsize; # number of maze cells
TyMzSizeSet=0;              # no partial paths yet
TyMzVarInit;                # setup TyMzVisited, and directions

# start off with a random cell

TyMzAddRndCell::TI03=TyMzYsize-1;
TI01=random(0)(TI03);
TI03=TyMzXsize-1;
TI02=random(0)(TI03);    # pick random cell (row,col)
TI03=TI01*TyMzXsize;
TI03+=TI02;              # random cell index
TyMzVisited[TI03]=16;    # 16 is visited but no directions
TyMzYset[0]=TI01;        # add to mazeCollection
TyMzXset[0]=TI02;        # add to mazeCollection
TyMzSizeSet=1;           # now in collection

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyMzGenerateBegin::TyabBusy=0;   # assume we finish
TyMzSL03=50;                     # max number of loops in generate
TyMzGenerate;                    # build maze
((TyMzSizeSet>0))TyabBusy=1;     # set that we need continue

# each maze cell is either 2x2, 3x3, 4x4 map tiles.

TyMzInit::TyMzMapScale=TyMzSPI02;
TyMzfMap2Cell=1.0//TyMzMapScale;
TI01=TyMzSPY2-TyMzSPY1;
TI01+=1;          #height
TI01+=TyMzMapScale;
TI01-=1;          #allow final cell on bottom even if partially clipped
TF01=TI01;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzYsize=TF01;   # cell height
TI01=TyMzSPX2-TyMzSPX1;
TI01+=1;          #width
TI01+=TyMzMapScale;
TI01-=1;          #allow final cell on right even if partially clipped
TF01=TI01;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    #round off error
TyMzXsize=TF01;   # cell width

#### maze generation engine. Loop while anything in collection On entry we have something

TyMzGenerate::TI04=TyMzSizeSet-1;
((random(0)(1)==0))TI04=random(0)(TI04);    # get either random cell or last one 50/50 oods
TI02=TyMzYset[TI04];     # row
TI03=TyMzXset[TI04];     # col
TyMzSizeNeighbors=0;    # start off with no neighbors
TI05=1;      # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
((TI06>=0))TyMzBNChkDirVis; #not outside, see its been visited
TI05=2;      # check south
TI06=TI02+1;        #row of neighbor
#TI07=TI03;          #col of neighbor
((TI06<TyMzYsize))TyMzBNChkDirVis; #not outside, see its been visited
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
((TI07<TyMzXsize))TyMzBNChkDirVis; #not outside, see its been visited
TI05=4;      # check west
#TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
((TI07>=0))TyMzBNChkDirVis; #not outside, see its been visited
((TyMzSizeNeighbors>0))[TyMz05CP2N][TyMz06RemoveCell];
TyMzSL03-=1;                   #have to keep track of iterations to avoid script limits
((TyMzSizeSet<=0))return;      # collection is empty so exit
((TyMzSL03>0))TyMzGenerate;    #loop until we are done or must stop

###### remove cell from collection
#input
#  TI04: collection index of cell to remove

TyMz06RemoveCell::TyMzSizeSet-=1;       # removing the last one by copying the last one to where cell to remove is.
TyMzYset[TI04]=TyMzYset[TyMzSizeSet];   # move last to our position
TyMzXset[TI04]=TyMzXset[TyMzSizeSet];   # move last to our position

# TI05=dir (1-4) TI06=row, TI07=col neighbor. 

TyMzBNChkDirVis::TI08=TI06*TyMzXsize;
TI08+=TI07;                 #index of neighbor
TI01=TyMzVisited[TI08];
TyMzNeighbors[TyMzSizeNeighbors]=TI05;  #assume we will add it
((TI01==0))TyMzSizeNeighbors+=1;       # and add for real if its not already processed

### we have some unvisisted neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell with direction to neighbor, and set neighbor direction back to us. Both cells are thus made visited.
# TI02, TI03: cell row,col:  TI04 collection index of cell

TyMz05CP2N::TI01=TyMzSizeNeighbors-1;
TI05=TyMzNeighbors[random(0)(TI01)];     # get direction we picked
# set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TI01=TyMzVisited[TI06];       #cell valid directions
((TI01==16))TI01=0;           #first time init, clear so no directions
TyMzVisited[TI06]=TI01+TyMzDir2Bit[TI05];       #direction added
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]+=TyMzDirB2Bit[TI05];       #neighbor dir back to cell

##### debug out of maze directions

#TyMzDBGDirs::TS01="";
#TI02=0;
#TyMzDBGDirsO;
#msg:TS01;


#TyMzDBGDirsO::TI03=0;
#TyMzDBGDirsI;
#TI02+=1;
#((TI02>0))TyMzDBGDirsO;


#TyMzDBGDirsI::TyMzDBGDirsCell;
#TI03+=1;
#((TI03>0))TyMzDBGDirsI;

#input TI02: row, TI03: col

#TyMzDBGDirsCell::TI04=TI02*TyMzXsize;
#TI04+=TI03;
#TI01=TyMzVisited[TI04];
#TS01+="[";
#TS01+=TI04;
#TS01+=":";
#TS01+=TyMzDirN[TI01];  #N
#TS01+=" ";
#TS01+=TyMzDirS[TI01];  #S
#TS01+=" ";
#TS01+=TyMzDirE[TI01];  #E
#TS01+=" ";
#TS01+=TyMzDirW[TI01];  #W
#TS01+="] ";

# modifying the map to include the maze. All of the passed in values are still available.
# note: Since map is filled in from UL towards LR, the left side (west) and top side(north) cells will be against
#       the border allowing easy connections to rest of map. But right side (east) and bottom (south) may not
#       be on the border (if maze is smaller than tiles, it may not align perfectly).
#       Thus we always extend paths east from east most cells and south for south most cells to the maze boundary.

TyMzUpdateMap::((TyabBusy==0))TyMzDrawInit;   # first time, start on first row
TI01=TyMzVisited[0];
((TI01==16))TyMzVisited[0]=0;     # single cell maze case
TyabBusy=0; #assume we finish
TyMzSL10=50;    #we will stop on next row after this many cells
TyMz19MMRL;
((TyMzSL01<TyMzYsize))TyabBusy=2;  # we are not done drawing


TyMzDrawInit::TyMzSL01=0;   #start on first row


TyMz19MMRL::TyMzSL02=0;          #col
TyMz20MMCL;
TyMzSL01+=1;
TI01=1;
((TyMzSL10<=0))TI01=0;
((TyMzSL01>=TyMzYsize))TI01=0;
((TI01==1))TyMz19MMRL;


# every cell in the maze column

TyMz20MMCL::TyMzSL10-=1;    #doing a cell - count for too many
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;                       # get maze cell index
TI03=TyMzSL01*TyMzMapScale;
TI03+=TyMzSPY1;                       # map row for this cell
TI04=TyMzSL02*TyMzMapScale;
TI04+=TyMzSPX1;
#inline TyMzFillCell
# TyMzSL01, TyMzSL02, cell row, TI02: cell index,  TI03, TI04. map row,col
#every cell has UL, the cell itself path UR is either wall or path. LL is wall or path, LR is wall. Some areas are null depending on cell size and path size
TI01=TyMzVisited[TI02]; # get directions
RI02=TyMzDirS[TI01];    # do we go south
RI03=TyMzDirE[TI01];    # do we go east
# first do the UL cell - its a path
TI09=1;             # path
TyMzSL05=0;              #starting row,col offset values
TyMzSL06=TyMzSPI01;           # path size
TyMzSL07=TyMzSPI01;
#inline TyMzFillRect
TyMzSL08=0;              # row offset
TyMzFRRL;           #start Y loops
#end TyMzFillRect
#now look at UR, either path or wall
TyMzSL05=TyMzSPI01;           # now on UR subsection
TyMzSL06=TyMzSPI01;
TyMzSL07=TyMzMapScale;
TI09=RI03;           # either path or wall going east
TI01=TyMzXsize-1;
((TyMzSL02>=TI01))TI09=1;    #if right most col, we path to the east to connect to map
#inline TyMzFillRect
TyMzSL08=0;              #row offset
TyMzFRRL;           #start Y loops
#end TyMzFillRect
#now look at LL, either path or wall
TyMzSL05=0;
TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzSPI01;
TI09=RI02;             # either path or wall going south
TI01=TyMzYsize-1;
((TyMzSL01>=TI01))TI09=1;    #if bottom most row we path to the south to connect to map
#inline TyMzFillRect
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzSL06))TI01=0;           #outside
((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
((TI01==1))TyMzFRRL;           #start Y loops
#end TyMzFillRect
#final is LR which is wall
TyMzSL05=TyMzSPI01;
#TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzMapScale;
TI09=0;    #wall
#inline TyMzFillRect
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzSL06))TI01=0;           #outside
((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
((TI01==1))TyMzFRRL;           #start Y loops
#end TyMzFillRect
#endif TyMzFillCell
TyMzSL02+=1;
((TyMzSL02<TyMzXsize))TyMz20MMCL;     # all maze columns for this row

# fill in cell starting at TI03,TI04. using offset range [L04,TyMzSL05] -> (TyMzSL06,TyMzSL07). Clamp to cell size.
# if TI09=1, get random tile, else use PI04.
# deal with clipping and even if nothing to do

#TyMzFillRect::;  
#TyMzSL08=L04;
#TI01=1;   #assume ok to y loop
#((TyMzSL08>=TyMzSL06))TI01=0;           #outside
#((TyMzSL08>=TyMzMapScale))TI01=0;  #outside
#((TI01==1))TyMzFRRL;           #start Y loops


TyMzFRRL::TyMzSL09=TyMzSL05;               # starting col offset
TI05=TI03+TyMzSL08;          #tile row
TI01=1;                # assume ok to run columns
((TyMzSL09>=TyMzSL07))TI01=0;         # outside
((TyMzSL09>=TyMzMapScale))TI01=0; # outside
((TI05>TyMzSPY2))TI01=0;           #row outside
((TI01==1))TyMzFRRC;          # inside on Row, process columns
TyMzSL08+=1;
((TyMzSL08>=TyMzSL06))return;      #outside
((TyMzSL08<TyMzMapScale))TyMzFRRL;   # keep looping while inside


TyMzFRRC::((TI09>0))[TyProbTile][RI01=TyMzSPI03];   #either path or wall tile
TI06=TI04+TyMzSL09;          #tile col
TI01=TI05-TynY1;
TI01*=TynXtiles;
TI01+=TI06;
TI01-=TynX1;              # compute index
((TI06<=TyMzSPX2))TyMapTiles[TI01]=RI01;   #draw if col is within range
TyMzSL09+=1;
((TyMzSL09>=TyMzSL07))return;       #outside
((TyMzSL09<TyMzMapScale))TyMzFRRC;  #keep looping while not outside

### convert map row, col to the maze call row, col
#input
#  TI02 map row
#  TI03 map col
#output
#  TI02 maze cell row
#  TI03 maze cell col

#TyMzMap2Cell::TI01=TI02-TyMzSPY1;          # map offset to range Corner
#TF01=TI01;
#TF01*=TyMzfMap2Cell;
#TF01+=0.00001;    # round off error
#TI02=TF01;
#TI01=TI03-TyMzSPX1;          # map offset to range Corner
#TF01=TI01;
#TF01*=TyMzfMap2Cell;
#TF01+=0.00001;    # round off error
#TI03=TF01;

#.############################ TyabPath ##################
# generates a random path. Between the two points. Is constrained by the provided rectangle.
# internally we are generating a maze. We run the recursive backtracker from the start point
# and it builds internally the maze visited bits just like a maze but the key is - we exit
# the generation phase once we hit the destination cell. The path is then cells in the collection.
# start and end do not need to be on the border generating an island maze. You may also include
# obstructions to stay away from. It is caller responsiblity to ensure that obstructions do not
# block a valid path , make sure to take into account PI02 cell size.
# TODO - add in cells as obstacles to go around!
# TODO - do we fill-in around the path or just make it in an existing area
#input:
# PX1, PY1    upper left starting bounding region
# PX2, PY2    lower right Ending bounding region
# PX3, PY3    starting point of path
# PX4, PY4    ending point of path
# PI01        size of path (1,2) must be smaller than PI02
# PI02        cell size (1,2,3,4)
# PI04        number of entries in IAP01
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01
#                    The sum of all of the odds should be 0-1000. If under 1000, tDirt will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.
# PI05        number of obstructions
# PIA03
# PIA04.      Each is a row, col (PIA03[i],PIA04[i]) in map coords of an obstruction to not generate a path through

# command queue entry
TyIPath::TyabBusy=0;    # should not be needed but ensures starting a new one
TyabIPath;

# TyabTimer entry
TyabIPath::((TyabBusy==0))[TyRp0][TyRpContinue34];  #start new or continue

# convert PX3, PY3 to starting cell row,col saved as first in collection
# convert PX4, PY4 to starting cell row,col in PY6, PX6
# - starting a new random path
TyRp0::TyMzSaveVars;   # copy input, use own vars
TyMzStartNew;   # init maze stuff since we use it
TyRpStartNew;
TyRpGenerateBegin;  # run the maze engine, build visible and directions
((TyabBusy==0))TyRpUpdateMap;   # if we are finished, draw it


TyRpStartNew::;
#inline TyMzMap2Cell
TF01=TyMzSPY3-TyMzSPY1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzYset[0]=TF01;      # start path from start point
TF01=TyMzSPX3-TyMzSPX1;          # map offset to range Corner
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzXset[0]=TF01;     #start path from start point
#end inline TyMzMap2Cell
#inline TyMzMap2Cell
TF01=TyMzSPY4-TyMzSPY1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzSPY6=TF01;
TF01=TyMzSPX4-TyMzSPX1;
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TyMzSPX6=TF01;
#end inline TyMzMap2Cell
TyMzSizeSet=1;  # preloading the start cell. Visited is set to 0 via init
((TyMzSPI05>0))TyRpObstructions;   # fill in obstructions as already visited cells.


TyRpObstructions::TyMzSL01=0;
TyRpLObstruct;


TyRpLObstruct::TF01=PIA03[TyMzSL01]-TyMzSPY1;   # map row
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TI02=TF01;        # cell row
TF01=PIA04[TyMzSL01]-TyMzSPX1;   # map col
TF01*=TyMzfMap2Cell;
TF01+=0.00001;    # round off error
TI03=TF01;        # now row,col in maze coords
TI01=1;                     #assume in range
((TI02<0))TI01=0;           # outside
((TI02>=TyMzYsize))TI01=0;  # outside
((TI03<0))TI01=0;           # outside
((TI03>=TyMzXsize))TI01=0;  # outside
((TI01==1))TyRpLObstructAdd;  #add if in range
TyMzSL01+=1;
((TyMzSL01<TyMzSPI05))TyRpLObstruct;

TyRpLObstructAdd::TI01=TI02*TyMzXsize;
TI01+=TI03;
TyMzVisited[TI01]=TyNeg1;  # -1 means already visited (ok to use -1 in this case since they are excluded from path)

# - calling with either state 3 = generation, or 4 = drawing
TyRpContinue34::((TyabBusy==3))[TyRpBusy3][TyRpBusy4];

# - continuing to generate. 
TyRpBusy3::TyRpGenerateBegin;
((TyabBusy==0))TyabBusy=4;   # finished generation, move to drawing
((TyabBusy==4))TyRpDrawInit;  # starting draw, just do init, next time we draw

# - continue with drawing
TyRpBusy4::((TyabBusy==4))TyRpUpdateMap;

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyRpGenerateBegin::TyMzSRI05=0;                 # solution not found
TyMzSL03=50;               # max number of loops in generate
TI04=TyMzSizeSet-1;    # get the last cell (using backtracker)
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TI01=0;                # assume solution found
((TI02!=TyMzSPY6))TI01=1;
((TI03!=TyMzSPX6))TI01=1;   #check to see if start == end
TyabBusy=0;     # assume we finish
((TI01==1))TyRpGenerate;  # not, find path, else found it
((TyMzSRI05==0))TyabBusy=3; # set that we need continue

#### path generation engine. Loop until we hit the end point
# on entry at every loop. 
# TI02 cell row
# TI03 cell col

TyRpGenerate::TyMzSizeNeighbors=0;   # start off with no neighbors
TI05=1;         # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
((TI06>=0))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=2;     # check south
TI06=TI02+1;        #row of neighbor
#TI07=TI03;          #col of neighbor
((TI06<TyMzYsize))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
((TI07<TyMzXsize))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
TI05=4;     # check west
#TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
((TI07>=0))TyMzBNChkDirVis; #not outside, see its been visited (use maze version)
((TyMzSizeNeighbors>0))[TyRpPickNext][TyMzSizeSet-=1];   # process neighbor or remove this cell
TI04=TyMzSizeSet-1;    # get the last cell
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TyMzSRI05=1;                # assume solution found
((TI02!=TyMzSPY6))TyMzSRI05=0;
((TI03!=TyMzSPX6))TyMzSRI05=0;   #check to see if start == end
((TyMzSRI05==1))return;      #found solution, need to exit
TyMzSL03-=1;                #have to keep track of iterations to avoid script limits
((TyMzSL03>0))TyRpGenerate;    #loop until we are done or must stop

### we have some unvisited neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell only with the direction bit we are going. Set neighbor as the maze does
# TI02, TI03: cell row,col:  TI04 collection index of cell

TyRpPickNext::TI01=TyMzSizeNeighbors-1;
TI01=random(0)(TI01);         # pick a random neighbor
TI05=TyMzNeighbors[TI01];     # get direction we picked
# set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TyMzVisited[TI06]=TyMzDir2Bit[TI05];       #direction added
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]=TyMzDirB2Bit[TI05];       #back direction

# - get ready to draw from beginning
TyRpDrawInit::TI03=TyMzSizeSet-1;
TyMzSL01=TyMzYset[TI03];   #last cell if on bottom or right needs connecting paths to map
TyMzSL02=TyMzXset[TI03];
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI01=0;
TI03=TyMzYsize-1;
((TyMzSL01==TI03))TyMzVisited[TI02]+=2;   # last cell on bottom, needs path south
TI04=TyMzXsize-1;
((TyMzSL02==TI04))TyMzVisited[TI02]+=4;   # last cell on bottom, needs path east
#first cell if on bottom or right needs connecting paths to map
TyMzSL01=TyMzYset[0];
TyMzSL02=TyMzXset[0];
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI01=0;
TI03=TyMzYsize-1;
TyMzSRI05=0;                 #will have last direction from prior cell so we can make back paths
TyMzSRI06=0;
((TyMzSL01==TI03))TyMzSRI05=1;   # first cell on bottom, needs path south
((TyMzSPI01==TyMzSPI02))TyMzSRI05=0;  # if path size == cell size, we don't need any directions
TI04=TyMzXsize-1;
((TyMzSL02==TI04))TyMzSRI06=1;   # first cell on bottom, needs path east
((TyMzSPI01==TyMzSPI02))TyMzSRI06=0;  # if path size == cell size, we don't need any directions
TyMzSL03=0;          # collection index

# we have the path, it is in the collection. For each step, the visited gives direction to next one.

TyRpUpdateMap::((TyabBusy==0))TyRpDrawInit;
TyMzSL10=100;       #number of cells to draw
TyRp20MMCL;    # start/restart drawing

# TyMzSL03 loops for every cell in the collection. TyMzSRI05 if S path needed, TyMzSRI06 if east path needed

TyRp20MMCL::TyMzSL01=TyMzYset[TyMzSL03];     # row
TyMzSL02=TyMzXset[TyMzSL03];     # cell
TI02=TyMzSL01*TyMzXsize;
TI02+=TyMzSL02;             # get maze cell index
TI03=TyMzSL01*TyMzMapScale;
TI03+=TyMzSPY1;             #map row
TI04=TyMzSL02*TyMzMapScale;
TI04+=TyMzSPX1;             # map col
TI01=TyMzVisited[TI02]; # get direction to fill
((TyMzSPI01==TyMzSPI02))TI01=0;  # if path size == cell size, we don't need any directions
RI01=TyMzDirN[TI01];
RI02=TyMzDirS[TI01];
RI03=TyMzDirE[TI01];
RI04=TyMzDirW[TI01];
RI02+=TyMzSRI05;             # add in possible S backtrack path
RI03+=TyMzSRI06;             # add in possible E backtrack path
((RI01>0))[TyMzSRI05=1][TyMzSRI05=0];      # we are going north, next cell needs a path south
((RI04>0))[TyMzSRI06=1][TyMzSRI06=0];      # we are going west, next cell needs path east
# TyMzSL01, TyMzSL02, cell row, TI02: cell index,  TI03, TI04. map row,col
#every cell has UL, the cell itself path UR is either wall or path. LL is wall or path, LR is wall. Some areas are null depending on cell size and path size
# first do the UL cell - its a path
TI09=1;             # path
TyMzSL05=0;              # starting row,col offset values
TyMzSL06=TyMzSPI01;           # path size
TyMzSL07=TyMzSPI01;
TyMzSL08=0;              # row offset
TyMzFRRL;           # start Y loops
#see if we need a path east
#TI09=1;             #path 
TyMzSL05=TyMzSPI01;           # now on UR subsection
TyMzSL06=TyMzSPI01;
TyMzSL07=TyMzMapScale;
TyMzSL08=0;              #row offset
((RI03>0))TyMzFRRL;       #start Y loops
#see if we need a path S
#TI09=1;             #path 
TyMzSL05=0;
TyMzSL06=TyMzMapScale;
TyMzSL07=TyMzSPI01;
TyMzSL08=TyMzSPI01;
TI01=1;   #assume ok to y loop
((TyMzSL08>=TyMzMapScale))TI01=0;   #outside
((RI02==0))TI01=0;
((TI01==1))TyMzFRRL;           #start Y loops
TyMzSL03+=1;
TI01=1;   #assume not done
((TyMzSL03>=TyMzSizeSet))TI01=0;   #stop
TyMzSL10-=1;
((TyMzSL10<=0))TI01=0;
((TI01==1))TyRp20MMCL;     # keep going
((TyMzSL03>=TyMzSizeSet))[TyabBusy=0][TyabBusy=4];  # either done or need another call


#.############################ TyabTightPath ##################
# generates a random path. Between the two points. Is constrained by the provided rectangle.
# internally use the same type of logic as the path method, but we have more complex
# rules defining what direction we can go and we are fixed to a cell and path sizes of 1.
# This results in variable sized cells, so we are no longer generating maze.
# from the start point random directions are chosen and the path grows until we get
# near the destination. Once near the destination, we suck in the path to the destination based on
# fixed rules. If a dead end is hit, we back up forgetting those cells so they can be used again.
# Thus the path can whip around randomly until we get lucky to be near the destination.
# there are checks to try and detect paths that backtrack with no way to get out to help it
# find a solution sooner.
# because we are not making an internal maze, processing time is random and it can take some time.
# Once the destination is found, the path is the cells in the collection.
# start and end do not need to be on the border generating an island maze. You may also include
# obstructions to stay away from. It is caller responsiblity to ensure that obstructions do not
# block a valid path.
#input:
# PX1, PY1    upper left starting bounding region
# PX2, PY2    lower right Ending bounding region
# PX3, PY3    starting point of path
# PX4, PY4    ending point of path
# PI04        number of entries in IAP01
# PIA01: intarray: each item is the path type ID.
# PIA02: intarray: each item is the odds 0-1000 of using that path type ID from PIA01
#                    The sum of all of the odds should be 0-1000. If under 1000, tDirt will fill in remaining.
#                    If sum is over 1000, those over the 1000 sum will not be possible to be generated.
# PI05        number of obstructions
# PIA03
# PIA04.      Each is a row, col (PIA03[i],PIA04[i]) in map coords of an obstruction to not generate a path through

#command queue entry
TyITightPath::TyabBusy=0;
TyabITightPath;

#TyabTimer entry
TyabITightPath::((TyabBusy==0))[TyTp0][TyTpContinue5];  #start new or continue

# convert PX3, PY3 to starting cell row,col saved as first in collection
# convert PX4, PY4 to starting cell row,col in PY6, PX6
# - starting a new random path
TyTp0::TyMzSaveVars;   # save input vars, use own vars
TyMzSPI01=1;  # force to 1 path width
TyMzSPI02=1;  # force to 1 cell size
TyMzStartNew;   # init maze stuff since we use it
TyRpStartNew;      # same init as path
TyTpGenerateBegin;  # run the maze engine, build visible and directions
((TyabBusy==0))TyTpDraw;   # if we are finished, draw it

# - calling with state 5
TyTpContinue5::((TyabBusy==5))TyTpBusy5;

# - continuing to generate. 
TyTpBusy5::TyTpGenerateBegin;
((TyabBusy==0))TyTpDraw;   # finished generation, move to drawing - using path draw

# in case we have a large maze, we run it inside of a loop to work around the script limit of nested events

TyTpGenerateBegin::TyMzSL03=50; # max number of loops in generate
TI04=TyMzSizeSet-1;    # get the last cell (using backtracker)
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TI01=0;                # assume solution found
((TI02!=TyMzSPY6))TI01=1;
((TI03!=TyMzSPX6))TI01=1;   #check to see if start == end
TyabBusy=0;     # assume we finish
TyMzSRI05=1;         # assume finish
((TI01==1))TyTpGenerate;  # not, find path, else found it
((TyMzSRI05==0))TyabBusy=5; # set that we need continue


#for tight path, we are tracking in TyMzVisited the dirs we have tried so far
#### path generation engine. Loop until we hit the end point
# on entry at every loop. 
# TI02 cell row
# TI03 cell col

TyTpGenerate::TI04=TI02*TyMzXsize;
TI04+=TI03;         # cell index
TyMzSizeNeighbors=0;   # start off with no neighbors
TI05=1;         # check North
TI06=TI02-1;         #row of neighbor
TI07=TI03;           #col of neighbor
TI04=TyMzVisited[TI04];  # bits we have tried (also has back connection so we don't try that dir)
TI01=TyMzDirN[TI04]; # if non-zero we have tried this dir
((TI06<0))TI01=1;    # outside
((TI01==0))TyTpChkDirVis; #north not outside and north has not been already tried
TI05=2;     # check south
TI06=TI02+1;        #row of neighbor
#TI07=TI03;          #col of neighbor
TI01=TyMzDirS[TI04]; # if non-zero we have gone this dir
((TI06>=TyMzYsize))TI01=1; #outside
((TI01==0))TyTpChkDirVis; #south not outside and south has not been already tried
TI05=3;      # check east
TI06=TI02;           #row of neighbor
TI07=TI03+1;         #col of neighbor
TI01=TyMzDirE[TI04]; # if non-zero we have gone this dir
((TI07>=TyMzXsize))TI01=1; #outside
((TI01==0))TyTpChkDirVis; #east not outside and east has not been already tried
TI05=4;     # check west
#TI06=TI02;          #row of neighbor
TI07=TI03-1;        #col of neighbor
TI01=TyMzDirW[TI04]; # if non-zero we have gone this dir
((TI07<0))TI01=1;   #outside
((TI01==0))TyTpChkDirVis; #west not outside and west has not been already tried
((TyMzSizeNeighbors>0))[TyTpPickNext][TyTpRemoveCell];   # process neighbor or remove this cell
TI04=TyMzSizeSet-1;    # get the last cell
((TI04<0))TI04=0;      #don't crash if we run out of cells
TI02=TyMzYset[TI04];   # row
TI03=TyMzXset[TI04];   # col
TyTpDestAttract;       # are we withing the 5x5 grid of destination (or at dest)
((TyMzSizeSet<=0))TyMzSRI05=1;   #abort, we have run out of cells (solution never found)
((TyMzSRI05==1))return;          #found solution, need to exit
TyMzSL03-=1;                     #have to keep track of iterations to avoid script limits
((TyMzSL03>0))TyTpGenerate;    #loop until we are done or must stop


#destination will draw in if within 2 cells
#TI02,TI03 current cell
#TyMzSRI05 0=not drawn in or not at dest. =1 draw in.

TyTpDestAttract::TyMzSRI05=0;
TI04=TI02-TyMzSPY6;
TI04+=2;     # scale 0-4 if in range
TI05=TI03-TyMzSPX6;
TI05+=2;     # scale 0-4 if in range
((TI04<0))return;
((TI04>4))return;
((TI05<0))return;
((TI05>4))return;
TyMzSRI05=1;  # have solution
TyTpAtDest;


#TI04,TI05 now define a 5x5 array of positions with the dest in the center
#no checks for obstructions
TyTpAtDest::TI06=TI04*5;
TI06+=TI05;
((TI06!=12))TyTpMove2Dest;  # loop until we hit dest


TyTpMove2Dest::TI01=TyTpDDir[TI06];    #get movment dir
TI02+=TyMzDirYInc[TI01];
TI03+=TyMzDirXInc[TI01];
TyMzYset[TyMzSizeSet]=TI02;
TyMzXset[TyMzSizeSet]=TI03;
TyMzSizeSet+=1;     # note we don't have to set any visited bits for tight path draw
TI04+=TyMzDirYInc[TI01];
TI05+=TyMzDirXInc[TI01];
TyTpAtDest;

#tight path when we remove a cell since this path ran into a dead end, we must forget its connections
# since the maze is now changing, it may go back far enough so that cell is no longer a dead end.
# we remove multiple cells once we have more than 20 in length to get out faster. TODO do we need to make this configurable?

TyTpRemoveCell::((TyMzSizeSet>20))[TyTpRemoveMore][TyTpRemoveOne];

TyTpRemoveOne::;
TI01=TyMzSizeSet-1;
TI04=TyMzYset[TI01]*TyMzXsize;
TI04+=TyMzXset[TI01];
TyMzVisited[TI04]=0;   #forget that cells connections since maze is changing
TyMzSizeSet-=1;        #remove cell
#TI02=TyMzYset[TI01]+TyMzSPY1;   #debug
#TI03=TyMzXset[TI01]+TyMzSPX1;   #debug
#place:TI02,TI03,$(tGround);   #debug


TyTpRemoveMore::TF01=TyMzSizeSet;
TF01*=0.2;              # going back 1/5 of the way. TODO do we need to make this configurable?
TI05=TF01;
TyTpRemoveMoreL;

TyTpRemoveMoreL::TyTpRemoveOne;
TI05-=1;
((TI05>0))TyTpRemoveMoreL;

# tight path has far more complex logic to see if a direction is viable. Here are the rules:
# must not be out of range (already checked in the main loop)
# must not be in use (TyMzVisited entry is 0) same as path/maze
# new for tight path:
#   In same direction 2 cells must be free or wall/obstruction
#   In both 90's, 2 cells must be free or wall/obstruction
#   if backtracking, one of the two 90's must also be free and inside for 3rd cell.
#   diagonals cannot be visited unless they are cell-2 (zigzag path)  TODO
#   2nd diagonals cannot be visited
# do not change TI02, TI03, TI04, TI05, TI06, TI07

TyTpChkDirVis::TI01=TI06*TyMzXsize;
TI01+=TI07;                 #index of neighbor
((TyMzVisited[TI01]==0))TyTpUnVisted;

# next cell same dir must also be open or obstruction if still in range

TyTpUnVisted::TI08=TI05;      # same dir, check two cells
TI01=1;                   # assume not valid
TyTpChkDirection;
TI08=TyTpBack1[TI05];     #get one of the 90's
((TI01==1))TyTpChkDirection;
TI08=TyTpBack2[TI05];     #get other 90's
((TI01==1))TyTpChkDirection;
#now we check the diagonals. We do allow cell-2 to be on a diagonal for zigzag
TI08=5;     # North west
((TI01==1))TyTpChkDDirection;
TI08=6;     # South West
((TI01==1))TyTpChkDDirection;
TI08=7;     # South East
((TI01==1))TyTpChkDDirection;
TI08=8;     # North East
((TI01==1))TyTpChkDDirection;
TyMzNeighbors[TyMzSizeNeighbors]=TI05;  # in case we add
((TI01==1))TyMzSizeNeighbors+=1;  #TyTpChkBacktrack;  #TODO backtracking checks not done, are they really necessary and does it prevent some interesting paths? Its alot of code so it has to be worth it

#neighbor cell in TI06,TI07. TI08 is dir to check. Two cells from this cell must be unvisited or wall/obstruction
#return TI01=0 visited. 1 = wall/obstruction/unvisted

TyTpChkDirection::TI09=TI06+TyMzDirYInc[TI08];
TI10=TI07+TyMzDirXInc[TI08];
TyTpChkWallObstruct;
TI09+=TyMzDirYInc[TI08];
TI10+=TyMzDirXInc[TI08];
((TI01==1))TyTpChkWallObstruct;

# return TI01 = 0 visited. TI01=unvisited or wall or obstruction. TI09,TI10 cell

TyTpChkWallObstruct::((TI09<0))return;
((TI09>=TyMzYsize))return;
((TI10<0))return;
((TI10<TyMzXsize))TyTpChkWOInside;    # cell is inside


TyTpChkWOInside::TI01=TI09*TyMzXsize;
TI01+=TI10;
((TyMzVisited[TI01]<=0))[TI01=1][TI01=0];

# diagonal check. We do allow cell-2 to be on the diagonal for zigzag path

#return TI01=0 visited. 1 = wall/obstruction/unvisted
TyTpChkDDirection::TI09=TI06+TyMzDirYInc[TI08];
TI10=TI07+TyMzDirXInc[TI08];
TI11=TyMzSizeSet-2;    # this is the 2nd prior cell
((TI11<0))[TyTpChkWallObstruct][TyTpDiag1];

# see if 2nd prior cell is the corner, if so, its good.
TyTpDiag1::((TI09==TyMzYset[TI11]))return;
((TI10!=TyMzXset[TI11]))TyTpChkWallObstruct;  # 2nd prior cell is not this corner, continue normal tests


#TODO I need to rethink backtracking - what does it really mean?
# determine if backtracking, if not add the cell. If so, one of the 90's must be open and inside for 3 cells (have to have a way to get back out)

#TyTpChBacktrack::TI08=TyMzSPY6-TI06;          # row distance for neighbor
#((TI08<0))TI08=0-TI08;  # abs
#TI09=TyMzSPY6-TI02;          # row distance for cell
#((TI09<0))TI09=0-TI09;  # abs
#TI01=0;
#((TI08>TI09))TI01=1;    # neighbor is farther away in row - we are backtracking
#TI08=TyMzSPX6-TI07;          # col distance for neighbor
#((TI08<0))TI08=0-TI08;  # abs
#TI09=TyMzSPY6-TI03;          # col distance for cell 
#((TI09<0))TI09=0-TI09;  # abs
#((TI08>TI09))TI01=1;    # neighbor is farther away in col - we are backtracking
#TyMzNeighbors[TyMzSizeNeighbors]=TI05;  # in case we add
#((TI01==1))[TyTpBackTRK][TyMzSizeNeighbors+=1];  # we are doing a backtrack if not, add this direction


#TyTpBackTRK::TI08=TyTpBack1[TI05];   # first back dir
#TyMzCheckBack;
#TI08=TyTpBack2[TI05];
#((TI01==0))TyTpCheckBack;   # try the other dir
#((TI01==1))TyMzSizeNeighbors+=1;  # one of the backtrack tests passes, add the direction


#TyTpN1Inside::TI10=TI08*TyMzXSize;
#TI10+=TI09;
#((TyMzVisited[TI10]<=0))TyTpN1Inside1;  # not visited or obstruction ok


#TyTpN1Inside1::((TyMzVisited[TI10]<0))[TyTpChBacktrack][TyTpN1Inside2];  #obstruction good, else check next following


#TyTpN1Inside2::TI08+=TyMzDirYInc[TI05];
#TI09+=TyMzDirXInc[TI05];    # row,col of the 2nd following
#TI01=1;
#((TI08<0))TI01=0;
#((TI08>=TyMzYsize))TI01=0;
#((TI09<0))TI01=0;
#((TI09>=TyMzXsize))TI01=0;
#((TI01==1))[TyTpN2Inside][TyTpChBacktrack];  # inside check visited, outside now move to backtrack check


#TyTpN2Inside::TI10=TI08*TyMzXSize;
#TI10+=TI09;
#((TyMzVisited[TI10]<=0))TyTpChBacktrack;  # not visited or obstruction ok


#go three in the 90 direction, final one must be inside. All must be unvisited
#TI08 is the dir to go (1-4)
#return TI01 0 = reject, 1 = ok.

#TyTpCheckBack::TI09=TI06+TyMzDirYInc[TI08];
#TI10=TI07+TyMzDirXInc[TI08];    #TI09,TI10  +1 90
#TI11=TI09+TyMzDirYInc[TI08];
#TI12=TI10+TyMzDirXInc[TI08];    #TI11,TI12  +2 90
#TI13=TI11+TyMzDirYInc[TI08];
#TI14=TI12+TyMzDirXInc[TI08];    #TI13,TI14  +3 90
#TI01=1;
#((TI13<0))TI01=0;
#((TI13>=TyMzYsize))TI01=0;
#((TI14<0))TI01=0;
#((TI14>=TyMzXsize))TI01=0;
#((TI01==1))TyTpBack3VisChk;   # range inside check visited


#TyTpBack3VisChk::TI08=TI09*TyMzXsize;
#TI08+=TI10;
#((TyMzVisited[TI08]!=0))TI01=0;
#TI08=TI11*TyMzXsize;
#TI08+=TI12;
#((TyMzVisited[TI08]!=0))TI01=0;
#TI08=TI13*TyMzXsize;
#TI08+=TI14;
#((TyMzVisited[TI08]!=0))TI01=0;

### we have some unvisited neighbors, the directions are in the array
# pick a random neighbor. Add that neighbor to the collection.
# Set current cell only with the direction bit we are going. Set neighbor as the maze does
# TI02, TI03: cell row,col:

TyTpPickNext::TI01=TyMzSizeNeighbors-1;
TI01=random(0)(TI01);         # pick a random neighbor
TI05=TyMzNeighbors[TI01];     # get direction we picked
# set current cell visited direction
TI06=TI02*TyMzXsize;
TI06+=TI03;                   #index for cell
TyMzVisited[TI06]+=TyMzDir2Bit[TI05];       #direction added, remember so we only try a dir once
TI06=TyMzDirYInc[TI05]+TI02;       #row increment for direction
TI07=TyMzDirXInc[TI05]+TI03;       #col increment for direction
TyMzYset[TyMzSizeSet]=TI06;
TyMzXset[TyMzSizeSet]=TI07;
TyMzSizeSet+=1;               #neighbor added to collection
TI08=TI06*TyMzXsize;
TI08+=TI07;                   #index of neighbor
TyMzVisited[TI08]=TyMzDirB2Bit[TI05];       #back direction
#TI06+=TyMzSPY1;   #debug
#TI07+=TyMzSPX1;   #debug
#place:TI06,TI07,$(tErosion1);   #debug

TyTpDraw::TyMzSL03=0;
TyTpDrawLoop;
TyabBusy=0;

TyTpDrawLoop::TyProbTile;
TI02=TyMzYset[TyMzSL03]+TyMzSPY1;
TI03=TyMzXset[TyMzSL03]+TyMzSPX1;
TI01=TI02-TynY1;
TI01*=TynXtiles;
TI01+=TI03;
TI01-=TynX1;
TyMapTiles[TI01]=RI01;
TyMzSL03+=1;
((TyMzSL03<TyMzSizeSet))TyTpDrawLoop;

#.#################### TyabObstructAdd #####################################
# helper function to add all of the cells for a region to the obstruction list
# input:
#  PY1, PX1  Upper left corner of region
#  PY2, PX2  Lower right corner of region (inclusive) 
#  PI05 Current number of cells in the obstruction list.
#       First time, set to 0, don't touch on later calls
#  PIA03, PIA04   row,col for existing obstruction cells
# output:
#  PI05 Updated with number of cells in input region
#  PIA03, PIA04  row,col with new cells at end
#EVENT
TyabObstructAdd::L01=PY1;   #start row
TyObAddRL;

#EVENT
TyObAddRL::L02=PX1;     #start col
TyObAddCL;
L01+=1;                 #next col
((L01<=PY2))TyObAddRL;

#EVENT
TyObAddCL::PIA03[PI05]=L01;  #save row
PIA04[PI05]=L02;             #save col
PI05+=1;                #added entry
L02+=1;                 #next col
((L02<=PX2))TyObAddCL;

#.############################# TyabFlood ##################################

#storage for every region
intarray TyFlPY1
intarray TyFlPX1
intarray TyFlPX2
intarray TyFlPY2
intarray TyFlPI01
intarray TyFlPI02
intarray TyFlPI03
intarray TyFlPI05
intarray TyFlFIndex   # oldest cell in region (0 is empty)
intarray TyFlLIndex   # newest cell in region (0 is empty)

int TyFlNRegions=0   #number of regions
int TyFlRegNum=0     #region to process

# this is our grow only heap used by all regions, this allows any number of regions and we treat it like a single direction linked list
intarray TyFlRow
intarray TyFlCol
intarray TyFlTime
intarray TyFlNext     #index of next cell for this region (0 = end of list)
intarray TyFlDir      #N,S,E,W,NE,SE,SW,NW  N,S,E,W may only go that dir. 

int TyFlLLSize=0  #number of cells in linked list (so we know the end) Never shrinks unless all regions done (set back to 0)
int TyFlTNow=0    #time we are processing
intarray TyFlRndDir   # array used to mix up directions for more random growth
intarray TyFlDiag1    # map direction 1-4 to one of the diagonals that cover it
intarray TyFlDiag2    # map direction 1-4 to the other diagonal that covers it

#set heap to empty, no regions
#EVENT
TyFlInit::TyFlRow[0]=0;
TyFlCol[0]=0;
TyFlTime[0]=0;
TyFlNext[0]=0;
TyFlDir[0]=0;
TyFlLLSize=0;
TyFlNRegions=0;
TyFlRegNum=0;
# setup diagonal mapping used to see if a cell will be covered by ray diagonal checks
TyFlDiag1[0]=0;     # not used
TyFlDiag2[0]=0;     # not used
TyFlDiag1[1]=5;     # N is covered by NE
TyFlDiag2[1]=8;     # N is covered by NW
TyFlDiag1[2]=6;     # S is covered by SE
TyFlDiag2[2]=7;     # S is covered by SW
TyFlDiag1[3]=5;     # E is covered by NE
TyFlDiag2[3]=6;     # E is covered by SE
TyFlDiag1[4]=7;     # W is covered by SW
TyFlDiag2[4]=8;     # W is covered by NW
TyFlDiag1[5]=1;     # NE goes N
TyFlDiag2[5]=3;     # NE goes E
TyFlDiag1[6]=2;     # SE goes S
TyFlDiag2[6]=3;     # SE goes E
TyFlDiag1[7]=2;     # SW goes S
TyFlDiag2[7]=4;     # SW goes W
TyFlDiag1[8]=1;     # NW goes N
TyFlDiag2[8]=4;     # NW goes W

# will flood a region from a start point over time.
# only walkable tiles will be flooded. The exception is the start point - it will ALWAYS be turned into a flood tile.
# flooding for a region stops when there are no more unflooded walkable tiles that are touching a flooded tile.
# the entire region will be processed. For a tile to become flooded, it must have one of its N,S,E,W neighbors flooded except for the start - it is always flooded.
# This means you can have safe area surrounded by walls that will not be flooded. If you have a flood tile inside that space, it will flood.
# if the map is modified while flooding is in progress, it does not try and pick up that modification.
# flood regions may be queued - so you can have multiple regions. To reduce processing try to have non-overlapping regions.
# all internal vars are saved so it is safe to call any routine after this. All updates happen from the TyabTimer calls.
# in our list they are sorted by ready to process time, front of list has oldest one, end of the list is newest.
# input.
#   on init, push the start cell into linked list for that region with its start time.
#   For the 8 neighbors, add them to link list with expected start time.The start cell is the only one that spawns 8 neighbors.
#   Diagonals are 2x later (since we can't grow diagonal). Tag each cell with direction. Direction for start cell is -1.
#   TimeSlice processing:
#       for regions in queue   (we now wrap around so we don't have to do any move to back type of operations)
#           while cells and allowed draws
#               Look at first cell (oldest)
#               If time has expired
#                   if walkable or dir==-1
#                       if (dir == -1) or are any N,S,E,W flooded
#                       Yes - convert to flood - draw.  +1 number of draws.
#                           For each N,S,E,W if walkable - add that neighbor with dir 0. This allows backtracking paths to flood
#                           (this may result in same cell being added multiple times due to scan below, but that is ok)
#                          
#                   remove from list (we still access its data)
#                   get dir.
#                   If -1 or 0 nothing (start cell or N,S,E,W added above)
#                   if N, S, E, W spawn neighbor (if in range) in that direction only.
#                   if NE, spawn N, E and NE in those directions if they are in range
#                   if SE, spawn S, E and SE in those directions if they are in range
#                   if SW, spawn S, W and SW in those directions if they are in range
#                   if NW, spawn N, W and NW in those directions if they are in range
#               else
#                   done with region (oldest is not ready for processing - move to next region)       
#           while end
#           if we did a draw
#              return RI03=1 
#       for end
#       if all regions are empty, clear everything out.
#
# for each time slice only do a single region. After a region has a draw, move to end of queue. If a region does not have a draw
# move to next region.

#  PY1, PX1  Upper left corner of region
#  PY2, PX2  Lower right corner of region
#  PY3, PX3  Start point for flooding
#  PI01      Tile to flood with.
#  PI02      min time to wait before flooding a cell (100 = 1 second)
#  PI03      max tiles to change in a draw call - should be kept low for best visual appearance 1-3
#  PI04      Delay start of region processing (100 = 1 second)
#  PI05      2 = fill mode (everything is turned to flood) 1 = use Rays to cross areas, 0 = walkable flood only

TyabFlood::;
TyFlPY1[TyFlNRegions]=PY1;
TyFlPX1[TyFlNRegions]=PX1;
TyFlPY2[TyFlNRegions]=PY2;
TyFlPX2[TyFlNRegions]=PX2;
TyFlPI01[TyFlNRegions]=PI01;
TyFlPI02[TyFlNRegions]=PI02;
TyFlPI03[TyFlNRegions]=PI03;
TyFlPI05[TyFlNRegions]=PI05;
#add start cell
TF01=time;    # get current time
TF01*=100.0;  # we work in 1/100 of seconds
TF01+=0.5;    # round
TyFlTNow=TF01;    # current time
TyFlTNow+=PI04;   # add in start delay
TyFlLLSize+=1;  #this is index (we don't use index 0)
TyFlRow[TyFlLLSize]=PY3;
TyFlCol[TyFlLLSize]=PX3;
TyFlTime[TyFlLLSize]=TyFlTNow;  # time to process cell
TyFlNext[TyFlLLSize]=0;  # we are first cell
TyFlDir[TyFlLLSize]=TyNeg1;  # -1 is special for first cell
TyFlFIndex[TyFlNRegions]=TyFlLLSize;  # we are first
TyFlLIndex[TyFlNRegions]=TyFlLLSize;  # we are last
TyFlRegNum=TyFlNRegions;    # region
TyFlNRegions+=1;     # now we are in queue
((PI05>0))TyFlSetupRays;

# now add at the next cell time later to process its rays - put them in random order to mix up growths
TyFlSetupRays::TI03=TyFlLLSize;      # cell index
TI05=PY3;
TI06=PX3;
TyFlRndDir14;    # mix up 1-4 directions
TI07=TyFlRndDir[0];
TyFlAddNInRange;
TI07=TyFlRndDir[1];
TyFlAddNInRange;
TI07=TyFlRndDir[2];
TyFlAddNInRange;
TI07=TyFlRndDir[3];
TyFlAddNInRange;
TyFlRndDir58;    # mix up 5-8 directions
TI07=TyFlRndDir[4];
TyFlAddNInRange;
TI07=TyFlRndDir[5];
TyFlAddNInRange;
TI07=TyFlRndDir[6];
TyFlAddNInRange;
TI07=TyFlRndDir[7];
TyFlAddNInRange;

# mix up directions 1, 2, 3, 4 (N, S, E, W)
#EVENT
TyFlRndDir14::TyFlRndDir[0]=1;   # start off N, S, E, W
TyFlRndDir[1]=2;
TyFlRndDir[2]=3;
TyFlRndDir[3]=4;
TI10=random(0)(3);  # pick one to make first
TI11=TyFlRndDir[0];
TyFlRndDir[0]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(1)(3);  # pick one to make second
TI11=TyFlRndDir[1];
TyFlRndDir[1]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(2)(3);  # pick one to make third
TI11=TyFlRndDir[2];
TyFlRndDir[2]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;

# mix up directions 5, 6, 7, 8 (NE, SE, SW, NW)
#EVENT
TyFlRndDir58::TyFlRndDir[4]=5;   # start off NE, SE, SW, NW
TyFlRndDir[5]=6;
TyFlRndDir[6]=7;
TyFlRndDir[7]=8;
TI10=random(4)(7);  # pick one to make first
TI11=TyFlRndDir[4];
TyFlRndDir[4]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(5)(7);  # pick one to make second
TI11=TyFlRndDir[5];
TyFlRndDir[5]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI10=random(6)(7);  # pick one to make third
TI11=TyFlRndDir[6];
TyFlRndDir[6]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;


# force stop of all flooding
#EVENT
TyabFloodStop::TyFlInit;

#EVENT
TyFlRegionLInit::TF01=time;      # current time
TF01*=100.0;    # we work in 1/100 of seconds 
TF01+=0.5;      # round off
TyFlTNow=TF01;  # current time in int from scaled
L01=0;          # region count loop
L03=60;         # max number of cells to look at before we get out
TyabTimerDraw=0; # set to 1 if we did a draw. we exit after any region does a draw
RI02=0;         # assume all regions are empty, set to 1 if any region is not empty
TyFlRegionLoop;
((RI02==0))TyFlInit;  # all regions empty, so clear everything out

#EVENT
TyFlRegionLoop::((TyFlRegNum>=TyFlNRegions))TyFlRegNum=0;  #wrap around
TyFlBeginProcessRegion;
TyFlRegNum+=1;              # always move to next region - check for wrap around next time
TI01=TyabTimerDraw;   #0 nothing, 1=did draw
L01+=1;
((L01>=TyFlNRegions))TI01=1;
((L03<=0))TI01=1;      # only allow a limited number of cell visits
((TI01==0))TyFlRegionLoop;

# input
#   TyFlRegNum region index
# return
#   TyabTimerDraw 1= did a draw, 0 = no draw
#EVENT
TyFlBeginProcessRegion::L02=TyFlPI03[TyFlRegNum];      # number of draws allowed
TyFlProcessRegion;

# input
#   TyFlRegNum region index
# return
#   TyabTimerDraw 1= did a draw, 0 = no draw
#   RI02 1= not empty, 0 = empty
#EVENT
TyFlProcessRegion::TI03=TyFlFIndex[TyFlRegNum];   # first (oldest) cell index
((TI03>0))TyFlProcessCell;

#input TyFlRegNum region index, L02 number of draws remaining, TI03=cell index
#EVENT
TyFlProcessCell::RI02=1;         # region is not empty
((TyFlTNow>=TyFlTime[TI03]))TyFlCellTimeExpired;  # oldest cell is ready, else done with region

# this cell is ready for processing based on time.
#input TyFlRegNum region index, L02 number of draws remaining, TI03=cell index
#EVENT
TyFlCellTimeExpired::TI05=TyFlRow[TI03];
TI06=TyFlCol[TI03];
#inline the following
#iPY1=TI05;     #row
#iPX1=TI06;     #col
#iTyabGetTile;  #read single tile update map
TI02=TI05-TynY1;
TI02*=TynXtiles;
TI02+=TI06;
TI02-=TynX1;
iRI01=get(TI05)(TI06);
TyMapTiles[TI02]=iRI01;
# end inline iTyabGetTile
TI01=TyWalkTile[iRI01];
((TyFlDir[TI03]==TyNeg1))TI01=1;         # always make start cell a flood tile no matter what
((TyFlPI05[TyFlRegNum]==2))TI01=1;       # fill mode, convert everything to flood
((TI01==1))TyFlWalkable;                 # cell is walkable - make it a flood tile and do all that processing
TyFlRemoveCell;                          # remove from collection since we done with it
((TyFlPI05[TyFlRegNum]>0))TyFlCellAddDirs;   # add ray cells that we need to check
L03-=1;
((L02<=0))return;    # we only allow a given number of draws
((L03>0))TyFlProcessRegion;  # more checks allowed keep checking

#TyFlRegNum=region, TI03=cell index, TI05=cell row, TI06=cell col
#walkable tile or first one. If not first, we have to have one of N,S,E,W that is flooded to draw
TyFlWalkable::((TyFlPI05[TyFlRegNum]==2))[TyFlFillWalkable][TyFlNonFillWalkable];

# non-fill mode, check neighbors
TyFlNonFillWalkable::TI01=0;
((TyFlDir[TI03]==TyNeg1))TI01=1;  # first cell no neighbor check
TI07=1;
((TI01==0))TyFlCheckDirFlood;  # see if neighbor is flooded
TI07=2;
((TI01==0))TyFlCheckDirFlood;
TI07=3;
((TI01==0))TyFlCheckDirFlood;
TI07=4;
((TI01==0))TyFlCheckDirFlood;
((TI01==1))TyFlDrawTile;

# fill mode, do not check neighbors.
# iRI01 is current tile read from map
# TI02 index into TyMapTiles for the row,col

TyFlFillWalkable::iPI01=TyFlPI01[TyFlRegNum];   # tileid to flood with
((iPI01==iRI01))return;     # cell is already flood, ignore
TyMapTiles[TI02]=iPI01;
place:TI05,TI06,iPI01;      # draw new tile
L02-=1;                    # did a draw
TyabTimerDraw=1;           # we did a draw

#TyFlRegNum=region, TI01=0, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
# return TI01: 0 = neighbor not flooded, 1 = neighbor is flooded
#EVENT
TyFlCheckDirFlood::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
((TI08<TyFlPY1[TyFlRegNum]))return;  # outside
((TI08>TyFlPY2[TyFlRegNum]))return;  # outside
((TI09<TyFlPX1[TyFlRegNum]))return;  # outside
((TI09>TyFlPX2[TyFlRegNum]))return;  # outside
#inline
#iPY1=TI08;   #row
#iPX1=TI09;     #col
#iTyabGetTile;  # read tile, update map
TI01=TI08-TynY1;
TI01*=TynXtiles;
TI01+=TI09;
TI01-=TynX1;
iRI01=get(TI08)(TI09);
TyMapTiles[TI01]=iRI01;
#end inline
((iRI01==TyFlPI01[TyFlRegNum]))[TI01=1][TI01=0];  #return 1 if neighbor is already a flood tile

#this cell needs to be made a flood tile.
#EVENT
TyFlDrawTile::iPY1=TI05;
iPX1=TI06;
iPI01=TyFlPI01[TyFlRegNum];
iTyabDrawTile;
L02-=1;         # did a draw
TyabTimerDraw=1;         # we did a draw
TI01=TyFlPI05[TyFlRegNum];
((TyFlDir[TI03]==0))TI01=0;   #if this cell is a flood - it has no direction, so do not do any ray processing
((TI01==1))[TyFlChkWalkRays][TyFlChkWalkNoRays];

#EVENT
#ray mode, if start cell do nothing since we already added all its rays
TyFlChkWalkRays::((TyFlDir[TI03]>0))TyFldoChkWalkRays;  # not start, so see if ray dir matches a walk dir if so ,don't add it

TyFldoChkWalkRays::TyFlRndDir14;   # get random dirs 1-4
# if N,S,E,W neighbor is walkable add it to deal with backtrack paths already ignored. However don't do it if we will add it in TyFlCellAddDirs
TI07=TyFlRndDir[0];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[1];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[2];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0
TI07=TyFlRndDir[3];
TI01=1;
((TyFlDir[TI03]==TI07))TI01=0;      # if going that dir then it will be covered by ray
((TyFlDir[TI03]==TyFlDiag1[TI07]))TI01=0;   # check if diagonal covers it by ray
((TyFlDir[TI03]==TyFlDiag2[TI07]))TI01=0;   # check if diagonal covers it by ray
((TI01==1))TyFlAddWalkableNeighbor;  # add direction neighbor if it is walkable - special ID 0

# check walkables in random order, no ray checks
#EVENT
TyFlChkWalkNoRays::TyFlRndDir14;
TI07=TyFlRndDir[0];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[1];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[2];
TyFlAddWalkableNeighbor;
TI07=TyFlRndDir[3];
TyFlAddWalkableNeighbor;

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
TyFlAddWalkableNeighbor::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
TI07=0;    # clear dir since this will not itself spawn rays
((TI08<TyFlPY1[TyFlRegNum]))return;  # outside
((TI08>TyFlPY2[TyFlRegNum]))return;  # outside
((TI09<TyFlPX1[TyFlRegNum]))return;  # outside
((TI09>TyFlPX2[TyFlRegNum]))return;  # outside
# in range, add neighbor dir
# inline
#iPY1=TI08;
#iPX1=TI09;
#iTyabGetTile;
TI01=TI08-TynY1;
TI01*=TynXtiles;
TI01+=TI08;
TI01-=TynX1;
iRI01=get(TI08)(TI09);
TyMapTiles[TI01]=iRI01;
# end inline
((TyWalkTile[iRI01]==1))TyFlAddNDir;  # neighbor is walkable so add cell.

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8)
TyFlAddNInRange::TI08=TyMzDirYInc[TI07]+TI05;
TI09=TyMzDirXInc[TI07]+TI06;
TI01=1;
((TI08<TyFlPY1[TyFlRegNum]))return;     # outside
((TI08>TyFlPY2[TyFlRegNum]))return;     # outside
((TI09<TyFlPX1[TyFlRegNum]))return;     # outside
((TI09<=TyFlPX2[TyFlRegNum]))TyFlAddNDir;    # in range, add neighbor dir

#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col, TI07=direction (1-8), TI08,TI09=neighbor cell to add.
# also used by walkable to add N,S,E,W cells that have a dir of 0 to handle backtracking paths.

TyFlAddNDir::TyFlLLSize+=1;      #new cell
TyFlRow[TyFlLLSize]=TI08;
TyFlCol[TyFlLLSize]=TI09;
TI01=TyFlPI02[TyFlRegNum];         # time between cells
((TI07>4))TI01*=2;          # corner cells take 2x the time
TyFlTime[TyFlLLSize]=TyFlTNow+TI01;    # expire time based on now
TyFlNext[TyFlLLSize]=0;     # we are the new end
TyFlDir[TyFlLLSize]=TI07;   # direction
#now add to end of linked list
((TyFlFIndex[TyFlRegNum]==0))TyFlFIndex[TyFlRegNum]=TyFlLLSize;   #if first empty, this is first
TI01=TyFlLIndex[TyFlRegNum];      # get current last so we can update the last cell to point to this new end
TyFlLIndex[TyFlRegNum]=TyFlLLSize;  # now the end
((TI01>0))TyFlNext[TI01]=TyFlLLSize;   # prior end if there was one now points to this as the end

#TyFlRegNum=region, TI03=cell index 
# we always remove the oldest (first cell) it is the only one we look at so TI03 is the first one.

TyFlRemoveCell::TI01=TyFlNext[TI03];               # get our next
TyFlFIndex[TyFlRegNum]=TI01;              # set as first
((TI01==0))TyFlLIndex[TyFlRegNum]=TI01;   # completely empty now

# add the dirs for this cell
#TyFlRegNum=region, TI03=cell index TI05=cell row, TI06=cell col
TyFlCellAddDirs::TI07=TyFlDir[TI03];
((TI07>0))TyFlRayCellAddDirs;   # only add rays for cells that are themselves rays

TyFlRayCellAddDirs::((TI07<=4))[TyFlAddNInRange][TyFlAdd58NInRange];  # do dirs 1-4 or we have diagonal

# process a diagonal. First to the two primary dirs (random which one is first), then the diagonal
TyFlAdd58NInRange::;
TyFlRndDir[0]=TyFlDiag1[TI07];     # get first primary for this diagonal
TyFlRndDir[1]=TyFlDiag2[TI07];     # get second primary for this diagonal
TI10=random(0)(1);    # mix up which one is done first each time
TI11=TyFlRndDir[0];
TyFlRndDir[0]=TyFlRndDir[TI10];
TyFlRndDir[TI10]=TI11;
TI07=TyFlRndDir[0];   # first primary
TyFlAddNInRange;
TI07=TyFlRndDir[1];
TyFlAddNInRange;      # 2nd primary
TI07=TyFlDir[TI03];
TyFlAddNInRange;  # and go the actual diagonal

#.############################# TyabNotification ##################################
#### notification system based on a value that is decreasing
intarray TyabNotification         # fill in with values that define when to notify
intarray TyabNotificationDone     # matching index will be set to 1 when we have done the notification
int      TyabNotificationSize=0   # size of each array

TyabNotificationInit::TyabNotification[0]=2;
TyabNotification[1]=3;
TyabNotification[2]=4;
TyabNotification[3]=5;
TyabNotification[4]=6;
TyabNotification[5]=7;
TyabNotification[6]=9;
TyabNotification[7]=11;
TyabNotification[8]=16;
TyabNotification[9]=21;
TyabNotification[10]=26;
TyabNotification[11]=31;
TyabNotification[12]=41;
TyabNotification[13]=51;
TyabNotification[14]=61;
TyabNotification[15]=81;
TyabNotification[16]=101;
TyabNotification[17]=126;
TyabNotification[18]=151;
TyabNotification[19]=176;
TyabNotification[20]=201;
TyabNotification[21]=251;
TyabNotification[22]=301;
TyabNotification[23]=351;
TyabNotification[24]=401;
TyabNotification[25]=501;
TyabNotification[26]=601;
TyabNotification[27]=701;
TyabNotification[28]=801;
TyabNotification[29]=901;
TyabNotification[30]=1001;
TyabNotificationSize=31;
TyabNotificationReset;

# reset notification ranges for a new set of notifications
TyabNotificationReset::TyabNotificationDone[0]=0;
TyabNotificationDone[1]=0;
TyabNotificationDone[2]=0;
TyabNotificationDone[3]=0;
TyabNotificationDone[4]=0;
TyabNotificationDone[5]=0;
TyabNotificationDone[6]=0;
TyabNotificationDone[7]=0;
TyabNotificationDone[8]=0;
TyabNotificationDone[9]=0;
TyabNotificationDone[10]=0;
TyabNotificationDone[11]=0;
TyabNotificationDone[12]=0;
TyabNotificationDone[13]=0;
TyabNotificationDone[14]=0;
TyabNotificationDone[15]=0;
TyabNotificationDone[16]=0;
TyabNotificationDone[17]=0;
TyabNotificationDone[18]=0;
TyabNotificationDone[19]=0;
TyabNotificationDone[20]=0;
TyabNotificationDone[21]=0;
TyabNotificationDone[22]=0;
TyabNotificationDone[23]=0;
TyabNotificationDone[24]=0;
TyabNotificationDone[25]=0;
TyabNotificationDone[26]=0;
TyabNotificationDone[27]=0;
TyabNotificationDone[28]=0;
TyabNotificationDone[29]=0;
TyabNotificationDone[30]=0;

# input PI01 value to check
# output RI01: 1 value has already been seen for this range
#              0 value has not been seen for this range, it is now tagged as seen.
# values below the first range will always return 0. Values above the highest range map to that highest range
TyabNotificationCheckAndSet::L01=0;  # start at beginning
RI01=0;                            # assume notification for too small
((TyabNotificationSize>0))TyNChkL;   # if we have an array check it

TyNChkL::((PI01==TyabNotification[L01]))[TyNGetAndSet][TyNChkL1];  #handle equal

TyNChkL1::((PI01>TyabNotification[L01]))[TyNChkNext][TyNChkPast];  #handle > and <

TyNChkNext::L01+=1;
((L01<TyabNotificationSize))[TyNChkL][TyNChkPast];

# L01 is past the range
TyNChkPast::L01-=1;
((L01<0))return;                 # handle first one is too large
RI01=TyabNotificationDone[L01];  # get range flag
TyabNotificationDone[L01]=1;     # set that this range is done

TyNGetAndSet::RI01=TyabNotificationDone[L01];  # get range flag
TyabNotificationDone[L01]=1;                   # set that this range is done

### ------- Internal Tyab Command queue
# maze, path (others to come) are now serialized into a single intarray. All parameters are added to the queue
# this allows multiple calls to be made without worry if the previous call has finished or not. It is
# very useful when making chain paths.
# format:
#   method number:  0 = end of queue, 1 = maze, 2 = path, 3 = tight path, 4 = TyabQueueDrawRect
#   Total length:   total number of indexes needed to serial this command. This length defines how to find the next one.
#                    includes this value and the method number. 
#   following are the serialized values for each command. That is command specific and is done by the command itself.

intarray TyCmdQueue   # this is the queue
# only used to write commands
int      TyCmdWIndex=0  # current end+1. Can be == to start if empty While a command is serialzing it can update this value
int      TyCmdRIndex=0  # while reading index that updates during deserialization

# when writing a command. TyCmdWIndex always points to end+1 of last command written.
# When reading a command. TyCmdRIndex points to start of next command to read. IF same as TyCmdWIndex, queue is empty.

# set queue to empty
TyCmdEmpty::TyCmdWIndex=0;
TyCmdRIndex=0;
RI01=0;

### - path entry
TyabPath::TI01=2;
TyPathorTightSerialize;

### - tight path entry
TyabTightPath::TI01=3;
TyPathorTightSerialize;

TyPathorTightSerialize::TI02=TyCmdWIndex;   # save start for length calculation
TyCmdQueue[TyCmdWIndex]=TI01;               # add command index
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY3;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX3;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY4;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX4;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # path width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI02;   # cell width
TyCmdWIndex+=1;
TyCmdSerializeProbData;         # serialized PI04 and PIA01 and PIA02
TyCmdSerializeObstruct;         # serialized PI05 and PIA03 and PIA04
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

### - maze entry
TyabMaze::TI02=TyCmdWIndex;  # get ready to serialize, start always has where to start
TyCmdQueue[TyCmdWIndex]=1;   # maze ID
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # path width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI02;   # cell width
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI03;   # walls
TyCmdWIndex+=1;
TyCmdSerializeProbData;         # serialized PI04 and PIA01 and PIA02
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

TyabQueueDrawRect::TI02=TyCmdWIndex;  # get ready to serialize, start always has where to start
TyCmdQueue[TyCmdWIndex]=4;   # draw queue rect
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=0;   # we don't know the length yet
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX1;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PY2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PX2;
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PI01;   # draw code
TyCmdWIndex+=1;
TyCmdSetSize;                   # fill in size data and have pointers ready for next one.

TyCmdSerializeProbData::TyCmdQueue[TyCmdWIndex]=PI04;      # serialized PI04 and PIA01 and PIA02
TyCmdWIndex+=1;
L01=0;
((PI04>0))TyCmdSerProbDataL;

TyCmdSerProbDataL::TyCmdQueue[TyCmdWIndex]=PIA01[L01]; # save probability
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PIA02[L01];                    # save tile id for that probability
TyCmdWIndex+=1;
L01+=1;
((L01<PI04))TyCmdSerProbDataL;

TyCmdSerializeObstruct::TyCmdQueue[TyCmdWIndex]=PI05;      # serialized PI05 and PIA03 and PIA04
TyCmdWIndex+=1;
L01=0;
((PI05>0))TyCmdSerObstL;

TyCmdSerObstL::TyCmdQueue[TyCmdWIndex]=PIA03[L01];   # row
TyCmdWIndex+=1;
TyCmdQueue[TyCmdWIndex]=PIA04[L01]; # col
TyCmdWIndex+=1;
L01+=1;
((L01<PI05))TyCmdSerObstL;

#TI02 has start index of command prior to write
TyCmdSetSize::TI01=TyCmdWIndex-TI02;   # length of this one.
TI02+=1;                        # 2nd parameter is length
TyCmdQueue[TI02]=TI01;          # save length
TyCmdQueue[TyCmdWIndex]=0;      # put end of queue marker just in case

# process next command.
# return RI01=1 a command was run. 0 = queue empty
TyCmdNextCommand::RI01=0;
((TyCmdRIndex<TyCmdWIndex))[TyCmdDoNextComamnd][TyCmdEmpty];

TyCmdDoNextComamnd::RI01=1;
((TyCmdQueue[TyCmdRIndex]==1))[TyCmdRMaze][TyCmdRNot1];

TyCmdRNot1::((TyCmdQueue[TyCmdRIndex]==2))[TyCmdRPath][TyCmdRNot2];

TyCmdRNot2::((TyCmdQueue[TyCmdRIndex]==3))[TyCmdRTPath][TyCmdRNot3];

TyCmdRNot3::((TyCmdQueue[TyCmdRIndex]==4))[TyCmdRQueueDrawRect][TyCmdRNot4];

TyCmdRNot4::TyCmdEmpty;   # unknown, treat as queue empty

# process maze command
TyCmdRMaze::TyCmdRIndex+=2;  # skip ID and length
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];   # path width
TyCmdRIndex+=1;
PI02=TyCmdQueue[TyCmdRIndex];   # cell width
TyCmdRIndex+=1;
PI03=TyCmdQueue[TyCmdRIndex];   # walls
TyCmdRIndex+=1;
TyCmdDeSerializeProbData;  # serialized PI04 and PIA01 and PIA02
TyIMaze;                   # internal maze         

# process path command
TyCmdRPath::TyCmdPathorTightDeSerialize;
TyIPath;    # internal path routine

# process tight path command
TyCmdRTPath::TyCmdPathorTightDeSerialize;
TyITightPath; #internal tight path routine

TyCmdPathorTightDeSerialize::TyCmdRIndex+=2;  #skip command and length
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY3=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX3=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY4=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX4=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];   # path width
TyCmdRIndex+=1;
PI02=TyCmdQueue[TyCmdRIndex];   # cell width
TyCmdRIndex+=1;
TyCmdDeSerializeProbData;       # deserialized PI04 and PIA01 and PIA02
TyCmdDeSerializeObstruct;       # deserialized PI05 and PIA03 and PIA04

TyCmdRQueueDrawRect::TyCmdRIndex+=1;              #skip command, already processed
TyCmdRIndex+=1;              #skip length, don't need
PY1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX1=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PY2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PX2=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
PI01=TyCmdQueue[TyCmdRIndex];
TyCmdRIndex+=1;
TyabDrawRect;

TyCmdDeSerializeProbData::PI04=TyCmdQueue[TyCmdRIndex];      # deserialized PI04 and PIA01 and PIA02
TyCmdRIndex+=1;
L01=0;
((PI04>0))TyCmdDeSerProbDataL;

TyCmdDeSerProbDataL::PIA01[L01]=TyCmdQueue[TyCmdRIndex]; # get probability
TyCmdRIndex+=1;
PIA02[L01]=TyCmdQueue[TyCmdRIndex];                    # get tile id for that probability
TyCmdRIndex+=1;
L01+=1;
((L01<PI04))TyCmdDeSerProbDataL;

TyCmdDeSerializeObstruct::PI05=TyCmdQueue[TyCmdRIndex];      # deserialized PI05 and PIA03 and PIA04
TyCmdRIndex+=1;
L01=0;
((PI05>0))TyCmdDeSerObstL;

TyCmdDeSerObstL::PIA03[L01]=TyCmdQueue[TyCmdRIndex];   # row
TyCmdRIndex+=1;
PIA04[L01]=TyCmdQueue[TyCmdRIndex]; # col
TyCmdRIndex+=1;
L01+=1;
((L01<PI05))TyCmdDeSerObstL;


#. End --- TyabGenericScript.scr
